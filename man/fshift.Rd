% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spct.fshift.r
\name{fshift}
\alias{fshift}
\alias{fshift.default}
\alias{fshift.source_spct}
\alias{fshift.response_spct}
\alias{fshift.filter_spct}
\alias{fshift.reflector_spct}
\alias{fshift.source_mspct}
\alias{fshift.raw_spct}
\alias{fshift.cps_spct}
\alias{fshift.generic_spct}
\alias{fshift.response_mspct}
\alias{fshift.filter_mspct}
\alias{fshift.reflector_mspct}
\alias{fshift.raw_mspct}
\alias{fshift.cps_mspct}
\alias{fshift.generic_mspct}
\title{Shift the scale of a spectrum using a summary function}
\usage{
fshift(x, ...)

\method{fshift}{default}(x, ...)

\method{fshift}{source_spct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

\method{fshift}{response_spct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

\method{fshift}{filter_spct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...
)

\method{fshift}{reflector_spct}(x, range = c(wl_min(x), wl_min(x) + 10), f = "min", qty.out = NULL, ...)

\method{fshift}{source_mspct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...
)

\method{fshift}{raw_spct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  qty.out = NULL,
  ...
)

\method{fshift}{cps_spct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  qty.out = NULL,
  ...
)

\method{fshift}{generic_spct}(x, range = c(wl_min(x), wl_min(x) + 10), f = "mean", col.names, ...)

\method{fshift}{response_mspct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "mean",
  unit.out = getOption("photobiology.radiation.unit", default = "energy"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

\method{fshift}{filter_mspct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  qty.out = getOption("photobiology.filter.qty", default = "transmittance"),
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

\method{fshift}{reflector_mspct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  qty.out = NULL,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

\method{fshift}{raw_mspct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

\method{fshift}{cps_mspct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  ...,
  .parallel = FALSE,
  .paropts = NULL
)

\method{fshift}{generic_mspct}(
  x,
  range = c(wl_min(x), wl_min(x) + 10),
  f = "min",
  col.names,
  ...,
  .parallel = FALSE,
  .paropts = NULL
)
}
\arguments{
\item{x}{An R object}

\item{...}{additional named arguments passed down to \code{f}.}

\item{range}{An R object on which \code{range()} returns a numeric vector of
length 2 with the limits of a range of wavelengths in nm, with min and max
wavelengths (nm)}

\item{f}{character string "mean", "min" or "max" for scaling so that this
summary value becomes the origin of the spectral data scale in the returned
object, or the name of a function taking \code{x} as first argument and
returning a numeric value.}

\item{unit.out}{character Allowed values "energy", and "photon", or its alias
"quantum"}

\item{qty.out}{character Allowed values "transmittance", and "absorbance"}

\item{col.names}{character vector containing the names of columns or
variables to which to apply the scale shift.}

\item{.parallel}{if TRUE, apply function in parallel, using parallel backend
provided by foreach}

\item{.paropts}{a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example)
your code relies on external data or packages: use the .export and
.packages arguments to supply them so that all cluster nodes have the
correct environment set up for computing.}
}
\value{
A copy of \code{x} with the spectral data values replaced with values
  zero-shifted.

a new object of the same class as \code{x}.
}
\description{
The \code{fshift()} methods return a spectral object of the same class as the
one supplied as argument but with the spectral data on a zero-shifted scale.
A range of wavelengths is taken as a zero reference and the summary
calculated with \code{f} for this waveband is substracted. This results in a
zero shift (= additive correction) to the values in the returned object.
Metadata attributes are retained unchanged.
}
\section{Methods (by class)}{
\itemize{
\item \code{fshift(default)}: Default for generic function

\item \code{fshift(source_spct)}: 

\item \code{fshift(response_spct)}: 

\item \code{fshift(filter_spct)}: 

\item \code{fshift(reflector_spct)}: 

\item \code{fshift(source_mspct)}: 

\item \code{fshift(raw_spct)}: 

\item \code{fshift(cps_spct)}: 

\item \code{fshift(generic_spct)}: 

\item \code{fshift(response_mspct)}: 

\item \code{fshift(filter_mspct)}: 

\item \code{fshift(reflector_mspct)}: 

\item \code{fshift(raw_mspct)}: 

\item \code{fshift(cps_mspct)}: 

\item \code{fshift(generic_mspct)}: 

}}
\note{
Method \code{fshift} is not implemented for \code{solute_spct} objects
  as the spectral data stored in them are a description of an intensive
  property of a substance. To represent solutions of specific concentrations
  of solutes, \code{filter_spct} objects can be used.
}
\seealso{
Other rescaling functions: 
\code{\link{fscale}()},
\code{\link{getNormalized}()},
\code{\link{getScaled}()},
\code{\link{is_normalized}()},
\code{\link{is_scaled}()},
\code{\link{normalize}()},
\code{\link{setNormalized}()},
\code{\link{setScaled}()}
}
\concept{rescaling functions}
