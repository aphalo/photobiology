<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Pedro J. Aphalo" />

<meta name="date" content="2025-06-21" />

<title>User Guide: 1 Radiation</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">User Guide: 1 Radiation</h1>
<h3 class="subtitle">Package ‘photobiology’ 0.13.0.9000</h3>
<h4 class="author">Pedro J. Aphalo</h4>
<h4 class="date">2025-06-21</h4>


<div id="TOC">
<ul>
<li><a href="#radiation-astronomy-and-atmosphere" id="toc-radiation-astronomy-and-atmosphere">Radiation, astronomy and
atmosphere</a></li>
<li><a href="#naming-conventions" id="toc-naming-conventions">Naming
conventions</a></li>
<li><a href="#high-and-low-level-functions" id="toc-high-and-low-level-functions">High and low level
functions</a></li>
<li><a href="#example-data" id="toc-example-data">Example data</a></li>
<li><a href="#spectra" id="toc-spectra">Spectra</a>
<ul>
<li><a href="#getting-started" id="toc-getting-started">Getting
started</a></li>
<li><a href="#classes" id="toc-classes">Classes</a></li>
<li><a href="#data-assumptions" id="toc-data-assumptions">Data
assumptions</a></li>
<li><a href="#querying-the-class" id="toc-querying-the-class">Querying
the class</a></li>
<li><a href="#construction" id="toc-construction">Construction</a></li>
<li><a href="#metadata-attributes" id="toc-metadata-attributes">Metadata
attributes</a></li>
</ul></li>
<li><a href="#collections-of-spectra" id="toc-collections-of-spectra">Collections of spectra</a>
<ul>
<li><a href="#classes-1" id="toc-classes-1">Classes</a></li>
<li><a href="#construction-1" id="toc-construction-1">Construction</a></li>
<li><a href="#conversion-into-a-wide-data-frame" id="toc-conversion-into-a-wide-data-frame">Conversion into a “wide” data
frame</a></li>
<li><a href="#querying-the-class-1" id="toc-querying-the-class-1">Querying the class</a></li>
<li><a href="#extract-replace-and-combine" id="toc-extract-replace-and-combine">Extract, replace and
combine</a></li>
<li><a href="#random-sampling" id="toc-random-sampling">Random
sampling</a></li>
<li><a href="#transform-or-apply-functions" id="toc-transform-or-apply-functions">Transform or <em>apply</em>
functions</a></li>
<li><a href="#summary-spectra" id="toc-summary-spectra">Summary
spectra</a></li>
<li><a href="#convolution" id="toc-convolution">Convolution</a></li>
<li><a href="#metadata-attributes-1" id="toc-metadata-attributes-1">Metadata attributes</a></li>
</ul></li>
<li><a href="#wavebands" id="toc-wavebands">Wavebands</a>
<ul>
<li><a href="#construction-2" id="toc-construction-2">Construction</a></li>
<li><a href="#querying-the-class-2" id="toc-querying-the-class-2">Querying the class</a></li>
<li><a href="#retrieving-properties" id="toc-retrieving-properties">Retrieving properties</a></li>
</ul></li>
<li><a href="#collections-of-wavebands" id="toc-collections-of-wavebands">Collections of wavebands</a>
<ul>
<li><a href="#construction-3" id="toc-construction-3">Construction</a></li>
</ul></li>
<li><a href="#object-inspection-methods" id="toc-object-inspection-methods">Object <em>inspection</em>
methods</a>
<ul>
<li><a href="#printing" id="toc-printing">Printing</a></li>
<li><a href="#summary" id="toc-summary">Summary</a></li>
<li><a href="#handling-nas" id="toc-handling-nas">Handling
<code>NA</code>s</a></li>
</ul></li>
<li><a href="#transformations-using-operators" id="toc-transformations-using-operators">Transformations: using
operators</a>
<ul>
<li><a href="#binary-operators" id="toc-binary-operators">Binary
operators</a></li>
<li><a href="#unary-operators-and-maths-functions" id="toc-unary-operators-and-maths-functions">Unary operators and maths
functions</a></li>
<li><a href="#options" id="toc-options">Options</a></li>
</ul></li>
<li><a href="#transformations-methods-and-functions" id="toc-transformations-methods-and-functions">Transformations: methods
and functions</a>
<ul>
<li><a href="#manipulating-spectra" id="toc-manipulating-spectra">Manipulating spectra</a></li>
<li><a href="#conversions-between-radiation-units" id="toc-conversions-between-radiation-units">Conversions between
radiation units</a></li>
<li><a href="#conversions-among-transmission-quantities" id="toc-conversions-among-transmission-quantities">Conversions among
transmission quantities</a></li>
<li><a href="#normalizing-a-spectrum" id="toc-normalizing-a-spectrum">Normalizing a spectrum</a></li>
<li><a href="#rescaling-a-spectrum" id="toc-rescaling-a-spectrum">Rescaling a spectrum</a></li>
<li><a href="#shifting-the-zero-of-the-spectral-data-scale" id="toc-shifting-the-zero-of-the-spectral-data-scale">Shifting the zero
of the spectral data scale</a></li>
<li><a href="#replacing-off-range-spectral-data-values" id="toc-replacing-off-range-spectral-data-values">Replacing off-range
spectral data values</a></li>
<li><a href="#removing-spikes" id="toc-removing-spikes">Removing
spikes</a></li>
<li><a href="#smoothing-of-spectra" id="toc-smoothing-of-spectra">Smoothing of spectra</a></li>
<li><a href="#wavelength-interpolation" id="toc-wavelength-interpolation">Wavelength interpolation</a></li>
<li><a href="#trimming-clipping-and-thining" id="toc-trimming-clipping-and-thining">Trimming, clipping and
thining</a></li>
<li><a href="#convolving-weights" id="toc-convolving-weights">Convolving
weights</a></li>
<li><a href="#tagging-with-bands-and-colours" id="toc-tagging-with-bands-and-colours">Tagging with bands and
colours</a></li>
</ul></li>
<li><a href="#summaries" id="toc-summaries">Summaries</a>
<ul>
<li><a href="#summary-1" id="toc-summary-1">Summary</a></li>
<li><a href="#wavelength" id="toc-wavelength">Wavelength</a></li>
<li><a href="#peaks-valleys-and-spikes" id="toc-peaks-valleys-and-spikes">Peaks, valleys and spikes</a></li>
<li><a href="#wavelengths-at-target-value" id="toc-wavelengths-at-target-value">Wavelengths at target
value</a></li>
<li><a href="#irradiance" id="toc-irradiance">Irradiance</a></li>
<li><a href="#fluence" id="toc-fluence">Fluence</a></li>
<li><a href="#photon-and-energy-ratios" id="toc-photon-and-energy-ratios">Photon and energy ratios</a></li>
<li><a href="#transmittance-reflectance-absorptance-and-absorbance" id="toc-transmittance-reflectance-absorptance-and-absorbance">Transmittance,
reflectance, absorptance and absorbance</a></li>
<li><a href="#normalized-difference-indexes" id="toc-normalized-difference-indexes">Normalized difference
indexes</a></li>
<li><a href="#integrated-response" id="toc-integrated-response">Integrated response</a></li>
<li><a href="#integration-over-wavelengths" id="toc-integration-over-wavelengths">Integration over
wavelengths</a></li>
</ul></li>
<li><a href="#comparison-of-spectra" id="toc-comparison-of-spectra">Comparison of spectra</a></li>
<li><a href="#illumination-and-light-as-seen-by-humans" id="toc-illumination-and-light-as-seen-by-humans">Illumination and light
as seen by humans</a>
<ul>
<li><a href="#illuminance" id="toc-illuminance">Illuminance</a></li>
<li><a href="#cct-and-cri" id="toc-cct-and-cri">CCT and CRI</a></li>
<li><a href="#rgb-colours" id="toc-rgb-colours">RGB colours</a></li>
</ul></li>
</ul>
</div>

<div id="radiation-astronomy-and-atmosphere" class="section level2">
<h2>Radiation, astronomy and atmosphere</h2>
<p>The User Guide was earlier divided into two parts: <em>1.
Radiation</em> and <em>2. Astronomy</em>. The astronomy related
functions and the <a href="https://docs.r4photobiology.info/SunCalcMeeus/articles/userguide-1-astronomy.html">former
part 2 of this User Guide</a> are now in package ‘SunCalcMeeus’. This
User Guide is the updated version of former part 1.</p>
</div>
<div id="naming-conventions" class="section level2">
<h2>Naming conventions</h2>
<p>I have developed package ‘<strong>photobiology</strong>’ over several
years, and even though I have tried to remain consistent, some
inconsistencies have crept in. I have attempted to correct
inconsistencies without breaking old code by providing synonyms for some
functions.</p>
<p>In general I have used names in <em>snake case</em> for methods and
functions, such as <code>source_spct()</code> and <em>dot case</em> for
their arguments. There are two exceptions to this: the <code>as.</code>
and <code>is.</code> methods which for consistency with base R, retain
the dot: <code>as.source_spct()</code> and
<code>ìs.source_spct()</code>. There are still some functions and
methods whose names are in <em>camel case</em>: these are mostly
accessors and setters of metadata attributes such as
<code>setWhatMeasured()</code> and <code>getWhatMeasured()</code>, in
which case synonyms <code>what_measured&lt;-()</code> and
<code>what_measured()</code> are now provided with a syntax that
parallels that of R’s <code>comment&lt;-()</code>,
<code>comment()</code>, and similar methods for other attributes. Names
of attributes themselves use dots, while classes use snake case as
functions do, allowing consistency between class names and their
constructor functions. There is an additional twist: functions named
like <code>clip_wl()</code> are “verbs” that act on the wavelengths
(“wl”) modifying them, while those named like <code>wl_range()</code>
are “nouns” for the properties of the wavelengths.</p>
<p>In examples we use variable names ending in <code>.spct</code> for
spectra, ending in <code>.mspct</code> for collections of spectra and
ending in <code>.tb</code> for tibbles. In most cases the root of the
variable names use “snake case” and may have a tag at the end separated
with a dot. In the case of variable names used in examples I have been
less strict about conventions than for the objects exported by the
package.</p>
<p>None of these naming conventions are enforced for user defined
objects and classes; these conventions are simply those I have tried to
follow while developing this package as well as other packages in the
r4photobiology suite.</p>
</div>
<div id="high-and-low-level-functions" class="section level2">
<h2>High and low level functions</h2>
<p>The package exports two sets of functions for many operations:
low-level functions programmed following a functional paradigm, and
higher-level functions using an object-oriented paradigm. The former
functions take as arguments numeric vectors and are sometimes faster.
The later ones take <em>spectra</em> objects as arguments, are easier to
use, and at least at the moment, to some extent slower. For everyday
use, methods for <em>spectra</em> objects are recommended, but when
maximum performance or flexibility in scripts is desired, the use of the
functions taking numeric vectors as arguments may allow optimizations
that are not possible with the object-oriented functions. The
differences in performance becomes relevant only in extreme cases such
as processing in a single script tenths of thousands of spectra. In the
vignettes we emphasize the use of the object-oriented classes and
methods.</p>
</div>
<div id="example-data" class="section level2">
<h2>Example data</h2>
<p>Data for several spectra are included for use in examples and
vignettes, and in testing (Tables 1 and 2). Other packages in the
‘<strong>r4photobiology suite</strong>’ provide many additional data
sets.</p>
<hr />
<p><strong>Table 1. Data sets included in the package: spectra.</strong>
The CIE standard illuminant data in this package are normalized to one
at <span class="math inline">\(\lambda = 560\,\)</span>nm, while in the
CIE standard they are normalized to 100 at the same wavelength. See
documentation for each data object for details and data sources.</p>
<table>
<colgroup>
<col width="19%" />
<col width="19%" />
<col width="19%" />
<col width="42%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Object</th>
<th align="left">class</th>
<th align="left">units</th>
<th align="left">data description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>sun.spct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left"><span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span></td>
<td align="left">solar spectral irradiance</td>
</tr>
<tr class="even">
<td align="left"><code>sun_daily.spct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left"><span class="math inline">\(J\,m^{-2}\,d^{-1}\,nm^{-1}\)</span></td>
<td align="left">solar spectral exposure</td>
</tr>
<tr class="odd">
<td align="left"><code>sun.data</code></td>
<td align="left"><code>data.frame</code></td>
<td align="left"><span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span></td>
<td align="left">solar spectral irradiance</td>
</tr>
<tr class="even">
<td align="left"><code>sun_daily.data</code></td>
<td align="left"><code>data.frame</code></td>
<td align="left"><span class="math inline">\(J\,m^{-2}\,d^{-1}\,nm^{-1}\)</span></td>
<td align="left">solar spectral exposure</td>
</tr>
<tr class="odd">
<td align="left"><code>D65.illuminant.spct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left">(norm. 560 nm)</td>
<td align="left">CIE standard</td>
</tr>
<tr class="even">
<td align="left"><code>A.illuminant.spct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left">(norm. 560 nm)</td>
<td align="left">CIE standard</td>
</tr>
<tr class="odd">
<td align="left"><code>clear.spct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">fraction</td>
<td align="left">ideal transparent filter</td>
</tr>
<tr class="even">
<td align="left"><code>opaque.spct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">fraction</td>
<td align="left">ideal opaque filter</td>
</tr>
<tr class="odd">
<td align="left"><code>polyester.spct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">fraction</td>
<td align="left">plastic film</td>
</tr>
<tr class="even">
<td align="left"><code>yellow_gel.spct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">fraction</td>
<td align="left">theatrical <em>gel</em> filter</td>
</tr>
<tr class="odd">
<td align="left"><code>green_leaf.spct</code></td>
<td align="left"><code>reflector_spct</code></td>
<td align="left">fraction</td>
<td align="left">a birch leaf</td>
</tr>
<tr class="even">
<td align="left"><code>clear_body.spct</code></td>
<td align="left"><code>object_spct</code></td>
<td align="left">fraction</td>
<td align="left">ideal transparent body</td>
</tr>
<tr class="odd">
<td align="left"><code>black_body.spct</code></td>
<td align="left"><code>object_spct</code></td>
<td align="left">fraction</td>
<td align="left">ideal black body</td>
</tr>
<tr class="even">
<td align="left"><code>white_body.spct</code></td>
<td align="left"><code>object_spct</code></td>
<td align="left">fraction</td>
<td align="left">ideal white body</td>
</tr>
<tr class="odd">
<td align="left"><code>Ler_leaf.spct</code></td>
<td align="left"><code>object_spct</code></td>
<td align="left">fraction</td>
<td align="left">Arabidopsis leaf</td>
</tr>
<tr class="even">
<td align="left"><code>Ler_leaf_trns.spct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">fraction</td>
<td align="left">Arabidopsis leaf (T total)</td>
</tr>
<tr class="odd">
<td align="left"><code>Ler_leaf_trns_i.spct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">fraction</td>
<td align="left">Arabidopsis leaf (T internal)</td>
</tr>
<tr class="even">
<td align="left"><code>Ler_leaf_rflt.spct</code></td>
<td align="left"><code>reflector_spct</code></td>
<td align="left">fraction</td>
<td align="left">Arabidopsis leaf (R total)</td>
</tr>
<tr class="odd">
<td align="left"><code>water.spct</code></td>
<td align="left"><code>solute_spct</code></td>
<td align="left"><span class="math inline">\(m^{-1}\)</span></td>
<td align="left">pure water molar att. coef.</td>
</tr>
<tr class="even">
<td align="left"><code>phenylalanine</code></td>
<td align="left"><code>solute_spct</code></td>
<td align="left"><span class="math inline">\(m^{-1}\)</span></td>
<td align="left">phenylalanine molar att. coef.</td>
</tr>
<tr class="odd">
<td align="left"><code>photodiode.spct</code></td>
<td align="left"><code>response_spct</code></td>
<td align="left"><span class="math inline">\(A / W\)</span></td>
<td align="left">typical Si photodiode</td>
</tr>
<tr class="even">
<td align="left"><code>ccd.spct</code></td>
<td align="left"><code>response_spct</code></td>
<td align="left"><span class="math inline">\(A / W\)</span></td>
<td align="left">typical CCD array</td>
</tr>
<tr class="odd">
<td align="left"><code>white_led.raw_spct</code></td>
<td align="left"><code>raw_spct</code></td>
<td align="left">counts</td>
<td align="left">example raw detector counts data</td>
</tr>
<tr class="even">
<td align="left"><code>white_led.cps_spct</code></td>
<td align="left"><code>cps_spct</code></td>
<td align="left">counts / s</td>
<td align="left">example detector counts data</td>
</tr>
<tr class="odd">
<td align="left"><code>white_led.source_spct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left"><span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span></td>
<td align="left">spectral irradiance</td>
</tr>
<tr class="even">
<td align="left"><code>filter_cps.mspct</code></td>
<td align="left"><code>cps_mspct</code></td>
<td align="left"><span class="math inline">\(\mathrm{counts} /
s\)</span></td>
<td align="left">example detector counts data</td>
</tr>
</tbody>
</table>
<hr />
<hr />
<p><strong>Table 2. Data sets included in the package: chromaticity
data.</strong> See documentation for each data object for details and
data sources.</p>
<table>
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="58%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Object</th>
<th align="left">class</th>
<th align="left">data description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ciexyzCC2.spct</code></td>
<td align="left"><code>chroma_spct</code></td>
<td align="left">human chromaticity coordinates <span class="math inline">\(2^\circ\)</span></td>
</tr>
<tr class="even">
<td align="left"><code>ciexyzCC10.spct</code></td>
<td align="left"><code>chroma_spct</code></td>
<td align="left">human chromaticity coordinates <span class="math inline">\(10^\circ\)</span></td>
</tr>
<tr class="odd">
<td align="left"><code>ciexyzCMF2.spct</code></td>
<td align="left"><code>chroma_spct</code></td>
<td align="left">human colour matching function <span class="math inline">\(2^\circ\)</span></td>
</tr>
<tr class="even">
<td align="left"><code>ciexyzCMF10.spct</code></td>
<td align="left"><code>chroma_spct</code></td>
<td align="left">human colour matching function <span class="math inline">\(10^\circ\)</span></td>
</tr>
<tr class="odd">
<td align="left"><code>ciev2.spct</code></td>
<td align="left"><code>chroma_spct</code></td>
<td align="left">human luminous efficiency <span class="math inline">\(2^\circ\)</span></td>
</tr>
<tr class="even">
<td align="left"><code>beesxyzCMF.spct</code></td>
<td align="left"><code>chroma_spct</code></td>
<td align="left">bee colour matching function</td>
</tr>
</tbody>
</table>
<hr />
</div>
<div id="spectra" class="section level2">
<h2>Spectra</h2>
<p>Package ‘<strong>photobiology</strong>’ defines a family of classes
based on the <code>tibble</code> class, mostly compatible with R’s data
frames. The present package by imposing some restrictions on the naming
of the member vectors, allows methods to <em>find</em> the data when
passed one of these objects as argument. In addition, as the data are
checked when the object is built or modified, there is no need to test
for their validity each time a calculation is carried out. Another
advantage of using spectrum objects, is that specialized versions of
generic functions like <code>print</code> and operators like
<code>+</code> are defined for spectra. Objects of all the
<code>..._spct</code> classes are also <code>tibble</code> and
<code>data.frame</code> objects, as a result of how classes have been
derived.</p>
<p>In this package we define a <em>generic</em> or <em>base</em>
spectrum class, derived from <code>tibble</code>, which in turn has been
derived from <code>data.frame</code>. Classes for specialized types of
spectra are derived from <code>generic_spct</code>. This
<em>parenthood</em> hierarchy means that spectral objects can be used
almost anywhere where a <code>data.frame</code> is expected (and also
converted into data frames with R’s function
<code>as.data.frame()</code>). Specializations of many methods including
extraction (indexing) methods and partial assignment methods are defined
to ensure that the expectations on the variables contained in objects of
these classes remain valid in most situations. Other specializations of
methods and functions are related to achieving a convenient and concise
syntax tailored for spectral data as in the case of mathematical
operators and functions.</p>
<p>Another important aspect is that when spectral data are stored in
objects of these classes, the physical quantities and units of
expression are also stored as metadata. Furthermore, attributes are used
to keep track of both metadata related to the origin of the data and of
later transformations that affect their interpretation, such as
normalization or re-scaling. <strong>Although sanity tests are applied
at the time of object creation, to a large extent the responsibility of
ensuring that the numbers provided as argument to object constructors
comply with expectations remains with the users of the
package.</strong></p>
<p>In addition to the classes for storing individual spectra, classes
for storing collections of these spectral objects are defined. These
classes are derived from class <code>list</code> and can contain member
spectra of different lengths and measured at different wavelength
values.</p>
<p>We give in this vignette brief descriptions and examples of the use
of different classes, methods, functions and operators. We start with
the simplest and most frequently used methods.</p>
<div id="getting-started" class="section level3">
<h3>Getting started</h3>
<p>We load two packages in addition to ‘<strong>photobiology</strong>’,
‘<strong>lubridate</strong>’ and ‘<strong>dplyr</strong>’, as they will
be used in the examples.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(photobiology)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(lubridate)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span></code></pre></div>
</div>
<div id="classes" class="section level3">
<h3>Classes</h3>
<p>Package ‘<strong>photobiology</strong>’ defines several classes
intended to be used to store different types of spectral data. They are
all derived from <code>generic_spct</code>, which in turn is derived
from <code>tibble::tibble</code>. Table 1 lists these classes.
Attributes are used to store <em>metadata</em> such as information about
units of expression.</p>
<hr />
<p><strong>Table 1. Classes for spectral data.</strong> In addition to
the required variables listed in the table, additional arbitrary
variables are partly supported—some operations will not include them in
returned values to avoid ambiguity and other possible conflicts. In
addition to the attributes listed in the table, all spectral objects
support attributes <code>multiple.wl</code>, <code>idfactor</code>,
<code>normalized</code>, <code>scaled</code>,
<code>when.measured</code>, <code>where.measured</code>,
<code>what.measured</code>, <code>how.measured</code> plus the normal
attributes of <code>tibble</code> (and <code>data.frame</code>) objects
including <code>comment</code>. All these attributes plus attributes
<code>instrument.descriptor</code> and <code>instrument.settings</code>
are retained across operations on spectra as long as they remain
valid.</p>
<table>
<colgroup>
<col width="23%" />
<col width="26%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Class name</th>
<th align="left">Required variables</th>
<th align="left">Attributes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>generic_spct</code></td>
<td align="left"><code>w.length</code></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>calib ration_spct</code></td>
<td align="left"><code>w.length</code>, <code>irrad.mult</code></td>
<td align="left"><code>instr.desc</code></td>
</tr>
<tr class="odd">
<td align="left"><code>raw_spct</code></td>
<td align="left"><code>w.length</code>, <code>counts</code></td>
<td align="left"><code>instr.desc</code>, <code>instr.settings</code>,
<code>linearized</code></td>
</tr>
<tr class="even">
<td align="left"><code>cps_spct</code></td>
<td align="left"><code>w.length</code>, <code>cps</code></td>
<td align="left"><code>instr.desc</code>, <code>instr.settings</code>,
<code>linearized</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="left"><code>w.length</code>, <code>s.e.irrad</code></td>
<td align="left"><code>instr.desc</code>, <code>instr.settings</code>,
<code>time.unit</code>, <code>bswf</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>w.length</code>, <code>s.q.irrad</code></td>
<td align="left"><code>time.unit</code>, <code>bswf</code></td>
</tr>
<tr class="odd">
<td align="left"><code>filter_spct</code></td>
<td align="left"><code>w.length</code>, <code>Tfr</code></td>
<td align="left"><code>Tfr.type</code>,
<code>filter.properties</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>w.length</code>, <code>A</code></td>
<td align="left"><code>Tfr.type</code>,
<code>filter.roperties</code></td>
</tr>
<tr class="odd">
<td align="left"><code>reflector_spct</code></td>
<td align="left"><code>w.length</code>, <code>Rfr</code></td>
<td align="left"><code>Rfr.type</code></td>
</tr>
<tr class="even">
<td align="left"><code>object_spct</code></td>
<td align="left"><code>w.length</code>, <code>Tfr</code>,
<code>Rfr</code></td>
<td align="left"><code>Tfr.type</code>, <code>Rfr.type</code></td>
</tr>
<tr class="odd">
<td align="left"><code>response_spct</code></td>
<td align="left"><code>w.length</code>, <code>s.e.response</code></td>
<td align="left"><code>time.unit</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>w.length</code>, <code>s.q.response</code></td>
<td align="left"><code>time.unit</code></td>
</tr>
<tr class="odd">
<td align="left"><code>chroma_spct</code></td>
<td align="left"><code>w.length</code>, <code>x</code>, <code>y</code>,
<code>z</code></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>solute_spct</code></td>
<td align="left"><code>w.length</code>, <code>K.mole</code></td>
<td align="left"><code>K.type</code>,
<code>solute.properties</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>w.length</code>, <code>K.mass</code></td>
<td align="left"><code>K.type</code>,
<code>solute.properties</code></td>
</tr>
</tbody>
</table>
<hr />
<p>The <em>design</em> imposes the restriction that data from different
observations are never present as different <em>data columns</em>, if
present, additional data columns represent different properties from the
same observation event. In other words, the storage format is
<em>tidy</em> as nicknamed by Hadley Wickham. In most cases, one
spectral object correspond to one spectral observation, but most
functions and methods are compatible or can be used to create spectral
objects where the spectral data from different observations are stored
“longitudinally” and “tagged” with a factor with a level for each
observation event. These observations must use consistent units of
expression. This long format is useful, for example, when producing
plots with package ‘ggplot2’ or when acquiring or storing time series of
spectra. If spectra are stored in <em>long form</em>, e.g. for plotting
with ‘ggplot2’, attributes are stored as named lists or enforced to be
the same across spectra. This allows to reconstruct a collection of
spectra from a long-form spectral object and <em>vice versa</em>
preserving nearly all of the metadata. In ‘photobiology’ (&lt;= 0.11.0)
the support for these conversions was limited and spectral objects with
multiple spectra in long form created with these versions lack complete
metadata or have the metadata stored in a way that cannot be easily
retrieved, leading to metadata loss on conversion to collections of
spectra.</p>
<hr />
<p><em>Collections of spectra are to be in general preferred to multiple
spectra stored in a single spectral object.</em> This is because
collections are the “native” storage approach in the ‘photobiology’
package, supporting all operations efficiently, while operations on
spectra stored in long form are implemented by means of two way
on-the-fly conversions into collections of spectra. Two-way conversions
can be expected to depend on memory allocation and thus to decrease
performance.</p>
<hr />
</div>
<div id="data-assumptions" class="section level3">
<h3>Data assumptions</h3>
<p>A key assumption of the package is that wavelengths are always
expressed in manometers (<span class="math inline">\(1~\mathrm{nm} = 1
\cdot 10^{-9}\,\mathrm{m}\)</span>). If the data to be analysed use
different units for wavelengths, e.g. Ångstrom (<span class="math inline">\(1~\textrm{Å} = 1 \cdot
10^{-10}\,\mathrm{m}\)</span>), the values need to be re-expressed
before creating objects of the spectral classes. The same applies to all
spectral quantities, as there is an expectation in every case, of using
base SI units for expression. Table 2 lists the units of expression for
the different variables and the metadata attributes that may determine
variations in the expression of the quantities.</p>
<hr />
<p><strong>Table 2. Variables used for spectral data and their units of
expression.</strong> <strong>A:</strong> as stored in objects of the
spectral classes, <strong>B:</strong> also recognized by the
<code>set</code> family of functions for spectra and automatically
converted. <code>time.unit</code> accepts in addition to the character
strings listed in the table, objects of classes
<code>lubridate::duration</code> and <code>period</code>, in addition
<code>numeric</code> values are interpreted as seconds.
<code>exposure.time</code> accepts these same values, but not the
character strings.</p>
<table>
<colgroup>
<col width="30%" />
<col width="43%" />
<col width="26%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Variables</th>
<th align="left">Unit of expression</th>
<th align="left">Attribute value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>A: stored</strong></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">w.length</td>
<td align="left">nm</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">counts</td>
<td align="left"><span class="math inline">\(n\)</span></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">cps</td>
<td align="left"><span class="math inline">\(n\,s^{-1}\)</span></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">irrad.mult</td>
<td align="left"><span class="math inline">\(J\,m^{-2}\,nm^{-1}\,n^{-1}\)</span></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">s.e.irrad</td>
<td align="left"><span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “second”</td>
</tr>
<tr class="odd">
<td align="left">s.e.irrad</td>
<td align="left"><span class="math inline">\(J\,m^{-2}\,d^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “day”</td>
</tr>
<tr class="even">
<td align="left">s.e.irrad</td>
<td align="left"><span class="math inline">\(J\,m^{-2}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “exposure”</td>
</tr>
<tr class="odd">
<td align="left">s.e.irrad</td>
<td align="left">varies</td>
<td align="left">time.unit = <em>duration</em></td>
</tr>
<tr class="even">
<td align="left">s.q.irrad</td>
<td align="left"><span class="math inline">\(mol\,m^{-2}\,s^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “second”</td>
</tr>
<tr class="odd">
<td align="left">s.q.irrad</td>
<td align="left"><span class="math inline">\(mol\,m^{-2}\,d^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “day”</td>
</tr>
<tr class="even">
<td align="left">s.q.irrad</td>
<td align="left"><span class="math inline">\(mol\,m^{-2}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “exposure”</td>
</tr>
<tr class="odd">
<td align="left">s.q.irrad</td>
<td align="left">varies</td>
<td align="left">time.unit = <em>duration</em></td>
</tr>
<tr class="even">
<td align="left">Tfr</td>
<td align="left">[0..1]</td>
<td align="left">Tfr.type = “total”</td>
</tr>
<tr class="odd">
<td align="left">Tfr</td>
<td align="left">[0..1]</td>
<td align="left">Tfr.type = “internal”</td>
</tr>
<tr class="even">
<td align="left">A</td>
<td align="left">a.u.</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">Afr</td>
<td align="left">[0..1]</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">Rfr</td>
<td align="left">[0..1]</td>
<td align="left">Rfr.type = “total”</td>
</tr>
<tr class="odd">
<td align="left">Rfr</td>
<td align="left">[0..1]</td>
<td align="left">Rfr.type = “specular”</td>
</tr>
<tr class="even">
<td align="left">s.e.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,J^{-1}\,s^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “second”</td>
</tr>
<tr class="odd">
<td align="left">s.e.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,mol^{-1}\,d^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “day”</td>
</tr>
<tr class="even">
<td align="left">s.e.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,J^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “exposure”</td>
</tr>
<tr class="odd">
<td align="left">s.e.response</td>
<td align="left">varies</td>
<td align="left">time.unit = <em>duration</em></td>
</tr>
<tr class="even">
<td align="left">s.q.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,mol^{-1}\,s^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “second”</td>
</tr>
<tr class="odd">
<td align="left">s.q.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,mol^{-1}\,d^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “day”</td>
</tr>
<tr class="even">
<td align="left">s.q.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,mol^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “exposure”</td>
</tr>
<tr class="odd">
<td align="left">s.q.response</td>
<td align="left">varies</td>
<td align="left">time.unit = <em>duration</em></td>
</tr>
<tr class="even">
<td align="left">x, y, z</td>
<td align="left">[0,1]</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">K.mole</td>
<td align="left"><span class="math inline">\(m^{2}\,mol^{-1},
\log_{10}\)</span> based</td>
<td align="left">K.type = “attenuation”</td>
</tr>
<tr class="even">
<td align="left">K.mole</td>
<td align="left"><span class="math inline">\(m^{2}\,mol^{-1},
\log_{10}\)</span> based</td>
<td align="left">K.type = “absorption”</td>
</tr>
<tr class="odd">
<td align="left">K.mole</td>
<td align="left"><span class="math inline">\(m^{2}\,mol^{-1},
\log_{10}\)</span> based</td>
<td align="left">K.type = “scattering”</td>
</tr>
<tr class="even">
<td align="left">K.mass</td>
<td align="left"><span class="math inline">\(m^{2}\,g^{-1},
\log_{10}\)</span> based</td>
<td align="left">K.type = “attenuation”</td>
</tr>
<tr class="odd">
<td align="left">K.mass</td>
<td align="left"><span class="math inline">\(m^{2}\,g^{-1},
\log_{10}\)</span> based</td>
<td align="left">K.type = “absorption”</td>
</tr>
<tr class="even">
<td align="left">K.mass</td>
<td align="left"><span class="math inline">\(m^{2}\,g^{-1},
\log_{10}\)</span> based</td>
<td align="left">K.type = “scattering”</td>
</tr>
<tr class="odd">
<td align="left"><strong>B: converted</strong></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">wl <span class="math inline">\(\to\)</span>
w.length</td>
<td align="left">nm</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">wavelength <span class="math inline">\(\to\)</span>
w.length</td>
<td align="left">nm</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">Tpc <span class="math inline">\(\to\)</span> Tfr</td>
<td align="left">[0..100]</td>
<td align="left">Tfr.type = “total”</td>
</tr>
<tr class="odd">
<td align="left">Tpc <span class="math inline">\(\to\)</span> Tfr</td>
<td align="left">[0..100]</td>
<td align="left">Tfr.type = “internal”</td>
</tr>
<tr class="even">
<td align="left">Rpc <span class="math inline">\(\to\)</span> Rfr</td>
<td align="left">[0..100]</td>
<td align="left">Rfr.type = “total”</td>
</tr>
<tr class="odd">
<td align="left">Rpc <span class="math inline">\(\to\)</span> Rfr</td>
<td align="left">[0..100]</td>
<td align="left">Rfr.type = “specular”</td>
</tr>
<tr class="even">
<td align="left">counts.per.second <span class="math inline">\(\to\)</span> cps</td>
<td align="left"><span class="math inline">\(n\,s^{-1}\)</span></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">K.mole <span class="math inline">\(log_e \to
log_{10}\)</span></td>
<td align="left"><span class="math inline">\(m^{-1}\,mol^{-1},
\log_{e}\)</span> based</td>
<td align="left">K.type = “attenuation”</td>
</tr>
<tr class="even">
<td align="left">K.mole <span class="math inline">\(log_e \to
log_{10}\)</span></td>
<td align="left"><span class="math inline">\(m^{-1}\,mol^{-1},
\log_{e}\)</span> based</td>
<td align="left">K.type = “absorption”</td>
</tr>
<tr class="odd">
<td align="left">K.mole <span class="math inline">\(log_e \to
log_{10}\)</span></td>
<td align="left"><span class="math inline">\(m^{-1}\,mol^{-1},
\log_{e}\)</span> based</td>
<td align="left">K.type = “scattering”</td>
</tr>
<tr class="even">
<td align="left">K.mass <span class="math inline">\(log_e \to
log_{10}\)</span></td>
<td align="left"><span class="math inline">\(m^{-1}\,g^{-1},
\log_{e}\)</span> based</td>
<td align="left">K.type = “attenuation”</td>
</tr>
<tr class="odd">
<td align="left">K.mass <span class="math inline">\(log_e \to
log_{10}\)</span></td>
<td align="left"><span class="math inline">\(m^{-1}\,g^{-1},
\log_{e}\)</span> based</td>
<td align="left">K.type = “absorption”</td>
</tr>
<tr class="even">
<td align="left">K.mass <span class="math inline">\(log_e \to
log_{10}\)</span></td>
<td align="left"><span class="math inline">\(m^{-1}\,g^{-1},
\log_{e}\)</span> based</td>
<td align="left">K.type = “scattering”</td>
</tr>
</tbody>
</table>
<hr />
<p>Energy irradiance is assumed to be expressed in <span class="math inline">\(W\,m^{-2}\)</span> and photon irradiance in <span class="math inline">\(mol^{-1}\,m^{-2}\,s^{-1}\)</span>, that is to say
using second as unit for time and no SI scale factors for the measured
variables. With respect to time, second is the default, but it is
possible to set the unit for time to an arbitrary time duration such as
day. Obviously, this applies only to rate variables like irradiance and
response rates, but not to time-invariant intensive properties like
transmittance of filters.</p>
<p>The default time unit used is <em>second</em>, but <em>minute</em>,
<em>hour</em>, <em>day</em> and <em>exposure</em> can be used by
supplying as arguments <code>&quot;minute&quot;</code>, <code>&quot;hour&quot;</code>,
<code>&quot;day&quot;</code>, or <code>&quot;exposure&quot;</code>—The meaning of
<code>&quot;exposure&quot;</code> is the total exposure time, in other words,
fluence instead of irradiance—to the constructor
<code>source_spct()</code>. In addition to these character constants
objects of class <code>lubridate:duration</code> are also accepted. In
other words irradiance is a flux rate while exposure is a flux, as both
are expressed per unit of illuminated area.</p>
<p>In the case of spectra of the molar attenuation coefficient we use
<span class="math inline">\(\log_{10}\)</span> as a base for the stored
values but the constructor accepts data expressed in other log bases.
The expected units are always in metres (<span class="math inline">\(m^{-1}\)</span>) rather than the frequently used
centimetres (<span class="math inline">\(cm^{-1}\)</span>).</p>
<p>Transmittance, reflectance and absorptance are stored as fractions of
one. The constructors also accept these quantities expressed as
percentages, and convert them.</p>
<p>Most attributes are set when a spectral object is created, either
using default values or with values supplied as arguments to the
constructor. In many cases the default is <code>NA</code> used to
indicate missing information.</p>
<p>Methods for querying and setting these attributes in already
constructed objects are also available.</p>
<hr />
<p>Not respecting the expectations about data inputs or setting
erroneous values in the metadata attributes will yield completely wrong
results if calculations are attempted! It is extremely important to make
sure that the wavelengths are in nanometres as this is what all
functions expect. If wavelength values are in the wrong units, the
action-spectra weights and quantum to/from energy units conversions will
be wrongly calculated, and the values returned by most functions wrong,
without warning. Errors in some cases will be triggered at the time of
object creation as the data input to constructors is tested to be within
the expected range of values, which in the case of some quantities
frequently allows detection of mistakes in the use unit scaling
factors.</p>
<hr />
<p>If spectral irradiance data is in <span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span>, and the wavelength in
<span class="math inline">\(nm\)</span>, as is the case for many Macam
spectroradiometers, the data can be used directly and functions in the
package will return irradiances in <span class="math inline">\(W\,m^{-2}\)</span>.</p>
<p>If, for example, the spectral irradiance data output by a
spectroradiometer is expressed in <span class="math inline">\(mW\,m^{-2}\,nm^{-1}\)</span>, and the wavelengths
are in Ångstrom then to obtain correct results when using any of the
packages in the suite, we need to rescale the data when creating a new
object.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co"># not run</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>my.spct <span class="ot">&lt;-</span> <span class="fu">source_spct</span>(<span class="at">w.length =</span> wavelength<span class="sc">/</span><span class="dv">10</span>, <span class="at">s.e.irrad =</span> irrad<span class="sc">/</span><span class="dv">1000</span>)</span></code></pre></div>
<p>In the example above, we take advantage of the behaviour of the R
language: an operation between a scalar and a vector, is equivalent to
applying this operation to each element of the vector. Consequently, in
the code above, each value from the vector of wavelengths is divided by
10, and each value in the vector of spectral irradiances is divided by
1000.</p>
</div>
<div id="querying-the-class" class="section level3">
<h3>Querying the class</h3>
<p>Before giving examples of how to construct objects to store spectral
data we show how to query the class of an object, and how to query the
class of a spectrum. Consistently with R, the package provides
<em>is</em> functions for querying the type of spectra objects. The only
<em>unusual</em> function name, defined as a <em>synonym</em> for
<code>is.generic_spct</code>: <code>is.any_spct()</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">is.any_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">is.generic_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">is.source_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">is.data.frame</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>In addition function <code>class_spct()</code> returns directly the
spectrum-related class attributes—i.e. it filters out from the output of
<code>class()</code> the underlying inherited classes.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">class_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] &quot;source_spct&quot;  &quot;generic_spct&quot;</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">class</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] &quot;source_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;</code></pre>
</div>
<div id="construction" class="section level3">
<h3>Construction</h3>
<p>There are two different approaches to the creation of spectral
objects by users. The first group are constructors similar to the
<code>data.frame()</code> constructor, which take vectors as arguments.
The second group are constructors that convert <code>list</code>
objects, and because of class derivation also <code>data.frame</code>
objects, into spectral objects. Constructors in this second group are
similar to <code>as.data.frame</code> from base R. In contrast to the
data frame constructors, spectral object constructors require the
variables or the vector arguments to be suitably named so that they can
be recognized.</p>
<p>Here we briefly describe the <em>as</em> constructor functions for
spectra. In the first example we create an object to store spectral
irradiance data for a <em>fictitious light source</em>, by first
creating a data frame, and creating the spectral object as a copy of it.
In the example below we supply a single value, 1, for the spectral
irradiance. This value gets recycled as is normal in R, but of course in
real use it is more usual to supply a vector of the same length as the
<code>w.length</code> vector.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>my.df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">w.length =</span> <span class="dv">400</span><span class="sc">:</span><span class="dv">410</span>, <span class="at">s.e.irrad =</span> <span class="dv">1</span>)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>my.spct <span class="ot">&lt;-</span> <span class="fu">as.source_spct</span>(my.df)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="fu">class</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] &quot;source_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;</code></pre>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="fu">class</span>(my.df)</span></code></pre></div>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>my.spct</span></code></pre></div>
<pre><code>## Object: source_spct [11 x 2]
## Wavelength range 400-410 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      400         1
## 2      401         1
## 3      402         1
## 4      403         1
## # ℹ 7 more rows</code></pre>
<p>We can copy and convert any spectrum object into any of its base
clases, such as <code>generic_spct</code> or <code>data.frame</code>.
This can result in the immediate and surely in the delayed loss of
metadata when modified. In addition, objects <em>downgraded</em> to a
base class support fewer operations and those still available may behave
differently.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>my.g.spct <span class="ot">&lt;-</span> <span class="fu">as.generic_spct</span>(my.spct)</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="fu">class</span>(my.g.spct)</span></code></pre></div>
<pre><code>## [1] &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;</code></pre>
<p>When constructing spectral objects from numeric vectors the names of
the arguments are meaningful and convey information on the nature of the
spectral data and basis of expression.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="fu">source_spct</span>(<span class="at">w.length =</span> <span class="dv">300</span><span class="sc">:</span><span class="dv">305</span>, <span class="at">s.e.irrad =</span> <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 2]
## Wavelength range 300-305 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 6 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      300         1
## 2      301         1
## 3      302         1
## 4      303         1
## 5      304         1
## 6      305         1</code></pre>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>z <span class="ot">&lt;-</span> <span class="dv">300</span><span class="sc">:</span><span class="dv">305</span></span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a><span class="fu">source_spct</span>(<span class="at">w.length =</span> z, <span class="at">s.e.irrad =</span> y)</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 2]
## Wavelength range 300-305 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 6 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      300         2
## 2      301         2
## 3      302         2
## 4      303         2
## 5      304         2
## 6      305         2</code></pre>
<p>When argument names are not supplied explicitly as above, the names
of the variables are used to identify the data vectors.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>w.length <span class="ot">&lt;-</span> <span class="dv">300</span><span class="sc">:</span><span class="dv">305</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>s.e.irrad <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a><span class="fu">source_spct</span>(w.length, s.e.irrad)</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 2]
## Wavelength range 300-305 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 6 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      300         1
## 2      301         1
## 3      302         1
## 4      303         1
## 5      304         1
## 6      305         1</code></pre>
<p>The different constructors have additional arguments to be used in
setting non-default values for the attributes. These arguments have the
same name as the attributes. Here we used the data frame created in the
first code chunk of this section.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>my.d.spct <span class="ot">&lt;-</span> <span class="fu">as.source_spct</span>(my.df, <span class="at">time.unit =</span> <span class="st">&quot;day&quot;</span>)</span></code></pre></div>
<p>Argument <code>strict.range</code> can be used to override or make
more strict the validation of the data values.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="fu">source_spct</span>(<span class="at">w.length =</span> <span class="dv">300</span><span class="sc">:</span><span class="dv">305</span>, <span class="at">s.e.irrad =</span> <span class="sc">-</span><span class="dv">1</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 2]
## Wavelength range 300-305 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 6 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      300        -1
## 2      301        -1
## 3      302        -1
## 4      303        -1
## 5      304        -1
## 6      305        -1</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="fu">source_spct</span>(<span class="at">w.length =</span> <span class="dv">300</span><span class="sc">:</span><span class="dv">305</span>, <span class="at">s.e.irrad =</span> <span class="sc">-</span><span class="dv">1</span>, <span class="at">strict.range =</span> <span class="cn">NULL</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 2]
## Wavelength range 300-305 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 6 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      300        -1
## 2      301        -1
## 3      302        -1
## 4      303        -1
## 5      304        -1
## 6      305        -1</code></pre>
<p>Argument <code>comment</code> can be used to add a comment to the
data at the time of construction.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>my.cm.spct <span class="ot">&lt;-</span> <span class="fu">source_spct</span>(<span class="at">w.length =</span> <span class="dv">300</span><span class="sc">:</span><span class="dv">305</span>, <span class="at">s.e.irrad =</span> <span class="dv">1</span>,</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>                          <span class="at">comment =</span> <span class="st">&quot;This is a comment&quot;</span>)</span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a><span class="fu">comment</span>(my.cm.spct)</span></code></pre></div>
<pre><code>## [1] &quot;This is a comment&quot;</code></pre>
<p>The constructors treat unrecognized named arguments as data to create
aditional columns in the spectral objects.</p>
</div>
<div id="metadata-attributes" class="section level3">
<h3>Metadata attributes</h3>
<p>Metadata attributes are used in the spectral objects to store
metadata in a consistently. These metadata are in some cases required
for conversion among related physical quantities, while in other cases
allow printing of ancillary information needed for interpretation, like
units of expression. These metadata are also used in other packages in
the suite, for example in ‘ggspectra’ to automatically produce axis
labels, titles and annotations. A few attributes are simply a way or
organizing the storage of information which is not used in any
calculations, functioning as a kind of specialized comments. The
metadata described in this section are stored in spectral objects using
attributes, which are a normal feature of the R language. An example, is
attribute <code>time.unit</code> used to indicate if spectral irradiance
is expressed per second or integrated over some other time duration.</p>
<div id="attributes-supported-by-all-spectral-objects" class="section level4">
<h4>Attributes supported by all spectral objects</h4>
<p>Some attributes are meaningful for all the classes of spectra defined
in the package, while most others a specific to individual classes
(Table 1). Those that apply to all spectral objects and their summaries
are <em>time of measurement</em> using attribute
<code>&quot;when.measured&quot;</code>, <em>place of measurement</em> using
attribute <code>&quot;where.measured&quot;</code>, a <em>user supplied label</em>
using attribute <code>&quot;what.measured&quot;</code>, a label describing origin
of the data using attribute <code>&quot;how.measured&quot;</code> and free-text
<em>comments</em>. One can set and get comments stored in spectra by
means of base R’s <code>comment()</code> and
<code>comment() &lt;-</code> functions and the other attributes listed
above with functions following the same syntax and named after the
attributes but replacing any <code>.</code> by <code>_</code>. Functions
in this package may set additional attributes to keep track of the
actions. For example when a spectrum is normalized or scaled a record of
these action is kept in attributes. When spectra are are operated upon
the metadata that is not invalidated will be merged when possible—e.g.,
comments of operands are concatenated comments and set as comment to the
returned object.</p>
<p>Functions <code>when_measured()</code> and
<code>when_measured&lt;-()</code> are used for retrieving and setting
the <code>&quot;when.measured&quot;</code> attribute to a date supplied as a
<code>POSIXct</code> value. Note: we use <code>POSIXct</code> objects
which describes instants in time in absolute terms as they include time
zone information. Package <code>lubridate</code> makes entering and
operating on <code>POSIXct</code> objects rather easy.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>my.spct <span class="ot">&lt;-</span> sun.spct</span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="fu">when_measured</span>(my.spct) <span class="ot">&lt;-</span>  <span class="cn">NULL</span></span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a><span class="fu">when_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] NA</code></pre>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="fu">when_measured</span>(my.spct) <span class="ot">&lt;-</span> lubridate<span class="sc">::</span><span class="fu">ymd_hms</span>(<span class="st">&quot;2015-10-31 22:55:00&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;Europe/Helsinki&quot;</span>)</span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a><span class="fu">when_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] &quot;2015-10-31 20:55:00 UTC&quot;</code></pre>
<p>Functions <code>where_measured()</code> and
<code>where_measured&lt;-()</code> are used for retrieving and setting a
geocode stored in a <code>data.frame</code>. This format is compatible
with function <code>geocode()</code> from package <code>ggmap</code>. We
pass latitude and longitude coordinates, as shown below. The returned
value is always a data frame with columns <code>&quot;lon&quot;</code>,
<code>&quot;lat&quot;</code> and <code>&quot;address&quot;</code>.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="fu">where_measured</span>(my.spct) <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a><span class="fu">where_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##     lon   lat address
##   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  
## 1    NA    NA &lt;NA&gt;</code></pre>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="fu">where_measured</span>(my.spct) <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">lat =</span> <span class="dv">60</span>, <span class="at">lon =</span> <span class="sc">-</span><span class="dv">10</span>)</span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a><span class="fu">where_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##     lat   lon address
##   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  
## 1    60   -10 &lt;NA&gt;</code></pre>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="fu">where_measured</span>(my.spct) <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">lat =</span> <span class="dv">60</span>, <span class="at">lon =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">address =</span> <span class="st">&quot;Somewhere&quot;</span>)</span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a><span class="fu">where_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 3
##     lat   lon address  
##   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    
## 1    60   -10 Somewhere</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a>my.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2015-10-31 20:55:00 UTC 
## Measured at 60 N, -10 E; Somewhere 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<p>Functions <code>what_measured()</code> and
<code>where_measured&lt;-()</code>, and <code>how_measured()</code> and
<code>how_measured&lt;-()</code> are used for retrieving or setting a
text value containing information about what was measured to obtain the
data.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="fu">what_measured</span>(my.spct) <span class="ot">&lt;-</span> <span class="st">&quot;something&quot;</span></span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a><span class="fu">what_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] &quot;something&quot;</code></pre>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a>my.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: something 
## Measured on 2015-10-31 20:55:00 UTC 
## Measured at 60 N, -10 E; Somewhere 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<p>Functions using a different syntax are also available, for these and
other attributes which are not likely to be set by users. Many of these
additional attributes are meaningful only for some types of spectra.</p>
</div>
<div id="attributes-supported-by-source_spct-objects" class="section level4">
<h4>Attributes supported by <code>source_spct</code> objects</h4>
<p>One example is the time unit used to express spectral irradiance.
Functions are available for querying and setting the state if these
attributes. <code>is_</code> functions return a logical value, and
<code>get</code> functions return the values of the attributes
themselves. In addition <code>set</code> functions can be used to set
the value stored in the attributes. Several of the <code>set</code>
functions are very rarely needed in user code, as these attributes are
set during construction or as a side effect of applying other functions
and/or operators to the objects. Function <code>setBSWFUsed()</code> and
other <em>set</em> functions are mainly useful to programmers extending
the package, but only exceptionally to users. One exception is the case
when a wrong value has been assigned by mistake and needs to be
overwritten.</p>
<p>We can see in the printout that the time unit is reported in the
header.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a>sun.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<p>For example function <code>is_effective()</code> returns
<code>TRUE</code> if the spectral data has been weighted with a BSWF.
The corresponding <code>getBSWFUsed()</code> function can be used, in
this case to retrieve the name of the BSWF that was used. Here we
demonstrate with one example, where we use a <code>waveband</code>
object—constructed on-the-fly with a constructor function—, defining a
range of wavelengths.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="fu">is_effective</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a><span class="fu">is_effective</span>(sun.spct <span class="sc">*</span> <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">400</span>, <span class="dv">700</span>)))</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Sometimes it may be desired to change the time unit used for
expressing spectral irradiance or spectral response, and this can be
achieved with the <em>conversion</em> function
<code>convertTimeUnit</code>. This function both converts spectral data
to the new unit of expression and sets the <code>time.unit</code>
attribute, preserving the validity of the data object.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a>ten.minutes.spct <span class="ot">&lt;-</span></span>
<span id="cb58-2"><a href="#cb58-2" tabindex="-1"></a>  <span class="fu">convertTimeUnit</span>(sun.spct, <span class="at">time.unit =</span> <span class="fu">duration</span>(<span class="dv">10</span>, <span class="st">&quot;minutes&quot;</span>))</span>
<span id="cb58-3"><a href="#cb58-3" tabindex="-1"></a>ten.minutes.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy exposure [J m-2 nm-1]
##  s.q.irrad: Spectral photon exposure [mol m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="fu">getTimeUnit</span>(ten.minutes.spct)</span></code></pre></div>
<pre><code>## [1] &quot;600s (~10 minutes)&quot;</code></pre>
</div>
<div id="attributes-supported-by-filter_spct-objects" class="section level4">
<h4>Attributes supported by <code>filter_spct</code> objects</h4>
<p>A crucial information is whether transmittance (<code>Tfr</code>) is
expressed as internal or total, stored in attribute
<code>Tfr.type</code>, as this affects how absorptances and absorbances
are computed. The key step is when a <code>filter_spct</code> object is
created, when the user has to be careful to set this attribute
correctly.</p>
<p>The objects from which transmittance can differ in additional
properties that affect possible calculations. Attribute
<code>filter.properties</code> is used to store these in an object with
fields <code>Rfr.constant</code>, <code>thickness</code> and
<code>attenuation.mode</code>. When these metadata are available, in
many cases we can use function <code>convertTfrType()</code> to convert
internal transmittance into total transmittance and <em>vice versa</em>
and function <code>convertThickness()</code> to compute the spectral
transmittance of a filter of the same material but different
thickness.</p>
<p>These attributes are also allowed in the case of
<code>object_spct</code> and <code>reflector_spct</code> and retained
during class conversions between them and <code>filter_spct</code>
objects.</p>
<p>They are included in the printout of <code>filter.spct</code>
objects.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a>polyester.spct</span></code></pre></div>
<pre><code>## Object: filter_spct [561 x 2]
## Wavelength range 240-800 nm, step 1 nm 
## Label: Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Rfr (/1): 0.074, thickness (mm): 0.125, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 561 × 2
##   w.length     Tfr
##      &lt;int&gt;   &lt;dbl&gt;
## 1      240 0.00482
## 2      241 0.00464
## 3      242 0.00446
## 4      243 0.00429
## # ℹ 557 more rows</code></pre>
<p>We estimate the spectral transmittance of 2 mm-thick PET film.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="fu">convertThickness</span>(polyester.spct, <span class="at">thickness =</span> <span class="fl">2e-3</span>)</span></code></pre></div>
<pre><code>## Object: filter_spct [561 x 2]
## Wavelength range 240-800 nm, step 1 nm 
## Label: Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Rfr (/1): 0.074, thickness (mm): 2.00, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 561 × 2
##   w.length      Tfr
##      &lt;int&gt;    &lt;dbl&gt;
## 1      240 2.70e-37
## 2      241 1.48e-37
## 3      242 7.89e-38
## 4      243 4.10e-38
## # ℹ 557 more rows</code></pre>
<hr />
<p>Attributes <code>instr_desc</code> and <code>instr_settings</code>
are used to store measurement-related metadata, describing the
instrument used and its settings. These attributes are lists, with a few
default fields and possibly unlimited <em>special</em> attributes. The
present package provides functions for operating on them and print-outs
include some of the default fields if the attribute is set. The
expectation is that these attributes are set by other packages such as
‘ooacquire’ used for direct data acquisition or raw instrument data
import.</p>
<p>These instrument-specific attributes can contain lots of information
and bloat the size of spectral objects. Two methods,
<code>trimInstrDesc()</code> and <code>trimInstrSettings()</code> can be
used to discard parts of these metadata, such as instrument calibration
information, once the raw-counts data have been converted into physical
units.</p>
<hr />
<hr />
<p>Spectral objects created with earlier versions (from before the first
CRAN release in 2016) of this package are missing some metadata
attributes. For this reason <em>summary</em> methods from this package
and <code>autoplot()</code> and <code>ggplot()</code> methods from
package ‘ggspectra’ may print warnings. These <em>very old</em> objects
can be updated by adding the missing attributes using functions
<code>setTimeUnit</code>, <code>setBSWFUsed</code>,
<code>setTfrType</code> and <code>setRfrType</code>. However, in many
cases function <code>update_spct</code> can be used to set the missing
attributes to default values, or user scripts re-run to rebuild the data
objects from raw data.</p>
<hr />
</div>
</div>
</div>
<div id="collections-of-spectra" class="section level2">
<h2>Collections of spectra</h2>
<div id="classes-1" class="section level3">
<h3>Classes</h3>
<p>The package defines several classes intended to be used to store
<em>collections</em> of different types of spectral data. They are all
derived from <code>generic_mspct</code>, which in turn is derived from
<code>list</code>. Table 3 lists them.</p>
<hr />
<p><strong>Table 3. Classes for collections of spectral
objects.</strong> Objects of class <code>generic_mspct</code> can have
member objects of any class derived from <code>generic_spct</code> and
can be heterogeneous, while the other classes support homogeneous
collections of spectral objects. Attributes of these objects can be
queried and set with the normal R methods <code>attr</code> and
<code>attributes</code> as well as with functions defined in this
package. See table 1 for the attributes used in individual member
spectra of collections.</p>
<table>
<colgroup>
<col width="28%" />
<col width="34%" />
<col width="36%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Class name</th>
<th align="left">Class of member objects</th>
<th>Attributes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="even">
<td align="left"><code>calibration_mspct</code></td>
<td align="left"><code>calibration_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="odd">
<td align="left"><code>raw_mspct</code></td>
<td align="left"><code>raw_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="even">
<td align="left"><code>cps_mspct</code></td>
<td align="left"><code>cps_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_mspct</code></td>
<td align="left"><code>source_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="even">
<td align="left"><code>filter_mspct</code></td>
<td align="left"><code>filter_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="odd">
<td align="left"><code>reflector_mspct</code></td>
<td align="left"><code>reflector_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="even">
<td align="left"><code>object_mspct</code></td>
<td align="left"><code>object_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="odd">
<td align="left"><code>response_mspct</code></td>
<td align="left"><code>response_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="even">
<td align="left"><code>chroma_mspct</code></td>
<td align="left"><code>chroma_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="odd">
<td align="left"><code>solute_mspct</code></td>
<td align="left"><code>solute_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
</tbody>
</table>
<hr />
<p>Objects of these classes, except for class
<code>generic_mspct</code>, can only contain members belonging the
matching class of spectra. As all other spectral object classes are
derived from <code>generic_spct</code>, <code>generic_mspct</code>
objects can contain heterogeneous collections of spectra. In all cases,
there are no restrictions on the lengths, wavelength range and/or
wavelength step size, or attributes other than <code>class</code> of the
contained spectra. Mimicking R’s arrays and matrices, a <code>dim</code>
attribute is always present and <code>dim</code> methods are provided.
This approach is expected to allow the storage of time series of
spectral data, or (hyper)spectral image data, or even higher dimensional
spectral data. The handling of 1D and 2D spectral collections is already
implemented in the summary methods. Handling of 3D and higher
dimensional data can be implemented in the future without changing the
class definitions. By having implemented <code>dim</code>, also methods
<code>ncol</code> and <code>nrow</code> are available as they use
<code>dim</code> internally. Array-like subscripting collections of
spectra is <strong>not</strong> implemented.</p>
</div>
<div id="construction-1" class="section level3">
<h3>Construction</h3>
<div id="constructors" class="section level4">
<h4>Constructors</h4>
<p>We can construct a collection using a list of spectral objects as a
starting point, in this case the spectral irradiance for sunlight.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a>two_suns.mspct <span class="ot">&lt;-</span> <span class="fu">source_mspct</span>(<span class="fu">list</span>(<span class="at">sun1 =</span> sun.spct, <span class="at">sun2 =</span> sun.spct))</span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>two_suns.mspct</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: sun1 ---
## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows
## --- Member: sun2 ---
## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows
## 
## --- END ---</code></pre>
<p>We can also create heterogeneous collections, but this drastically
limits the methods that are applicable to the resulting collection.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a>mixed.mspct <span class="ot">&lt;-</span> <span class="fu">generic_mspct</span>(<span class="fu">list</span>(<span class="at">filter =</span> polyester.spct, <span class="at">source =</span> sun.spct))</span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a><span class="fu">class</span>(mixed.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;generic_mspct&quot; &quot;list&quot;</code></pre>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="fu">lapply</span>(mixed.mspct, class_spct)</span></code></pre></div>
<pre><code>## $filter
## [1] &quot;filter_spct&quot;  &quot;generic_spct&quot;
## 
## $source
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot;</code></pre>
</div>
<div id="using-as.-conversion-functions" class="section level4">
<h4>Using <em>as.</em> conversion functions</h4>
<p>The <code>as.</code> coercion methods for collections of spectra, not
only change the class of the collection object, but can also optionally
apply the corresponding <code>as.</code> functions to the member
objects. A copy of the original object is made and then class-converted
and returned.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a>two_gen.mspct <span class="ot">&lt;-</span> <span class="fu">as.generic_mspct</span>(two_suns.mspct)</span>
<span id="cb72-2"><a href="#cb72-2" tabindex="-1"></a><span class="fu">class</span>(two_gen.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;generic_mspct&quot; &quot;list&quot;</code></pre>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="fu">str</span>(two_gen.mspct, <span class="at">max.level =</span> <span class="dv">1</span>, <span class="at">give.attr =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## List of 2
##  $ sun1: src_spct [522 × 3] (S3: source_spct/generic_spct/tbl_df/tbl/data.frame)
##  $ sun2: src_spct [522 × 3] (S3: source_spct/generic_spct/tbl_df/tbl/data.frame)</code></pre>
<p>In addition to coercion methods for lists of spectra objects,
coercion methods are available for lists of data frames (or tibbles) and
from matrix objects.</p>
<p>One additional feature is that if a single spectrum object or data
frame are coerced into a collection of spectra, the behaviour is
equivalent to having passed as argument a list containing such object as
its only member.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a>one_sun.mspct <span class="ot">&lt;-</span> <span class="fu">as.source_mspct</span>(sun.spct)</span>
<span id="cb76-2"><a href="#cb76-2" tabindex="-1"></a><span class="fu">class</span>(one_sun.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;source_mspct&quot;  &quot;generic_mspct&quot; &quot;list&quot;</code></pre>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a><span class="fu">str</span>(one_sun.mspct, <span class="at">max.level =</span> <span class="dv">1</span>, <span class="at">give.attr =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## List of 1
##  $ spct_1: src_spct [522 × 3] (S3: source_spct/generic_spct/tbl_df/tbl/data.frame)</code></pre>
<p>Sometimes spectral data stored in a matrix need to be coerced into a
collection of spectra. Coercion methods are defined also for this cases.
Several spectra may be stored in a matrix either by row or by column,
but this can be deduced automatically in the case of rectangular
matrices. Wavelengths values are not expected to be part of the matrix,
and need to be supplied as a separate numeric vector sorted in ascending
order. As in a spectrum wavelength values never repeat, the vector of
wavelengths is never recycled and uniqueness of values is enforced.</p>
<p>We here use artificial data, in this first example with spectra saved
by column. We assume that the values in the matrix are spectral
transmittance stored as percentages (hence “Tpc”).</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb80-2"><a href="#cb80-2" tabindex="-1"></a>wl <span class="ot">&lt;-</span> <span class="dv">501</span><span class="sc">:</span><span class="dv">550</span> <span class="co"># wavelengths in nanometres</span></span>
<span id="cb80-3"><a href="#cb80-3" tabindex="-1"></a><span class="fu">as.filter_mspct</span>(x, wl, <span class="st">&quot;Tpc&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_mspct [0 x 3]
## --- Member: spct_1 ---
## Object: filter_spct [50 x 2]
## Wavelength range 501-550 nm, step 1 nm 
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 50 × 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      501  0.01
## 2      502  0.02
## 3      503  0.03
## 4      504  0.04
## # ℹ 46 more rows
## --- Member: spct_2 ---
## Object: filter_spct [50 x 2]
## Wavelength range 501-550 nm, step 1 nm 
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 50 × 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      501  0.51
## 2      502  0.52
## 3      503  0.53
## 4      504  0.54
## # ℹ 46 more rows
## 
## --- END ---</code></pre>
<p>In a second example we supply explicit names for the spectra.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a><span class="fu">as.filter_mspct</span>(x, wl, <span class="st">&quot;Tpc&quot;</span>, <span class="at">spct.names =</span> <span class="fu">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>))</span></code></pre></div>
<pre><code>## Object: filter_mspct [0 x 3]
## --- Member: A ---
## Object: filter_spct [50 x 2]
## Wavelength range 501-550 nm, step 1 nm 
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 50 × 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      501  0.01
## 2      502  0.02
## 3      503  0.03
## 4      504  0.04
## # ℹ 46 more rows
## --- Member: B ---
## Object: filter_spct [50 x 2]
## Wavelength range 501-550 nm, step 1 nm 
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 50 × 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      501  0.51
## 2      502  0.52
## 3      503  0.53
## 4      504  0.54
## # ℹ 46 more rows
## 
## --- END ---</code></pre>
<p>There is no change in the call for data stored by row. We create a
new matrix, with the same data as above, but stored by row, as some R
packages do.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a>xrow <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>, <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb84-2"><a href="#cb84-2" tabindex="-1"></a><span class="fu">as.filter_mspct</span>(xrow, wl, <span class="st">&quot;Tpc&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_mspct [0 x 3]
## --- Member: spct_1 ---
## Object: filter_spct [50 x 2]
## Wavelength range 501-550 nm, step 1 nm 
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 50 × 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      501  0.01
## 2      502  0.02
## 3      503  0.03
## 4      504  0.04
## # ℹ 46 more rows
## --- Member: spct_2 ---
## Object: filter_spct [50 x 2]
## Wavelength range 501-550 nm, step 1 nm 
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 50 × 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      501  0.51
## 2      502  0.52
## 3      503  0.53
## 4      504  0.54
## # ℹ 46 more rows
## 
## --- END ---</code></pre>
<p>There is only one case when an explicit argument for
<code>byrow</code> is needed: square matrices (same number of spectra as
of wavelength values in each spectrum).</p>
<p>When coercing collections of spectra into matrices, the metadata
contained in the individual spectral objects is discarded, and only the
<code>&quot;comment&quot;</code> attribute of the collection of spectra copied to
the returned object. The wavelength values are preserved in an attribute
named “w.length”, but are not included as part of the matrix.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a>two_suns.mat <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(two_suns.mspct, <span class="st">&quot;s.e.irrad&quot;</span>)</span>
<span id="cb86-2"><a href="#cb86-2" tabindex="-1"></a><span class="fu">class</span>(two_suns.mat)</span></code></pre></div>
<pre><code>## [1] &quot;matrix&quot; &quot;array&quot;</code></pre>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" tabindex="-1"></a><span class="fu">dim</span>(two_suns.mat)</span></code></pre></div>
<pre><code>## [1] 522   2</code></pre>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">dimnames</span>(two_suns.mat)<span class="sc">$</span>spct)</span></code></pre></div>
<pre><code>## [1] &quot;sun1&quot; &quot;sun2&quot;</code></pre>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">dimnames</span>(two_suns.mat)<span class="sc">$</span>w.length)</span></code></pre></div>
<pre><code>## [1] &quot;280&quot;              &quot;280.923076923077&quot; &quot;281.846153846154&quot; &quot;282.769230769231&quot;
## [5] &quot;283.692307692308&quot; &quot;284.615384615385&quot;</code></pre>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">attr</span>(two_suns.mat, <span class="st">&quot;w.length&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 280.0000 280.9231 281.8462 282.7692 283.6923 284.6154</code></pre>
<p>The argument <code>byrow</code> in the coercion into matrix methods
has the same meaning as in the <code>matrix</code> constructor
function.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" tabindex="-1"></a>two_suns.row_mat <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(two_suns.mat, <span class="st">&quot;s.e.irrad&quot;</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb96-2"><a href="#cb96-2" tabindex="-1"></a><span class="fu">class</span>(two_suns.row_mat)</span></code></pre></div>
<pre><code>## [1] &quot;matrix&quot; &quot;array&quot;</code></pre>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" tabindex="-1"></a><span class="fu">dim</span>(two_suns.row_mat)</span></code></pre></div>
<pre><code>## [1] 522   2</code></pre>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">dimnames</span>(two_suns.row_mat)<span class="sc">$</span>spct)</span></code></pre></div>
<pre><code>## [1] &quot;sun1&quot; &quot;sun2&quot;</code></pre>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">attr</span>(two_suns.row_mat, <span class="st">&quot;w.length&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 280.0000 280.9231 281.8462 282.7692 283.6923 284.6154</code></pre>
<p>Collections of spectra have a <code>dim</code> attribute but it is
discarded as it describes dimensions that could require spectral data to
be stored in a three dimensional array and cannot be mapped to the two
dimensions of a matrix.</p>
<p>These functions are not fully automatic, the user needs to provide
the name of the variable to extract from each spectrum. If the
wavelength values are not consistent among spectra, only those with the
same values as the first spectrum in the collection are retained and the
remaining ones dropped with a warning.</p>
</div>
<div id="converting-tidy-data" class="section level4">
<h4>Converting <em>tidy</em> data</h4>
<p>Spectral objects containing multiple spectra identified by a factor
can be created by row-binding compatible spectral objects. For for
binding to succeed, the list of spectra passed as argument must be
homogeneous with respect to member class, as well as for certain
attributes such as <code>time.unit</code>. Other metadata attributes are
retained as named lists or multi-row data frames. We use a time series
of sunlight spectra. The default name <code>spct.idx</code> is used for
the <code>idfactor</code> unless an argument is passed to parameter
<code>idfactor</code>.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" tabindex="-1"></a>sun_evening_12.spct <span class="ot">&lt;-</span> <span class="fu">rbindspct</span>(sun_evening.mspct[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>])</span>
<span id="cb104-2"><a href="#cb104-2" tabindex="-1"></a>sun_evening_12.spct</span></code></pre></div>
<pre><code>## Object: source_spct [3,186 x 3]
## containing 2 spectra in long form
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## time.01 measured on 2023-06-12 18:38:00.379657 UTC
## time.02 measured on 2023-06-12 18:39:00.797266 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 3,186 × 3
##   w.length s.e.irrad spct.idx
##      &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;   
## 1     290          0 time.01 
## 2     290.         0 time.01 
## 3     291.         0 time.01 
## 4     291.         0 time.01 
## # ℹ 3,182 more rows</code></pre>
<p>The reverse operation, separating the individual spectra from a
spectrum object containing multiple spectra in <em>long form</em> and
storing them as a collection, is implemented in method
<code>subset2mspct</code>. In this case, metadata is set for the
individual spectra if it is available in the object being subset. What
metadata is automatically stored depends on the version of this package
used when creating the long form spectrum object by means of
<code>rbindspct()</code>. Versions 0.9.14 and later preserve most of the
metadata.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb106-1"><a href="#cb106-1" tabindex="-1"></a><span class="fu">subset2mspct</span>(sun_evening_12.spct)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## --- Member: time.02 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:39:00.797266 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## 
## --- END ---</code></pre>
<p>If multiple spectra are stored in long form (as <em>tidy</em> data)
in an ordinary <code>data.frame</code> or a <code>tibble</code> object
with columns with suitable names, the same <code>subset2mspct</code>
method can be used. In these case, arguments indicating the target class
for conversion and supplying the name of the index variable encoding the
grouping into multiple spectra need to be supplied. A call as in the
example below, adds only default metadata to spectral objects.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb108-1"><a href="#cb108-1" tabindex="-1"></a>test1.df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">w.length =</span> <span class="fu">rep</span>(<span class="dv">200</span><span class="sc">:</span><span class="dv">210</span>, <span class="dv">2</span>),</span>
<span id="cb108-2"><a href="#cb108-2" tabindex="-1"></a>                       <span class="at">s.e.irrad =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="fu">c</span>(<span class="dv">11</span>, <span class="dv">11</span>)),</span>
<span id="cb108-3"><a href="#cb108-3" tabindex="-1"></a>                       <span class="at">spectrum =</span> <span class="fu">factor</span>(<span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="fu">c</span>(<span class="dv">11</span>,<span class="dv">11</span>))))</span>
<span id="cb108-4"><a href="#cb108-4" tabindex="-1"></a><span class="fu">subset2mspct</span>(test1.df, <span class="at">member.class =</span> <span class="st">&quot;source_spct&quot;</span>, <span class="at">idx.var =</span> <span class="st">&quot;spectrum&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 2]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         1
## 2      201         1
## 3      202         1
## 4      203         1
## # ℹ 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 2]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         2
## 2      201         2
## 3      202         2
## 4      203         2
## # ℹ 7 more rows
## 
## --- END ---</code></pre>
<p>If all member spectra share the same metadata, and the constructor
has a parameter allowing it to be set, it can be passed as a named
argument. Here we set the time base of expression of the spectral data
to a whole day instead of the default of using seconds as is usual for
irradiance.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb110-1"><a href="#cb110-1" tabindex="-1"></a><span class="fu">subset2mspct</span>(test1.df, <span class="at">member.class =</span> <span class="st">&quot;source_spct&quot;</span>, <span class="at">idx.var =</span> <span class="st">&quot;spectrum&quot;</span>,</span>
<span id="cb110-2"><a href="#cb110-2" tabindex="-1"></a>             <span class="at">time.unit =</span> <span class="st">&quot;day&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 2]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy exposure [J d-1 m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         1
## 2      201         1
## 3      202         1
## 4      203         1
## # ℹ 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 2]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy exposure [J d-1 m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         2
## 2      201         2
## 3      202         2
## 4      203         2
## # ℹ 7 more rows
## 
## --- END ---</code></pre>
<p>To directly convert a <em>tidy</em> data frame into a long form
spectral object we need to pass the number of spectra through parameter
<code>multiple.wl</code> to change the target value of the check for
unique wavelength values (default is <code>multiple.wl = 1L</code>). The
data should be anyway ordered by increasing wavelength and the name of
the factor distinguishing the spectra also passed as an argument.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1" tabindex="-1"></a>test2.df <span class="ot">&lt;-</span> test1.df</span>
<span id="cb112-2"><a href="#cb112-2" tabindex="-1"></a><span class="fu">setSourceSpct</span>(test2.df, <span class="at">multiple.wl =</span> <span class="dv">2</span><span class="dt">L</span>, <span class="at">idfactor =</span> <span class="st">&quot;spectrum&quot;</span>)</span>
<span id="cb112-3"><a href="#cb112-3" tabindex="-1"></a><span class="fu">getMultipleWl</span>(test2.df)</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" tabindex="-1"></a><span class="fu">getIdFactor</span>(test2.df)</span></code></pre></div>
<pre><code>## [1] &quot;spectrum&quot;</code></pre>
<p>If <code>multiple.wl = NULL</code> a suitable value is guessed from
the data frame passed as first argument. This should work in most cases,
but is more time consuming. Using this approach in addition disables the
check for a fixed number of spectra.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1" tabindex="-1"></a>test3.df <span class="ot">&lt;-</span> test1.df</span>
<span id="cb116-2"><a href="#cb116-2" tabindex="-1"></a><span class="fu">setSourceSpct</span>(test3.df, <span class="at">multiple.wl =</span> <span class="cn">NULL</span>, <span class="at">idfactor =</span> <span class="st">&quot;spectrum&quot;</span>)</span>
<span id="cb116-3"><a href="#cb116-3" tabindex="-1"></a><span class="fu">getMultipleWl</span>(test3.df)</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
<div class="sourceCode" id="cb118"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1" tabindex="-1"></a><span class="fu">getIdFactor</span>(test3.df)</span></code></pre></div>
<pre><code>## [1] &quot;spectrum&quot;</code></pre>
</div>
<div id="converting-untidy-data-frames" class="section level4">
<h4>Converting <em>untidy</em> data frames</h4>
<p>In a <em>broad form</em> (or <em>untidy</em>) data.frame the spectral
values for different spectra are stored side-by-side as columns, and a
single additional column used to store the shared wavelength values. To
create a collection of spectral objects, with each member containing a
single spectrum, we use function <code>split2source_mspct</code> and its
equivalents for the remaining classes of spectral objects (class is
determined by the function used, and columns which are not
<code>numeric</code> are skipped). The column containing wavelength
values in nanometres is recognized by means of its name. The names used
for the spectra in the collection are derived from the names of the
columns containing numeric (assumed spectral data) values.</p>
<p>Using defaults when variables have the names expected by default.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1" tabindex="-1"></a>test2.df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">w.length =</span> <span class="dv">200</span><span class="sc">:</span><span class="dv">210</span>, <span class="at">A =</span> <span class="dv">1</span>, <span class="at">B =</span> <span class="dv">2</span>)</span>
<span id="cb120-2"><a href="#cb120-2" tabindex="-1"></a><span class="fu">split2source_mspct</span>(<span class="at">x =</span> test2.df)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 2]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         1
## 2      201         1
## 3      202         1
## 4      203         1
## # ℹ 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 2]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         2
## 2      201         2
## 3      202         2
## 4      203         2
## # ℹ 7 more rows
## 
## --- END ---</code></pre>
<p>If variable names differ from the default expectation, they can be
named in the call.</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1" tabindex="-1"></a>test3.df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">w =</span> <span class="dv">200</span><span class="sc">:</span><span class="dv">210</span>, <span class="at">A =</span> <span class="dv">1</span>, <span class="at">B =</span> <span class="dv">2</span>, <span class="at">z =</span> <span class="st">&quot;Z&quot;</span>)</span>
<span id="cb122-2"><a href="#cb122-2" tabindex="-1"></a><span class="fu">split2source_mspct</span>(<span class="at">x =</span> test3.df, <span class="at">w.length.var =</span> <span class="st">&quot;w&quot;</span>, <span class="at">idx.var =</span> <span class="st">&quot;z&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 3]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 11 × 3
##   w.length s.e.irrad z    
##      &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;
## 1      200         1 Z    
## 2      201         1 Z    
## 3      202         1 Z    
## 4      203         1 Z    
## # ℹ 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 3]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 11 × 3
##   w.length s.e.irrad z    
##      &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;
## 1      200         2 Z    
## 2      201         2 Z    
## 3      202         2 Z    
## 4      203         2 Z    
## # ℹ 7 more rows
## 
## --- END ---</code></pre>
<p>The interpretation of the data in the numeric columns other than the
wavelengths can be changed.</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1" tabindex="-1"></a><span class="fu">split2source_mspct</span>(test2.df, <span class="at">spct.data.var =</span> <span class="st">&quot;s.q.irrad&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 2]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.q.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         1
## 2      201         1
## 3      202         1
## 4      203         1
## # ℹ 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 2]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.q.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         2
## 2      201         2
## 3      202         2
## 4      203         2
## # ℹ 7 more rows
## 
## --- END ---</code></pre>
<p>Also in this case, it is possible to pass additional named arguments
to the constructor of spectral objects.</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1" tabindex="-1"></a><span class="fu">split2source_mspct</span>(test2.df, <span class="at">spct.data.var =</span> <span class="st">&quot;s.q.irrad&quot;</span>, <span class="at">time.unit =</span> <span class="st">&quot;day&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 2]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.q.irrad: Spectral photon exposure [mol d-1 m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.q.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         1
## 2      201         1
## 3      202         1
## 4      203         1
## # ℹ 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 2]
## Wavelength range 200-210 nm, step 1 nm 
## Variables:
##  w.length: Wavelength [nm]
##  s.q.irrad: Spectral photon exposure [mol d-1 m-2 nm-1] 
## --
## # A tibble: 11 × 2
##   w.length s.q.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         2
## 2      201         2
## 3      202         2
## 4      203         2
## # ℹ 7 more rows
## 
## --- END ---</code></pre>
<p>An additional way of storing spectral data is with one spectrum per
row and one wavelength per coulmn. In such a case, we can transpose the
data frame with function <code>t()</code> before pasing it as argument
to <code>split2source_mspct()</code>, taking care to copy wavelength
values into a column and that the column names of the transposed data
frame match the expected ones.</p>
</div>
</div>
<div id="conversion-into-a-wide-data-frame" class="section level3">
<h3>Conversion into a “wide” data frame</h3>
<p>Sometimes, when exporting spectral data we may need to convert a
collection of spectra into an <em>untidy</em> or <em>wide form</em> data
frame. In the example below we use a collection with only two member
spectra, but <code>join_mspct()</code> can handle collections of any
length.</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" tabindex="-1"></a>my.df <span class="ot">&lt;-</span> <span class="fu">join_mspct</span>(sun_evening.mspct)</span>
<span id="cb128-2"><a href="#cb128-2" tabindex="-1"></a><span class="fu">head</span>(my.df)</span></code></pre></div>
<pre><code>##   w.length time.01 time.02 time.03 time.04 time.05
## 1   290.00       0       0       0       0       0
## 2   290.39       0       0       0       0       0
## 3   290.86       0       0       0       0       0
## 4   291.32       0       0       0       0       0
## 5   291.79       0       0       0       0       0
## 6   292.26       0       0       0       0       0</code></pre>
</div>
<div id="querying-the-class-1" class="section level3">
<h3>Querying the class</h3>
<p><code>is.</code> functions are defined for all the new classes. R’s
<code>class</code> method can also be used.</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1" tabindex="-1"></a><span class="fu">is.source_mspct</span>(sun_evening.mspct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb132"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1" tabindex="-1"></a><span class="fu">class</span>(sun_evening.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;source_mspct&quot;  &quot;generic_mspct&quot; &quot;list&quot;</code></pre>
<p>In addition to using <code>class</code> to query the class of the
collection, we can use base R’s <code>lapply</code> together with
<code>class</code> or <code>class_spct</code> to query the class of each
of the members of the collection.</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1" tabindex="-1"></a><span class="fu">is.filter_mspct</span>(sun_evening.mspct)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb136"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1" tabindex="-1"></a><span class="fu">is.any_mspct</span>(sun_evening.mspct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb138"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb138-1"><a href="#cb138-1" tabindex="-1"></a><span class="fu">class</span>(sun_evening.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;source_mspct&quot;  &quot;generic_mspct&quot; &quot;list&quot;</code></pre>
<div class="sourceCode" id="cb140"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1" tabindex="-1"></a><span class="fu">lapply</span>(sun_evening.mspct, class_spct)</span></code></pre></div>
<pre><code>## $time.01
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot;
## 
## $time.02
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot;
## 
## $time.03
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot;
## 
## $time.04
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot;
## 
## $time.05
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot;</code></pre>
<div class="sourceCode" id="cb142"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1" tabindex="-1"></a><span class="fu">lapply</span>(sun_evening.mspct, class)</span></code></pre></div>
<pre><code>## $time.01
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;  
## 
## $time.02
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;  
## 
## $time.03
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;  
## 
## $time.04
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;  
## 
## $time.05
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;</code></pre>
</div>
<div id="extract-replace-and-combine" class="section level3">
<h3>Extract, replace and combine</h3>
<p>R’s extraction and replacement methods have specializations for
collections of spectra and can be used with the same syntax and
functionality as for R lists. However they test the class and validity
of the returned objects and replacement members.</p>
<hr />
<p>Methods <code>[</code>, and <code>[&lt;-</code>, extract and replace
<em>parts</em> of the collection, respectively. Even when only one
member is extracted, the returned value is a collection of spectra. The
expected replacement value is also, always a collection of spectra.</p>
<hr />
<div class="sourceCode" id="cb144"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1" tabindex="-1"></a>sun_evening.mspct[<span class="dv">1</span>]</span></code></pre></div>
<pre><code>## Object: source_mspct [1 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## 
## --- END ---</code></pre>
<div class="sourceCode" id="cb146"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1" tabindex="-1"></a>sun_evening.mspct[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>]</span></code></pre></div>
<pre><code>## Object: source_mspct [3 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## --- Member: time.02 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:39:00.797266 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## --- Member: time.03 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:40:00.714554 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## 
## --- END ---</code></pre>
<p><strong>Code like that in the chunk below, may be counterintuitive.
Collections of spectra are named lists, consequently assigning by
position as shown here swaps the values without swapping the names of
the slots!</strong></p>
<p>Using summary to check the names and time stamps we can demonstrate
this behaviour.</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb148-1"><a href="#cb148-1" tabindex="-1"></a><span class="co"># warning: this does not swap the names, even if it swaps the spectra</span></span>
<span id="cb148-2"><a href="#cb148-2" tabindex="-1"></a>my.mspct <span class="ot">&lt;-</span> sun_evening.mspct</span>
<span id="cb148-3"><a href="#cb148-3" tabindex="-1"></a><span class="fu">summary</span>(my.mspct, <span class="at">which.metadata =</span> <span class="st">&quot;when.measured&quot;</span>)<span class="sc">$</span>summary[ , <span class="sc">-</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">6</span>)]</span></code></pre></div>
<pre><code>## # A tibble: 5 × 2
##   spct.idx when.measured      
##   &lt;chr&gt;    &lt;dttm&gt;             
## 1 time.01  2023-06-12 18:38:00
## 2 time.02  2023-06-12 18:39:00
## 3 time.03  2023-06-12 18:40:00
## 4 time.04  2023-06-12 18:41:00
## 5 time.05  2023-06-12 18:42:00</code></pre>
<div class="sourceCode" id="cb150"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb150-1"><a href="#cb150-1" tabindex="-1"></a><span class="co"># member spectr swapped positions, but not the slot names</span></span>
<span id="cb150-2"><a href="#cb150-2" tabindex="-1"></a>my.mspct[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">&lt;-</span> my.mspct[<span class="dv">2</span><span class="sc">:</span><span class="dv">1</span>]</span>
<span id="cb150-3"><a href="#cb150-3" tabindex="-1"></a><span class="fu">summary</span>(my.mspct, <span class="at">which.metadata =</span> <span class="st">&quot;when.measured&quot;</span>)<span class="sc">$</span>summary[ , <span class="sc">-</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">6</span>)]</span></code></pre></div>
<pre><code>## # A tibble: 5 × 2
##   spct.idx when.measured      
##   &lt;chr&gt;    &lt;dttm&gt;             
## 1 time.01  2023-06-12 18:39:00
## 2 time.02  2023-06-12 18:38:00
## 3 time.03  2023-06-12 18:40:00
## 4 time.04  2023-06-12 18:41:00
## 5 time.05  2023-06-12 18:42:00</code></pre>
<div class="sourceCode" id="cb152"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb152-1"><a href="#cb152-1" tabindex="-1"></a><span class="co"># of course, we can also swap the names if needed</span></span>
<span id="cb152-2"><a href="#cb152-2" tabindex="-1"></a><span class="fu">names</span>(my.mspct)[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">&lt;-</span> <span class="fu">names</span>(my.mspct)[<span class="dv">2</span><span class="sc">:</span><span class="dv">1</span>]</span>
<span id="cb152-3"><a href="#cb152-3" tabindex="-1"></a><span class="fu">summary</span>(my.mspct, <span class="at">which.metadata =</span> <span class="st">&quot;when.measured&quot;</span>)<span class="sc">$</span>summary[ , <span class="sc">-</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">6</span>)]</span></code></pre></div>
<pre><code>## # A tibble: 5 × 2
##   spct.idx when.measured      
##   &lt;chr&gt;    &lt;dttm&gt;             
## 1 time.02  2023-06-12 18:39:00
## 2 time.01  2023-06-12 18:38:00
## 3 time.03  2023-06-12 18:40:00
## 4 time.04  2023-06-12 18:41:00
## 5 time.05  2023-06-12 18:42:00</code></pre>
<hr />
<p>Methods <code>[[</code>, <code>$</code> and <code>[[&lt;-</code>,
extract and replace individual members of the collection, respectively.
They always return or expect objects of one of the spectral classes.</p>
<hr />
<div class="sourceCode" id="cb154"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb154-1"><a href="#cb154-1" tabindex="-1"></a>sun_evening.mspct[[<span class="dv">1</span>]]</span></code></pre></div>
<pre><code>## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows</code></pre>
<div class="sourceCode" id="cb156"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb156-1"><a href="#cb156-1" tabindex="-1"></a>sun_evening.mspct<span class="sc">$</span>time<span class="fl">.01</span></span></code></pre></div>
<pre><code>## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows</code></pre>
<div class="sourceCode" id="cb158"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb158-1"><a href="#cb158-1" tabindex="-1"></a>sun_evening.mspct[[<span class="st">&quot;time.01&quot;</span>]]</span></code></pre></div>
<pre><code>## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows</code></pre>
<div class="sourceCode" id="cb160"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb160-1"><a href="#cb160-1" tabindex="-1"></a><span class="co"># local copy</span></span>
<span id="cb160-2"><a href="#cb160-2" tabindex="-1"></a>my.mspct <span class="ot">&lt;-</span> sun_evening.mspct</span>
<span id="cb160-3"><a href="#cb160-3" tabindex="-1"></a><span class="fu">names</span>(my.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;time.01&quot; &quot;time.02&quot; &quot;time.03&quot; &quot;time.04&quot; &quot;time.05&quot;</code></pre>
<div class="sourceCode" id="cb162"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb162-1"><a href="#cb162-1" tabindex="-1"></a><span class="co"># add computed member</span></span>
<span id="cb162-2"><a href="#cb162-2" tabindex="-1"></a>my.mspct[[<span class="st">&quot;time.01x2&quot;</span>]] <span class="ot">&lt;-</span> my.mspct[[<span class="st">&quot;time.01&quot;</span>]] <span class="sc">*</span> <span class="dv">2</span></span>
<span id="cb162-3"><a href="#cb162-3" tabindex="-1"></a><span class="fu">names</span>(my.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;time.01&quot;   &quot;time.02&quot;   &quot;time.03&quot;   &quot;time.04&quot;   &quot;time.05&quot;   &quot;time.01x2&quot;</code></pre>
<div class="sourceCode" id="cb164"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb164-1"><a href="#cb164-1" tabindex="-1"></a><span class="co"># delete a member</span></span>
<span id="cb164-2"><a href="#cb164-2" tabindex="-1"></a>my.mspct[[<span class="st">&quot;time.01x2&quot;</span>]] <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb164-3"><a href="#cb164-3" tabindex="-1"></a><span class="fu">names</span>(my.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;time.01&quot; &quot;time.02&quot; &quot;time.03&quot; &quot;time.04&quot; &quot;time.05&quot;</code></pre>
<p>As with R’s <code>list</code> objects, can combine collections of
spectra with method <code>c()</code> but we can not create new
collections from individual spectra using this method. Extraction plus
concatenation, moves names together with spectra.</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb166-1"><a href="#cb166-1" tabindex="-1"></a>new.spct <span class="ot">&lt;-</span> <span class="fu">c</span>(my.mspct[<span class="dv">5</span><span class="sc">:</span><span class="dv">4</span>], my.mspct[<span class="dv">3</span>])</span>
<span id="cb166-2"><a href="#cb166-2" tabindex="-1"></a><span class="fu">summary</span>(new.spct, <span class="at">which.metadata =</span> <span class="st">&quot;when.measured&quot;</span>)<span class="sc">$</span>summary[ , <span class="sc">-</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">6</span>)]</span></code></pre></div>
<pre><code>## # A tibble: 3 × 2
##   spct.idx when.measured      
##   &lt;chr&gt;    &lt;dttm&gt;             
## 1 time.05  2023-06-12 18:42:00
## 2 time.04  2023-06-12 18:41:00
## 3 time.03  2023-06-12 18:40:00</code></pre>
</div>
<div id="random-sampling" class="section level3">
<h3>Random sampling</h3>
<p>With large collections of spectra it can be useful to extract a
random subset of spectra. Method <code>pull_sample()</code> make this
easy for multiple spectra, stored either in long form or in collections
of spectra. (We can set the seed of the pseudo-random number generator
to ensure repeatability).</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb168-1"><a href="#cb168-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234564</span>)</span>
<span id="cb168-2"><a href="#cb168-2" tabindex="-1"></a>sampled.mspct <span class="ot">&lt;-</span> <span class="fu">pull_sample</span>(sun_evening.mspct, <span class="at">size =</span> <span class="dv">2</span>)</span>
<span id="cb168-3"><a href="#cb168-3" tabindex="-1"></a><span class="fu">summary</span>(sampled.mspct, <span class="at">which.metadata =</span> <span class="st">&quot;when.measured&quot;</span>)<span class="sc">$</span>summary[ , <span class="sc">-</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">6</span>)]</span></code></pre></div>
<pre><code>## # A tibble: 2 × 2
##   spct.idx when.measured      
##   &lt;chr&gt;    &lt;dttm&gt;             
## 1 time.02  2023-06-12 18:39:00
## 2 time.05  2023-06-12 18:42:00</code></pre>
<div class="sourceCode" id="cb170"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb170-1"><a href="#cb170-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234564</span>)</span>
<span id="cb170-2"><a href="#cb170-2" tabindex="-1"></a>sampled.spct <span class="ot">&lt;-</span> <span class="fu">pull_sample</span>(sun_evening.spct, <span class="at">size =</span> <span class="dv">2</span>)</span>
<span id="cb170-3"><a href="#cb170-3" tabindex="-1"></a><span class="fu">summary</span>(sampled.spct)</span></code></pre></div>
<pre><code>## Summary of source_spct [3,186 x 3] object: sampled.spct
## containing  2  spectra in long form
## Wavelength range 290-1000 nm, step 0.34-0.47 nm
## Label:  cosine.hour.9 
## time.01 measured on 2023-06-12 18:38:00.379657 UTC
## time.02 measured on 2023-06-12 18:39:00.797266 UTC
## time.03 measured on 2023-06-12 18:40:00.714554 UTC
## time.04 measured on 2023-06-12 18:41:00.768459 UTC
## time.05 measured on 2023-06-12 18:42:00.769065 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
##     w.length        s.e.irrad          spct.idx   
##  Min.   : 290.0   Min.   :0.00000   time.02:1593  
##  1st Qu.: 474.4   1st Qu.:0.02434   time.05:1593  
##  Median : 654.8   Median :0.04106                 
##  Mean   : 651.6   Mean   :0.03739                 
##  3rd Qu.: 830.3   3rd Qu.:0.05124                 
##  Max.   :1000.0   Max.   :0.07321</code></pre>
</div>
<div id="transform-or-apply-functions" class="section level3">
<h3>Transform or <em>apply</em> functions</h3>
<p>For our <em>apply</em> functions we follow the naming convention used
in package <code>plyr</code>, but using <code>ms</code> as prefix for
<code>_mspct</code> objects. The <em>apply</em> functions implemented in
the ‘<strong>photobiology</strong>’ package are <code>msmsply</code>,
<code>msdply</code>, <code>mslply</code> and <code>msaply</code> which
both accept a collection of spectra as first argument and return a
collection of spectra, a data frame, a list, or an array respectively
(see Table 4).</p>
<hr />
<p><strong>Table 4. Apply functions for collections of spectra.</strong>
Key: v., value returned by <em>apply</em> function; f.v., value returned
by the applied function (argument <code>.fun</code>). In the table
<code>generic_mspct</code> and <code>generic_spct</code> indicate
objects of these classes or any class derived from them. The exact class
of the collection of spectra object returned will be determined by the
class(es) of the values returned by the applied function.</p>
<table style="width:100%;">
<colgroup>
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th align="left"><em>apply</em> function</th>
<th align="left">first arg. class</th>
<th align="left">v. class</th>
<th align="left">f.v. class</th>
<th align="left">f.v. length</th>
<th align="left">f.v. dims</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>msmsply</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">1</td>
<td align="left">any</td>
</tr>
<tr class="even">
<td align="left"><code>msdply</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>data.frame</code></td>
<td align="left"><code>numeric</code></td>
<td align="left"><span class="math inline">\(1\ldots n\)</span></td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left"><code>mslply</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>list</code></td>
<td align="left">any</td>
<td align="left">any</td>
<td align="left">any</td>
</tr>
<tr class="even">
<td align="left"><code>msaply</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>vector</code></td>
<td align="left">any simple</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left"><code>msaply</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>matrix</code></td>
<td align="left">any simple</td>
<td align="left"><span class="math inline">\(2\ldots n\)</span></td>
<td align="left"><span class="math inline">\(2\ldots n\)</span></td>
</tr>
<tr class="even">
<td align="left"><code>concolve_each</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">1</td>
<td align="left">any</td>
</tr>
</tbody>
</table>
<hr />
<p>Functions <code>msmsply()</code>, <code>msdply</code> and
<code>mslply</code> can be used to apply a function to each member
spectrum in a collection. The <em>apply</em> function to use depends on
the return value of the applied function.</p>
<p>In the case of <code>msmsply()</code> the applied function is
expected to return a <em>transformed</em> spectrum as another object of
class <code>generic_spct</code> or a class derived from it. The value
returned by <code>msmsply</code> is a collection of spectra, of a type
determined by the class(es) of the member spectra in the new
collection.</p>
<p>We start with a simple example in which we add a constant to each
spectrum in the collection</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb172-1"><a href="#cb172-1" tabindex="-1"></a>two.mspct <span class="ot">&lt;-</span> sun_evening.mspct[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>]</span>
<span id="cb172-2"><a href="#cb172-2" tabindex="-1"></a><span class="fu">msmsply</span>(two.mspct, <span class="st">`</span><span class="at">+</span><span class="st">`</span>, <span class="fl">0.1</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290        0.1
## 2     290.       0.1
## 3     291.       0.1
## 4     291.       0.1
## # ℹ 1,589 more rows
## --- Member: time.02 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:39:00.797266 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290        0.1
## 2     290.       0.1
## 3     291.       0.1
## 4     291.       0.1
## # ℹ 1,589 more rows
## 
## --- END ---</code></pre>
<p>and continue with a more complex example in which we trim each
spectrum, and fill the added values with <code>NA</code> values.</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb174-1"><a href="#cb174-1" tabindex="-1"></a><span class="fu">msmsply</span>(two.mspct, trim_wl, <span class="at">range =</span> <span class="fu">c</span>(<span class="dv">285</span>, <span class="dv">500</span>), <span class="at">fill =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,602 x 2]
## Wavelength range 285-1000 nm, step 1.023182e-12-0.8333333 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,602 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     285         NA
## 2     286.        NA
## 3     287.        NA
## 4     287.        NA
## # ℹ 1,598 more rows
## --- Member: time.02 ---
## Object: source_spct [1,602 x 2]
## Wavelength range 285-1000 nm, step 1.023182e-12-0.8333333 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:39:00.797266 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,602 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     285         NA
## 2     286.        NA
## 3     287.        NA
## 4     287.        NA
## # ℹ 1,598 more rows
## 
## --- END ---</code></pre>
<p>In the second example we pass two arguments by name to the applied
function. The number of arguments is not fixed, but the spectrum will be
always passed as the first argument to the function.</p>
<p>In the case of <code>msdply()</code> the applied function is expected
to return an R object of the same length for each of the member
spectra.</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb176-1"><a href="#cb176-1" tabindex="-1"></a><span class="fu">msdply</span>(two.mspct, max)</span></code></pre></div>
<pre><code>## # A tibble: 2 × 2
##   spct.idx max.wl
##   &lt;fct&gt;     &lt;dbl&gt;
## 1 time.01   1000.
## 2 time.02   1000.</code></pre>
<div class="sourceCode" id="cb178"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb178-1"><a href="#cb178-1" tabindex="-1"></a>ranges.df <span class="ot">&lt;-</span> <span class="fu">msdply</span>(two.mspct, range)</span>
<span id="cb178-2"><a href="#cb178-2" tabindex="-1"></a>ranges.df</span></code></pre></div>
<pre><code>## # A tibble: 2 × 3
##   spct.idx min.wl max.wl
##   &lt;fct&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1 time.01     290  1000.
## 2 time.02     290  1000.</code></pre>
<div class="sourceCode" id="cb180"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb180-1"><a href="#cb180-1" tabindex="-1"></a><span class="fu">cat</span>(<span class="fu">comment</span>(ranges.df))</span></code></pre></div>
<pre><code>## Applied function: &#39;range&#39;.</code></pre>
<div class="sourceCode" id="cb182"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb182-1"><a href="#cb182-1" tabindex="-1"></a><span class="fu">msdply</span>(two.mspct, range, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## # A tibble: 2 × 3
##   spct.idx min.wl max.wl
##   &lt;fct&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1 time.01     290  1000.
## 2 time.02     290  1000.</code></pre>
<p>In the case of <code>mslply()</code> the applied function is expected
to return an R object of any length, possibly variable among
members.</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb184-1"><a href="#cb184-1" tabindex="-1"></a><span class="fu">str</span>(<span class="fu">mslply</span>(two.mspct, colnames))</span></code></pre></div>
<pre><code>## List of 2
##  $ time.01: chr [1:2] &quot;w.length&quot; &quot;s.e.irrad&quot;
##  $ time.02: chr [1:2] &quot;w.length&quot; &quot;s.e.irrad&quot;
##  - attr(*, &quot;comment&quot;)= chr &quot;Applied function: &#39;colnames&#39;.\n&quot;</code></pre>
<p>In the case of <code>msaply()</code> the applied function is expected
to return an R object of length 1, although a list with dimensions will
be returned for longer return values.</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb186-1"><a href="#cb186-1" tabindex="-1"></a><span class="fu">str</span>(<span class="fu">msaply</span>(two.mspct, max))</span></code></pre></div>
<pre><code>##  num [1:2] 1000 1000
##  - attr(*, &quot;comment&quot;)= chr &quot;Applied function: &#39;max&#39;.\n&quot;</code></pre>
<div class="sourceCode" id="cb188"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb188-1"><a href="#cb188-1" tabindex="-1"></a><span class="fu">msaply</span>(two.mspct, range)</span></code></pre></div>
<pre><code>##        1    2
## [1,] 290 1000
## [2,] 290 1000</code></pre>
<p>For the most common cases for which one would use the <em>apply</em>
functions described in the previous section methods and functions for
operations on collections of spectra are defined in the package. These
methods are described in a later section and listed in Table 9.</p>
</div>
<div id="summary-spectra" class="section level3">
<h3>Summary spectra</h3>
<p>Starting from a collection of spectra, or multiple spectra stored in
long form, we can obtain a single spectrum containing a “parallel”
summary across them. The current implementation of the methods described
in this section expects that all spectra in a collection are of the same
class, and data is available for each of them at exactly the same set of
wavelengths. In the table below, <code>source_spct/mspct</code> is an
abbreviation for <code>source_spct</code> or
<code>source_mspct</code>.</p>
<table style="width:100%;">
<colgroup>
<col width="26%" />
<col width="21%" />
<col width="21%" />
<col width="30%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">functions</th>
<th align="left">class of argument</th>
<th align="left">class of returned spectrum</th>
<th align="left">variables in spectrum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>s_sum</code></td>
<td align="left"><code>source_spct/mspct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="even">
<td align="left"><code>s_sum</code></td>
<td align="left"><code>response_spct/mspct</code></td>
<td align="left"><code>response_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="odd">
<td align="left"><code>s_sum</code></td>
<td align="left"><code>filter_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.sum</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_sum</code></td>
<td align="left"><code>reflector_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.sum</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_sum</code></td>
<td align="left"><code>calibration_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.sum</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_prod</code></td>
<td align="left"><code>source_spct/mspct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left">input tagged <code>.prod</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_prod</code></td>
<td align="left"><code>response_spct/mspct</code></td>
<td align="left"><code>response_spct</code></td>
<td align="left">input tagged <code>.prod</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_prod</code></td>
<td align="left"><code>filter_spct/mspct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="odd">
<td align="left"><code>s_prod</code></td>
<td align="left"><code>reflector_spct/mspct</code></td>
<td align="left"><code>reflector_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="even">
<td align="left"><code>s_prod</code></td>
<td align="left"><code>calibration_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.prod</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean</code> or <code>s_median</code></td>
<td align="left"><code>source_spct/mspct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="even">
<td align="left"><code>s_mean</code> or <code>s_median</code></td>
<td align="left"><code>response_spct/mspct</code></td>
<td align="left"><code>response_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean</code> or <code>s_median</code></td>
<td align="left"><code>filter_spct/mspct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="even">
<td align="left"><code>s_mean</code> or <code>s_median</code></td>
<td align="left"><code>reflector_spct/mspct</code></td>
<td align="left"><code>reflector_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean</code> or <code>s_median</code></td>
<td align="left"><code>calibration_spct/mspct</code></td>
<td align="left"><code>calibration_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="even">
<td align="left"><code>s_var</code>, <code>s_se</code> or
<code>s_sd</code></td>
<td align="left"><code>source_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.var</code>, <code>.se</code> or
<code>.sd</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_var</code>, <code>s_se</code> or
<code>s_sd</code></td>
<td align="left"><code>response_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.var</code>, <code>.se</code> or
<code>.sd</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_var</code>, <code>s_se</code> or
<code>s_sd</code></td>
<td align="left"><code>filter_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.var</code>, <code>.se</code> or
<code>.sd</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_var</code>, <code>s_se</code> or
<code>s_sd</code></td>
<td align="left"><code>reflector_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.var</code>, <code>.se</code> or
<code>.sd</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_var</code>, <code>s_se</code> or
<code>s_sd</code></td>
<td align="left"><code>calibration_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.var</code>, <code>.se</code> or
<code>.sd</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean_se</code></td>
<td align="left"><code>source_spct/mspct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left">same as input plus col. tagged <code>.se</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_mean_se</code></td>
<td align="left"><code>response_spct/mspct</code></td>
<td align="left"><code>response_spct</code></td>
<td align="left">same as input plus col. tagged <code>.se</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean_se</code></td>
<td align="left"><code>filter_spct/mspct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">same as input plus col. tagged <code>.se</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_mean_se</code></td>
<td align="left"><code>reflector_spct/mspct</code></td>
<td align="left"><code>reflector_spct</code></td>
<td align="left">same as input plus col. tagged <code>.se</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean_se</code></td>
<td align="left"><code>calibration_spct/mspct</code></td>
<td align="left"><code>calibration_spct</code></td>
<td align="left">same as input plus col. tagged <code>.se</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_range</code></td>
<td align="left"><code>source_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.min</code> and
<code>.max</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_range</code></td>
<td align="left"><code>response_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.min</code> and
<code>.max</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_range</code></td>
<td align="left"><code>filter_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.min</code> and
<code>.max</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_range</code></td>
<td align="left"><code>reflector_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.min</code> and
<code>.max</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_range</code></td>
<td align="left"><code>calibration_spct/mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.min</code> and
<code>.max</code></td>
</tr>
</tbody>
</table>
<p>The calculations are done wavelength by wavelength yielding a
spectrum at the same wavelengths than those in the input. Removal of
<code>NA</code> values is done wavelength by wavelength. As shown in the
table above, depending on the operation the returned quantity may be
equivalent or not to the quantity in the input. When the quantity
changes, even if units of expression remain the same, the name of the
variable and class of the returned spectrum are different to those in
the input.</p>
<p>Methods in this “family” are fast and are specially useful for large
collections of spectra containing even thousands of individual spectra.
Nonetheless, for the example below we use a collection of two spectra.
As computing the mean returns values of the same quantity as in the
input the returned value is a <code>source_spct</code> object, in other
words of the same class as the members of <code>two.mspct</code>.</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb190-1"><a href="#cb190-1" tabindex="-1"></a><span class="fu">s_mean</span>(sun_evening.mspct)</span></code></pre></div>
<pre><code>## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: Mean of 5 source_spct objects.
##  cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC
## Measured on 2023-06-12 18:39:00.797266 UTC
## Measured on 2023-06-12 18:40:00.714554 UTC
## Measured on 2023-06-12 18:41:00.768459 UTC
## Measured on 2023-06-12 18:42:00.769065 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows</code></pre>
<p>When we compute the standard error, the quantity returned is not the
same. Consequently, the object returned is in this case a
<code>generic_spct</code> instead of <code>source_spc</code> as it does
not contain spectral irradiance data as the input did. The variable name
is in addition tagged with <code>.se</code> to <em>advertise</em> the
change in the quantity.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb192-1"><a href="#cb192-1" tabindex="-1"></a><span class="fu">s_se</span>(sun_evening.mspct)</span></code></pre></div>
<pre><code>## Object: generic_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: Standard error for 5 source_spct objects.
##  cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC
## Measured on 2023-06-12 18:39:00.797266 UTC
## Measured on 2023-06-12 18:40:00.714554 UTC
## Measured on 2023-06-12 18:41:00.768459 UTC
## Measured on 2023-06-12 18:42:00.769065 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##   
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad.se
##      &lt;dbl&gt;        &lt;dbl&gt;
## 1     290             0
## 2     290.            0
## 3     291.            0
## 4     291.            0
## # ℹ 1,589 more rows</code></pre>
<p>We can also compute both the mean and standard error
simultaneously.</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb194-1"><a href="#cb194-1" tabindex="-1"></a><span class="fu">s_mean_se</span>(sun_evening.mspct)</span></code></pre></div>
<pre><code>## Object: source_spct [1,593 x 3]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: Mean and SEM of 5 source_spct objects.
##  cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC
## Measured on 2023-06-12 18:39:00.797266 UTC
## Measured on 2023-06-12 18:40:00.714554 UTC
## Measured on 2023-06-12 18:41:00.768459 UTC
## Measured on 2023-06-12 18:42:00.769065 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 3
##   w.length s.e.irrad s.e.irrad.se
##      &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;
## 1     290          0            0
## 2     290.         0            0
## 3     291.         0            0
## 4     291.         0            0
## # ℹ 1,589 more rows</code></pre>
<p>The other functions in this family work in a similar way to those
described here.</p>
</div>
<div id="convolution" class="section level3">
<h3>Convolution</h3>
<p>By convolution we normally mean the multiplication value by value at
matching wavelengths of two spectra. The function described in this
section facilitates this and similar operations among collections of
spectra. An example use case could be the convolution of spectral
irradiance by spectral transmittance for all combinations of light
sources and filters in a collection of source spectra and a collection
of filter spectra.</p>
<p>Default operator (or function) is that for multiplication, either one
or both of the two first arguments must be a collection of spectra. When
only one argument is a collection of spectra, the other one can be a
spectrum, or even a numeric vector. For multiplication the order of the
operands does not affect the returned value. With operators or functions
for non-transitive operations the order does, obviously, matter.</p>
<p>Convolution can be used, for example to simulate the effect of an
optical filter on the irradiance from a light source.</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb196-1"><a href="#cb196-1" tabindex="-1"></a><span class="fu">convolve_each</span>(two.mspct, yellow_gel.spct)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,629 x 2]
## Wavelength range 290-800 nm, step 0.01-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,629 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291          0
## # ℹ 1,625 more rows
## --- Member: time.02 ---
## Object: source_spct [1,629 x 2]
## Wavelength range 290-800 nm, step 0.01-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:39:00.797266 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,629 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291          0
## # ℹ 1,625 more rows
## 
## --- END ---</code></pre>
<div class="sourceCode" id="cb198"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb198-1"><a href="#cb198-1" tabindex="-1"></a><span class="fu">convolve_each</span>(yellow_gel.spct, two.mspct)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,629 x 2]
## Wavelength range 290-800 nm, step 0.01-0.47 nm 
## Label: Theatrical &#39;gel&#39;, type &#39;Canary Supergel no312; new; from Rosco, UK 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,629 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291          0
## # ℹ 1,625 more rows
## --- Member: time.02 ---
## Object: source_spct [1,629 x 2]
## Wavelength range 290-800 nm, step 0.01-0.47 nm 
## Label: Theatrical &#39;gel&#39;, type &#39;Canary Supergel no312; new; from Rosco, UK 
## Measured on 2023-06-12 18:39:00.797266 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,629 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291          0
## # ℹ 1,625 more rows
## 
## --- END ---</code></pre>
<div class="sourceCode" id="cb200"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb200-1"><a href="#cb200-1" tabindex="-1"></a>another_two.mspct <span class="ot">&lt;-</span> two.mspct</span>
<span id="cb200-2"><a href="#cb200-2" tabindex="-1"></a><span class="fu">names</span>(another_two.mspct) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>)</span>
<span id="cb200-3"><a href="#cb200-3" tabindex="-1"></a><span class="fu">convolve_each</span>(another_two.mspct, two.mspct)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 2]
## --- Member: a_time.01 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## --- Member: a_time.02 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## --- Member: b_time.01 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:39:00.797266 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## --- Member: b_time.02 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:39:00.797266 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## 
## --- END ---</code></pre>
<p>The function <code>convolve_each</code> will use other operators or
functions and even pass additional named arguments when these are
supplied as arguments.</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb202-1"><a href="#cb202-1" tabindex="-1"></a><span class="fu">convolve_each</span>(two.mspct, sun.spct, <span class="at">oper =</span> <span class="st">`</span><span class="at">+</span><span class="st">`</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,630 x 2]
## Wavelength range 290-800 nm, step 0.01-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:38:00.379657 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,630 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     290.         0
## 4     291.         0
## # ℹ 1,626 more rows
## --- Member: time.02 ---
## Object: source_spct [1,630 x 2]
## Wavelength range 290-800 nm, step 0.01-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2023-06-12 18:39:00.797266 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,630 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     290.         0
## 4     291.         0
## # ℹ 1,626 more rows
## 
## --- END ---</code></pre>
<hr />
<p>There are cases where functions <code>convolve_each()</code> and
<code>msmsply()</code> can be both used, but there are also cases where
their differences matter. An example is convolving two collections of
spectra, a case where only <code>convolve_each()</code> can be used. In
contrast, when one of the arguments is not a spectrum or a collection of
spectra, <code>msmsply()</code> should be used instead.</p>
<hr />
</div>
<div id="metadata-attributes-1" class="section level3">
<h3>Metadata attributes</h3>
<p>Some of the <code>set</code> and <code>get</code> functions used with
attributes have method definitions for collections of spectra. Some
examples follow.</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb204-1"><a href="#cb204-1" tabindex="-1"></a><span class="fu">when_measured</span>(two.mspct)</span></code></pre></div>
<pre><code>## # A tibble: 2 × 2
##   spct.idx when.measured      
##   &lt;fct&gt;    &lt;dttm&gt;             
## 1 time.01  2023-06-12 18:38:00
## 2 time.02  2023-06-12 18:39:00</code></pre>
<div class="sourceCode" id="cb206"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb206-1"><a href="#cb206-1" tabindex="-1"></a><span class="fu">when_measured</span>(two.mspct, <span class="at">simplify =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2023-06-12 18:38:00 UTC&quot; &quot;2023-06-12 18:39:00 UTC&quot;</code></pre>
<div class="sourceCode" id="cb208"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb208-1"><a href="#cb208-1" tabindex="-1"></a><span class="fu">when_measured</span>(two.mspct) <span class="ot">&lt;-</span> <span class="fu">ymd</span>(<span class="st">&quot;2015-10-31&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;Europe/Helsinki&quot;</span>)</span>
<span id="cb208-2"><a href="#cb208-2" tabindex="-1"></a><span class="fu">when_measured</span>(two.mspct)</span></code></pre></div>
<pre><code>## # A tibble: 2 × 2
##   spct.idx when.measured      
##   &lt;fct&gt;    &lt;dttm&gt;             
## 1 time.01  2015-10-30 22:00:00
## 2 time.02  2015-10-30 22:00:00</code></pre>
<div class="sourceCode" id="cb210"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb210-1"><a href="#cb210-1" tabindex="-1"></a><span class="fu">when_measured</span>(two.mspct, <span class="at">simplify =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2015-10-30 22:00:00 UTC&quot;</code></pre>
<div class="sourceCode" id="cb212"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb212-1"><a href="#cb212-1" tabindex="-1"></a><span class="fu">when_measured</span>(two.mspct) <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="fu">ymd_hm</span>(<span class="st">&quot;2015-10-31 10:00&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;Europe/Helsinki&quot;</span>),</span>
<span id="cb212-2"><a href="#cb212-2" tabindex="-1"></a>                                 <span class="fu">ymd_hm</span>(<span class="st">&quot;2015-10-31 11:00&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;Europe/Helsinki&quot;</span>))</span>
<span id="cb212-3"><a href="#cb212-3" tabindex="-1"></a><span class="fu">when_measured</span>(two.mspct) <span class="co"># UTC shown!</span></span></code></pre></div>
<pre><code>## # A tibble: 2 × 2
##   spct.idx when.measured      
##   &lt;fct&gt;    &lt;dttm&gt;             
## 1 time.01  2015-10-31 08:00:00
## 2 time.02  2015-10-31 09:00:00</code></pre>
<div class="sourceCode" id="cb214"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb214-1"><a href="#cb214-1" tabindex="-1"></a><span class="fu">when_measured</span>(two.mspct, <span class="at">simplify =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2015-10-31 08:00:00 UTC&quot; &quot;2015-10-31 09:00:00 UTC&quot;</code></pre>
<div class="sourceCode" id="cb216"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb216-1"><a href="#cb216-1" tabindex="-1"></a>two.mspct</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2015-10-31 08:00:00 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## --- Member: time.02 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2015-10-31 09:00:00 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## 
## --- END ---</code></pre>
<p>Other methods available are <code>getWhereMeasured</code> and
<code>setWhereMeasured</code>, and <code>getWhatMeasured</code> and
<code>setWhatMeasured</code>.</p>
<p>Functions <code>when.measured2tb()</code>, <code>geocode2tb()</code>,
<code>lon2tb()</code>, <code>lat2tb()</code> and
<code>what.measured2tb()</code> extract these same attributes from
collection members into a tibble or data frame. In contrast to the “get”
methods described above, if an existing data frame or tibble with a
matching number of rows is passed as second argument, the values for the
attribute are saved into a new column appended at the right edge of the
tibble or data frame.</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb218-1"><a href="#cb218-1" tabindex="-1"></a><span class="fu">when_measured2tb</span>(sun_evening.mspct)</span></code></pre></div>
<pre><code>## # A tibble: 5 × 2
##   spct.idx when.measured      
##   &lt;fct&gt;    &lt;dttm&gt;             
## 1 time.01  2023-06-12 18:38:00
## 2 time.02  2023-06-12 18:39:00
## 3 time.03  2023-06-12 18:40:00
## 4 time.04  2023-06-12 18:41:00
## 5 time.05  2023-06-12 18:42:00</code></pre>
<p>By default the new column is named after the name of the attribute,
but this default can be overridden by the user.</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb220-1"><a href="#cb220-1" tabindex="-1"></a><span class="fu">when_measured2tb</span>(sun_evening.mspct, <span class="at">col.names =</span> <span class="fu">c</span>(<span class="at">when.measured =</span> <span class="st">&quot;acquisition.time&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 5 × 2
##   spct.idx acquisition.time   
##   &lt;fct&gt;    &lt;dttm&gt;             
## 1 time.01  2023-06-12 18:38:00
## 2 time.02  2023-06-12 18:39:00
## 3 time.03  2023-06-12 18:40:00
## 4 time.04  2023-06-12 18:41:00
## 5 time.05  2023-06-12 18:42:00</code></pre>
<p>Function <code>spct_metadata()</code> returns the metadata in a
tibble. Unless the user supplies a list of names of attributes, all
applicable metadata values are returned. A single spectrum or a
collection of spectra can be passed. By default columns containing only
missing data are dropped.</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb222-1"><a href="#cb222-1" tabindex="-1"></a><span class="fu">spct_metadata</span>(two.mspct)</span></code></pre></div>
<pre><code>## # A tibble: 2 × 11
##   spct.idx   lat   lon address    when.measured       what.measured how.measured
##   &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;dttm&gt;              &lt;chr&gt;         &lt;chr&gt;       
## 1 time.01   60.2  24.0 Viikki, H… 2015-10-31 08:00:00 cosine.hour.9 &quot;Acquired w…
## 2 time.02   60.2  24.0 Viikki, H… 2015-10-31 09:00:00 cosine.hour.9 &quot;Acquired w…
## # ℹ 4 more variables: normalized &lt;dbl&gt;, multiplier &lt;dbl&gt;, time.unit &lt;Duration&gt;,
## #   bswf.used &lt;chr&gt;</code></pre>
<div class="sourceCode" id="cb224"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb224-1"><a href="#cb224-1" tabindex="-1"></a><span class="fu">spct_metadata</span>(two.mspct, </span>
<span id="cb224-2"><a href="#cb224-2" tabindex="-1"></a>              <span class="at">col.names =</span> <span class="fu">c</span>(<span class="st">&quot;when.measured&quot;</span> <span class="ot">=</span> <span class="st">&quot;time&quot;</span>, </span>
<span id="cb224-3"><a href="#cb224-3" tabindex="-1"></a>                            <span class="st">&quot;where.measured&quot;</span> <span class="ot">=</span> <span class="st">&quot;geocode&quot;</span>),</span>
<span id="cb224-4"><a href="#cb224-4" tabindex="-1"></a>              <span class="at">unnest =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## # A tibble: 2 × 3
##   spct.idx time                geocode         
##   &lt;fct&gt;    &lt;dttm&gt;              &lt;named list&gt;    
## 1 time.01  2015-10-31 08:00:00 &lt;tibble [1 × 3]&gt;
## 2 time.02  2015-10-31 09:00:00 &lt;tibble [1 × 3]&gt;</code></pre>
<p>Function <code>add_attr2tb()</code> adds one or more columns with
attributes to a tibble or data frame. We here also demonstrate that
because the data frame object is passed to the first positional
argument, we can use a <em>pipe</em>. This difference in interface is
the main difference between this function and
<code>spct_metadata()</code>.</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb226-1"><a href="#cb226-1" tabindex="-1"></a><span class="fu">q_irrad</span>(two.mspct) <span class="sc">%&gt;%</span></span>
<span id="cb226-2"><a href="#cb226-2" tabindex="-1"></a>  <span class="fu">add_attr2tb</span>(two.mspct, </span>
<span id="cb226-3"><a href="#cb226-3" tabindex="-1"></a>              <span class="at">col.names =</span> <span class="fu">c</span>(<span class="st">&quot;lon&quot;</span>, <span class="st">&quot;lat&quot;</span>, <span class="st">&quot;when.measured&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 2 × 5
##   spct.idx  Q_Total   lon   lat when.measured      
##   &lt;fct&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt;             
## 1 time.01  0.000132  24.0  60.2 2015-10-31 08:00:00
## 2 time.02  0.000126  24.0  60.2 2015-10-31 09:00:00</code></pre>
<p>We can set the desired names for the columns if we wish them to be
something else than the default.</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb228-1"><a href="#cb228-1" tabindex="-1"></a><span class="fu">q_irrad</span>(two.mspct) <span class="sc">%&gt;%</span></span>
<span id="cb228-2"><a href="#cb228-2" tabindex="-1"></a>  <span class="fu">add_attr2tb</span>(two.mspct, </span>
<span id="cb228-3"><a href="#cb228-3" tabindex="-1"></a>              <span class="at">col.names =</span> <span class="fu">c</span>(<span class="at">lon =</span> <span class="st">&quot;longitude&quot;</span>, </span>
<span id="cb228-4"><a href="#cb228-4" tabindex="-1"></a>                            <span class="at">lat =</span> <span class="st">&quot;latitude&quot;</span>, </span>
<span id="cb228-5"><a href="#cb228-5" tabindex="-1"></a>                            <span class="at">when.measured =</span> <span class="st">&quot;time&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 2 × 5
##   spct.idx  Q_Total longitude latitude time               
##   &lt;fct&gt;       &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dttm&gt;             
## 1 time.01  0.000132      24.0     60.2 2015-10-31 08:00:00
## 2 time.02  0.000126      24.0     60.2 2015-10-31 09:00:00</code></pre>
</div>
</div>
<div id="wavebands" class="section level2">
<h2>Wavebands</h2>
<p>When a range of wavelengths or a range of wavelengths plus a spectral
weighting function (SWF) is needed for radiation summaries or
transformations, methods, operators and functions defined in package
‘<strong>photobiology</strong>’ use <code>waveband</code> objects to
store these data. A few other bits of information can be included to
fine-tune calculations. The waveband definitions do NOT describe whether
input spectral irradiances are photon or energy based, nor whether the
output irradiance will be based on photon or energy units. All waveband
objects belong to the S3 class <code>waveband</code>.</p>
<p>A waveband stores the boundaries of a range of wavelengths, <span class="math inline">\(\lambda_1\)</span> and <span class="math inline">\(\lambda_2\)</span>, so that wavelengths within
<span class="math inline">\(\lambda_1 \ge \lambda &gt;
\lambda_2\)</span> belong to the waveband. If the waveband describes a
spectral weighting function, in addition to the range, two formulations
of the function used to compute the weights as a function of wavelength
are also stored, <span class="math inline">\(w_E(\lambda)\)</span> and
<span class="math inline">\(w_Q(\lambda)\)</span> to be used with
energy- or photon based irradiances.</p>
<p>Spectral weighting functions are normally used to compute effective
irradiances. In the current implementation their use is limited to this
case, while for other summaries only the wavelength range is made use
of, even when weighting functions are available.</p>
<div id="construction-2" class="section level3">
<h3>Construction</h3>
<p>To create a waveband object we use constructor function
<code>waveband</code>, and optionally giving a name to it. <strong>We
will use these objects in many of the examples below, so you will need
to run the code chunk bellow to be able to reproduce those
examples.</strong> It should be noted that waveband constructors for the
most frequently used wavelength-range definitions are provided by
package ‘<strong>photobiologyWavebands</strong>’.</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb230-1"><a href="#cb230-1" tabindex="-1"></a>PAR.wb <span class="ot">&lt;-</span> <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">400</span>, <span class="dv">700</span>), <span class="at">wb.name =</span> <span class="st">&quot;PAR&quot;</span>)</span>
<span id="cb230-2"><a href="#cb230-2" tabindex="-1"></a>UVA.wb <span class="ot">&lt;-</span> <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">315</span>, <span class="dv">400</span>), <span class="at">wb.name =</span> <span class="st">&quot;UVA&quot;</span>)</span>
<span id="cb230-3"><a href="#cb230-3" tabindex="-1"></a>UVB.wb <span class="ot">&lt;-</span> <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">280</span>, <span class="dv">315</span>), <span class="at">wb.name =</span> <span class="st">&quot;UVB&quot;</span>)</span>
<span id="cb230-4"><a href="#cb230-4" tabindex="-1"></a>UVC.wb <span class="ot">&lt;-</span> <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">280</span>), <span class="at">wb.name =</span> <span class="st">&quot;UVC&quot;</span>)</span>
<span id="cb230-5"><a href="#cb230-5" tabindex="-1"></a>UV.wb  <span class="ot">&lt;-</span> <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">400</span>), <span class="at">wb.name =</span>  <span class="st">&quot;UV&quot;</span>)</span>
<span id="cb230-6"><a href="#cb230-6" tabindex="-1"></a>UV_bands.lst <span class="ot">&lt;-</span> <span class="fu">list</span>(UVC.wb, UVB.wb, UVA.wb)</span></code></pre></div>
<p>When including a BSWF, we can supply, one or two versions of
functions returning the weights as a function of wavelength. Several
such functions are defined in package
‘<strong>photobiologyWavebands</strong>’ as well as waveband
constructors using them. Here we show how a waveband can be defined
based on a SWF, using the CIE definition for the erythemal spectral
weighting function. Although the constructor is smart enough to derive
the missing function when only one function is supplied, performance may
suffer unless two performance-optimized function are provided, one for
energy-based effect and a second one for photon-based effect.</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb231-1"><a href="#cb231-1" tabindex="-1"></a>CIE_e_fun <span class="ot">&lt;-</span></span>
<span id="cb231-2"><a href="#cb231-2" tabindex="-1"></a><span class="cf">function</span>(w.length){</span>
<span id="cb231-3"><a href="#cb231-3" tabindex="-1"></a>    CIE.energy <span class="ot">&lt;-</span> <span class="fu">numeric</span>(<span class="fu">length</span>(w.length))</span>
<span id="cb231-4"><a href="#cb231-4" tabindex="-1"></a>    CIE.energy[w.length <span class="sc">&lt;=</span> <span class="dv">298</span>] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb231-5"><a href="#cb231-5" tabindex="-1"></a>    CIE.energy[(w.length <span class="sc">&gt;</span> <span class="dv">298</span>) <span class="sc">&amp;</span> (w.length <span class="sc">&lt;=</span> <span class="dv">328</span>)] <span class="ot">&lt;-</span></span>
<span id="cb231-6"><a href="#cb231-6" tabindex="-1"></a>      <span class="dv">10</span><span class="sc">^</span>(<span class="fl">0.094</span><span class="sc">*</span>(<span class="dv">298</span><span class="sc">-</span>w.length[(w.length <span class="sc">&gt;</span> <span class="dv">298</span>) <span class="sc">&amp;</span> (w.length <span class="sc">&lt;=</span> <span class="dv">328</span>)]))</span>
<span id="cb231-7"><a href="#cb231-7" tabindex="-1"></a>    CIE.energy[(w.length <span class="sc">&gt;</span> <span class="dv">328</span>) <span class="sc">&amp;</span> (w.length <span class="sc">&lt;=</span> <span class="dv">400</span>)] <span class="ot">&lt;-</span></span>
<span id="cb231-8"><a href="#cb231-8" tabindex="-1"></a>      <span class="dv">10</span><span class="sc">^</span>(<span class="fl">0.015</span><span class="sc">*</span>(<span class="dv">139</span><span class="sc">-</span>w.length[(w.length <span class="sc">&gt;</span> <span class="dv">328</span>) <span class="sc">&amp;</span> (w.length <span class="sc">&lt;=</span> <span class="dv">400</span>)]))</span>
<span id="cb231-9"><a href="#cb231-9" tabindex="-1"></a>    CIE.energy[w.length <span class="sc">&gt;</span> <span class="dv">400</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb231-10"><a href="#cb231-10" tabindex="-1"></a>    <span class="fu">return</span>(CIE.energy)</span>
<span id="cb231-11"><a href="#cb231-11" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb232"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb232-1"><a href="#cb232-1" tabindex="-1"></a>CIE.wb <span class="ot">&lt;-</span> <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">250</span>, <span class="dv">400</span>), <span class="at">weight =</span> <span class="st">&quot;SWF&quot;</span>,</span>
<span id="cb232-2"><a href="#cb232-2" tabindex="-1"></a>                   <span class="at">SWF.e.fun =</span> CIE_e_fun, <span class="at">SWF.norm =</span> <span class="dv">298</span>)</span></code></pre></div>
<p>Another case where you might want to enter the same function twice,
is if you are using an absorptance spectrum as SWF, as the percent of
radiation absorbed will be independent of whether photon or energy units
are used for the spectral irradiance.</p>
<p>The first argument to <code>waveband()</code> does not need to be a
numeric vector of length two. Any R object of a class that supplies a
<code>range()</code> method definition that can be interpreted as a
range of wavelengths in nanometres can be used. As a consequence, when
wanting to construct a waveband covering the whole range of a spectrum
one can simply supply the spectrum as argument, or to construct an
non-weighed waveband which covers exactly the same range of wavelengths
as an existing effective (weighted) waveband, one can supply a waveband
object as an argument.</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb233-1"><a href="#cb233-1" tabindex="-1"></a><span class="fu">waveband</span>(sun.spct)</span></code></pre></div>
<pre><code>## Total 
## low (nm) 280 
## high (nm) 800 
## weighted none</code></pre>
<p>An “empty” waveband is returned by some functions as a “null”
value.</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb235-1"><a href="#cb235-1" tabindex="-1"></a><span class="fu">waveband</span>()</span></code></pre></div>
<pre><code>## Not available 
## low (nm) NA 
## high (nm) NA 
## weighted none</code></pre>
</div>
<div id="querying-the-class-2" class="section level3">
<h3>Querying the class</h3>
<p>The function <code>is.waveband</code> can the used to query any R
object. This function returns a logical value.</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb237-1"><a href="#cb237-1" tabindex="-1"></a><span class="fu">is.waveband</span>(PAR.wb)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Above, we demonstrate that <code>PAR.wb</code> is a waveband object,
the function <code>photobiologyWavebands::PAR()</code> is a waveband
constructor returning a waveband object. See package
‘<strong>photobiologyWavebands</strong>’ for details on pre-defined
waveband constructors for frequently used wavelength ranges and
biological spectral weighting functions (BSWFs).</p>
</div>
<div id="retrieving-properties" class="section level3">
<h3>Retrieving properties</h3>
<p>The function <code>is_effective</code> can the used to query any R
object.</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb239-1"><a href="#cb239-1" tabindex="-1"></a><span class="fu">is_effective</span>(<span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">400</span>,<span class="dv">500</span>)))</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
</div>
</div>
<div id="collections-of-wavebands" class="section level2">
<h2>Collections of wavebands</h2>
<p>In the current implementation there is no special class used for
storing collections of <code>waveband</code> objects. We simply use base
R’s <code>list</code> class.</p>
<div id="construction-3" class="section level3">
<h3>Construction</h3>
<div id="list-constructor" class="section level4">
<h4>List constructor</h4>
<p>Just base R’s functions used to create a list object.</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb241-1"><a href="#cb241-1" tabindex="-1"></a>wavebands <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">300</span>,<span class="dv">400</span>)), <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">400</span>,<span class="dv">500</span>)))</span>
<span id="cb241-2"><a href="#cb241-2" tabindex="-1"></a>wavebands</span></code></pre></div>
<pre><code>## [[1]]
## range.300.400 
## low (nm) 300 
## high (nm) 400 
## weighted none 
## 
## [[2]]
## range.400.500 
## low (nm) 400 
## high (nm) 500 
## weighted none</code></pre>
</div>
<div id="special-constructor" class="section level4">
<h4>Special constructor</h4>
<p>The function <code>split_bands</code> can be used to generate lists
of non-weighed wavebands in two different ways: a) it can be used to
split a range of wavelengths given by an R object into a series of
adjacent wavebands, or b) with a list of objects returning ranges, it
can be used to create non-adjacent and even overlapping wavebands.</p>
<p>The code chunk bellow shows an example of two variations of case a).
With the default value for <code>length.out</code> of <code>NULL</code>
each numerical value in the input is taken as a wavelength (nm) at the
boundary between adjacent wavebands. If a numerical value is supplied to
<code>length.out</code>, then the whole wavelength range of the input is
split into this number of equally spaced adjacent wavebands.</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb243-1"><a href="#cb243-1" tabindex="-1"></a><span class="fu">split_bands</span>(<span class="fu">c</span>(<span class="dv">200</span>, <span class="dv">225</span>, <span class="dv">300</span>))</span></code></pre></div>
<pre><code>## $wb1
## range.200.225 
## low (nm) 200 
## high (nm) 225 
## weighted none 
## 
## $wb2
## range.225.300 
## low (nm) 225 
## high (nm) 300 
## weighted none</code></pre>
<div class="sourceCode" id="cb245"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb245-1"><a href="#cb245-1" tabindex="-1"></a><span class="fu">split_bands</span>(<span class="fu">c</span>(<span class="dv">200</span>, <span class="dv">225</span>, <span class="dv">300</span>), <span class="at">length.out =</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## $wb1
## range.200.250 
## low (nm) 200 
## high (nm) 250 
## weighted none 
## 
## $wb2
## range.250.300 
## low (nm) 250 
## high (nm) 300 
## weighted none</code></pre>
<p>In both examples above, the output is a list of two wavebands, but
the <em>split</em> boundaries are at a different wavelength. The chunk
bellow gives a few more examples of the use of case a).</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb247-1"><a href="#cb247-1" tabindex="-1"></a><span class="fu">split_bands</span>(sun.spct, <span class="at">length.out =</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## $wb1
## range.280.540 
## low (nm) 280 
## high (nm) 540 
## weighted none 
## 
## $wb2
## range.540.800 
## low (nm) 540 
## high (nm) 800 
## weighted none</code></pre>
<div class="sourceCode" id="cb249"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb249-1"><a href="#cb249-1" tabindex="-1"></a><span class="fu">split_bands</span>(PAR.wb, <span class="at">length.out =</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## $wb1
## range.400.550 
## low (nm) 400 
## high (nm) 550 
## weighted none 
## 
## $wb2
## range.550.700 
## low (nm) 550 
## high (nm) 700 
## weighted none</code></pre>
<div class="sourceCode" id="cb251"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb251-1"><a href="#cb251-1" tabindex="-1"></a><span class="fu">split_bands</span>(<span class="fu">c</span>(<span class="dv">200</span>, <span class="dv">800</span>), <span class="at">length.out =</span> <span class="dv">3</span>)</span></code></pre></div>
<pre><code>## $wb1
## range.200.400 
## low (nm) 200 
## high (nm) 400 
## weighted none 
## 
## $wb2
## range.400.600 
## low (nm) 400 
## high (nm) 600 
## weighted none 
## 
## $wb3
## range.600.800 
## low (nm) 600 
## high (nm) 800 
## weighted none</code></pre>
<p>Now we demonstrate case b). This case is handled by recursion, so
each list element can be anything that is a valid input to the function,
including a nested list. However, the returned value is always a flat
list of wavebands.</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb253-1"><a href="#cb253-1" tabindex="-1"></a><span class="fu">split_bands</span>(<span class="fu">list</span>(<span class="at">A =</span> <span class="fu">c</span>(<span class="dv">200</span>, <span class="dv">300</span>), <span class="at">B =</span> <span class="fu">c</span>(<span class="dv">400</span>, <span class="dv">500</span>), <span class="at">C =</span> <span class="fu">c</span>(<span class="dv">250</span>, <span class="dv">350</span>)))</span></code></pre></div>
<pre><code>## $A
## range.200.300 
## low (nm) 200 
## high (nm) 300 
## weighted none 
## 
## $B
## range.400.500 
## low (nm) 400 
## high (nm) 500 
## weighted none 
## 
## $C
## range.250.350 
## low (nm) 250 
## high (nm) 350 
## weighted none</code></pre>
<div class="sourceCode" id="cb255"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb255-1"><a href="#cb255-1" tabindex="-1"></a><span class="fu">split_bands</span>(<span class="fu">list</span>(<span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">150</span>, <span class="dv">200</span>), <span class="fu">c</span>(<span class="dv">800</span>, <span class="dv">825</span>)))</span></code></pre></div>
<pre><code>## $wb.a
## range.100.150 
## low (nm) 100 
## high (nm) 150 
## weighted none 
## 
## $&lt;NA&gt;
## range.150.200 
## low (nm) 150 
## high (nm) 200 
## weighted none 
## 
## $wb.b
## range.800.825 
## low (nm) 800 
## high (nm) 825 
## weighted none</code></pre>
<p>In case b) if we supply a numeric value to <code>length.out</code>,
this value is used recursively for each element of the list.</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb257-1"><a href="#cb257-1" tabindex="-1"></a><span class="fu">split_bands</span>(UV_bands.lst, <span class="at">length.out  =</span>  <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## $wb.a
## range.100.190 
## low (nm) 100 
## high (nm) 190 
## weighted none 
## 
## $&lt;NA&gt;
## range.190.280 
## low (nm) 190 
## high (nm) 280 
## weighted none 
## 
## $wb.b
## range.280.297.5 
## low (nm) 280 
## high (nm) 298 
## weighted none 
## 
## $&lt;NA&gt;
## range.297.5.315 
## low (nm) 298 
## high (nm) 315 
## weighted none 
## 
## $wb.c
## range.315.357.5 
## low (nm) 315 
## high (nm) 358 
## weighted none 
## 
## $&lt;NA&gt;
## range.357.5.400 
## low (nm) 358 
## high (nm) 400 
## weighted none</code></pre>
<div class="sourceCode" id="cb259"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb259-1"><a href="#cb259-1" tabindex="-1"></a><span class="fu">split_bands</span>(<span class="fu">list</span>(<span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">150</span>, <span class="dv">200</span>), <span class="fu">c</span>(<span class="dv">800</span>, <span class="dv">825</span>)), <span class="at">length.out =</span> <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## $wb.a
## range.100.200 
## low (nm) 100 
## high (nm) 200 
## weighted none 
## 
## $wb.b
## range.800.825 
## low (nm) 800 
## high (nm) 825 
## weighted none</code></pre>
</div>
</div>
</div>
<div id="object-inspection-methods" class="section level2">
<h2>Object <em>inspection</em> methods</h2>
<div id="printing" class="section level3">
<h3>Printing</h3>
<p>The <code>print()</code> method for spectra is based on the method
defined in package ‘<strong>tibble</strong>’, consequently, it is
possible to use the options from this package to control printing. In
the code chunk below, <code>tibble.print_max</code>, the number of rows
in the spectral object above which only <code>tibble.print_min</code>
rows are printed, are both set to 5, instead of the default 20 and 10,
to avoid excessive clutter in our examples.</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb261-1"><a href="#cb261-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">tibble.print_max =</span> <span class="dv">4</span>)</span>
<span id="cb261-2"><a href="#cb261-2" tabindex="-1"></a><span class="fu">options</span>(<span class="at">tibble.print_min =</span> <span class="dv">4</span>)</span></code></pre></div>
<p>For explicit calls to <code>print()</code> its argument
<code>n</code> can be used to control the number of lines printed. If
<code>n</code> is set to <code>Inf</code> the whole spectrum is always
printed. The output differs from that of the <code>print()</code> method
from package ‘dplyr’ in that additional metadata specific to spectra are
shown.</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb262-1"><a href="#cb262-1" tabindex="-1"></a><span class="fu">print</span>(sun.spct, <span class="at">n =</span> <span class="dv">3</span>)</span></code></pre></div>
<p>Specialized <code>print()</code> methods for collections of spectra
and for <code>waveband</code> objects are also defined.</p>
</div>
<div id="summary" class="section level3">
<h3>Summary</h3>
<p>The <code>summary()</code> method for spectra is based on base R’s
<code>summary()</code> method for data frames, and accepts the same
arguments. The main difference is that the attributes containing
metadata and dimensions of the original spectrum object are copied to
the summary object.</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb263-1"><a href="#cb263-1" tabindex="-1"></a><span class="fu">summary</span>(sun.spct)</span></code></pre></div>
<p>Specialized <code>print()</code> methods for summaries of spectra are
defined. The output differs from that of the <code>print()</code> method
from base R in that additional metadata specific to spectra are
shown.</p>
</div>
<div id="handling-nas" class="section level3">
<h3>Handling <code>NA</code>s</h3>
<p>Functions <code>na.omit()</code> and <code>na.exclude</code> are
implemented for all spectral classes. These methods test for
<code>NA</code>s only the spectral data, not wavelength. They set the
<code>&quot;na.action&quot;</code> attribute in the same way as the corresponding
methods for data frames. In the case of <code>na.fail()</code>,
<code>na.pass()</code> and <code>na.action()</code>, the methods from
base R, can be used with spectra.</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb264-1"><a href="#cb264-1" tabindex="-1"></a><span class="fu">na.omit</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb266"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb266-1"><a href="#cb266-1" tabindex="-1"></a><span class="fu">na.exclude</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
</div>
</div>
<div id="transformations-using-operators" class="section level2">
<h2>Transformations: using operators</h2>
<div id="binary-operators" class="section level3">
<h3>Binary operators</h3>
<p>All of R’s built-in maths operators have definitions for spectra. It
is possible to sum, subtract, multiply and divide spectra. These
operators can be used even if the spectral data is on different
arbitrary sets of wavelengths. Operators by default return values
expressed in energy units. Only certain operations are meaningful for a
given combination of objects belonging to different classes, and
meaningless combinations return <code>NA</code> also issuing a warning
(see Table 5). By default operations are carried out on spectral energy
irradiance for <code>source_spct</code> objects and transmittance for
<code>filter_spct</code> objects.</p>
<hr />
<p><strong>Table 5. Binary operators and their operands.</strong>
Validity and class of result. All operations marked
<code>\Y&#39; are allowed, those marked</code>’ are forbidden and return
<code>NA</code> and issue a warning. Operators <code>%/%</code> and
<code>%%</code> follow <code>/</code>.</p>
<table>
<colgroup>
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="14%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">e1</th>
<th align="center"><code>+</code></th>
<th align="center"><code>-</code></th>
<th align="center"><code>*</code></th>
<th align="center"><code>/</code></th>
<th align="center"><code>^</code></th>
<th align="left">e2</th>
<th align="left">value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>raw_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>raw_spct</code></td>
<td align="left"><code>raw_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>cps_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>cps_spct</code></td>
<td align="left"><code>cps_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>source_spct</code></td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>filter_spct</code> (T)</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>filter_spct</code></td>
<td align="left"><code>filter_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>filter_spct</code> (A)</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>filter_spct</code></td>
<td align="left"><code>filter_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>reflector_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>reflector_spct</code></td>
<td align="left"><code>reflector_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>object_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>object_spct</code></td>
<td align="left">–</td>
</tr>
<tr class="even">
<td align="left"><code>response_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>response_spct</code></td>
<td align="left"><code>response_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>chroma_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>chroma_spct</code></td>
<td align="left"><code>chroma_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>raw_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>raw_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>cps_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>cps_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>calibration_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>calibration_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>filter_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>filter_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>reflector_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>reflector_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>object_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>numeric</code></td>
<td align="left">–</td>
</tr>
<tr class="odd">
<td align="left"><code>response_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>response_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>chroma_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>chroma_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>cps_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>calibration_spct</code></td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>response_spct</code></td>
<td align="left"><code>response_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>filter_spct</code> (T)</td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>filter_spct</code> (A)</td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>reflector_spct</code></td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>object_spct</code></td>
<td align="left">–</td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>waveband</code> (no BSWF)</td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>waveband</code> (BSWF)</td>
<td align="left"><code>source_spct</code> (effective)</td>
</tr>
</tbody>
</table>
<hr />
<div class="sourceCode" id="cb268"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb268-1"><a href="#cb268-1" tabindex="-1"></a>sun.spct <span class="sc">*</span> sun.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<p>When meaningful, operations between different spectra are also
allowed. For example, it is possible to simulate the effect of a filter
on a light source by multiplying (or convolving) the two spectra.</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb270-1"><a href="#cb270-1" tabindex="-1"></a>sun.spct <span class="sc">*</span> polyester.spct</span></code></pre></div>
<pre><code>## Object: source_spct [533 x 2]
## Wavelength range 280-800 nm, step 0.07692308-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 533 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     281          0
## 4     282.         0
## # ℹ 529 more rows</code></pre>
<p>If we have two layers of the filter, this can be approximated using
either of these two statements.</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb272-1"><a href="#cb272-1" tabindex="-1"></a>sun.spct <span class="sc">*</span> polyester.spct <span class="sc">*</span> polyester.spct</span></code></pre></div>
<pre><code>## Object: source_spct [533 x 2]
## Wavelength range 280-800 nm, step 0.07692308-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 533 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     281          0
## 4     282.         0
## # ℹ 529 more rows</code></pre>
<div class="sourceCode" id="cb274"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb274-1"><a href="#cb274-1" tabindex="-1"></a>sun.spct <span class="sc">*</span> polyester.spct<span class="sc">^</span><span class="dv">2</span></span></code></pre></div>
<pre><code>## Object: source_spct [533 x 2]
## Wavelength range 280-800 nm, step 0.07692308-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 533 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     281          0
## 4     282.         0
## # ℹ 529 more rows</code></pre>
<p>Operators are also defined for operations between a spectrum and a
numeric vector (with normal recycling).</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb276-1"><a href="#cb276-1" tabindex="-1"></a>sun.spct <span class="sc">*</span> <span class="dv">2</span></span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb278"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb278-1"><a href="#cb278-1" tabindex="-1"></a><span class="dv">2</span> <span class="sc">*</span> sun.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb280"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb280-1"><a href="#cb280-1" tabindex="-1"></a>sun.spct <span class="sc">*</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<p>There is one special case, for <code>chroma_spct</code>: if the
numeric operand has length three, containing three <em>named</em> values
<em>x</em>, <em>y</em> and <em>z</em>, the corresponding value is used
for each of the chromaticity <em>columns</em> in the
<code>chroma_spct</code>. Un-named values or differently named values
are not treated specially.</p>
<p>Operators are also defined for operations between an spectrum and a
<code>waveband</code> object. The next to code chunks demonstrate how
the class of the result depends on whether the <code>waveband</code>
object describes a range of wavelengths or a range of wavelengths plus a
BSWF.</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb282-1"><a href="#cb282-1" tabindex="-1"></a>sun.spct <span class="sc">*</span> UVB.wb</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280-315 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 37 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 33 more rows</code></pre>
<div class="sourceCode" id="cb284"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb284-1"><a href="#cb284-1" tabindex="-1"></a>sun.spct <span class="sc">*</span> CIE.wb</span></code></pre></div>
<p>And of course these operations can be combined into more complex
statements, including parentheses, when needed. The example below
estimates the difference in effective spectral irradiance according to
the CIE98 definition, between sunlight and sunlight filtered with a
polyester film. Of course, the result is valid only for the solar
spectral data used, which corresponds to Southern Finland.</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb285-1"><a href="#cb285-1" tabindex="-1"></a>sun.spct <span class="sc">*</span> CIE.wb <span class="sc">-</span> sun.spct <span class="sc">*</span> polyester.spct <span class="sc">*</span> CIE.wb</span></code></pre></div>
<pre><code>## Object: source_spct [133 x 2]
## Wavelength range 280-400 nm, step 0.07692308-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Data weighted using &#39;range.250.400.wtd&#39; BSWF
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 133 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     281          0
## 4     282.         0
## # ℹ 129 more rows</code></pre>
</div>
<div id="unary-operators-and-maths-functions" class="section level3">
<h3>Unary operators and maths functions</h3>
<p>Many common maths functions, as well as unary minus and plus, are
implemented for spectral objects (see Table 6).</p>
<hr />
<p><strong>Table 6. Unary operators and maths functions for
spectra.</strong> Classes for which they are implemented and class of
the result. All operations marked Y are allowed, those marked N are not
implemented and return <code>NA</code> and issue a warning. Additional
supported functions:
<code>log2, log10, sin, cos, tan, asin, acos, atan, sinpi, cospi, tanpi, signif, floor, ceiling, trunc, sign, abs</code>.</p>
<table style="width:100%;">
<colgroup>
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">e1</th>
<th align="center"><code>+, -</code></th>
<th align="center"><code>log, exp</code></th>
<th align="center">trig.</th>
<th align="center"><code>round</code></th>
<th align="center"><code>sqrt</code></th>
<th align="left">value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>raw_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>raw_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>cps_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>cps_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>calibration_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>calibration_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>source_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>filter_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>filter_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>reflector_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>reflector_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>object_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left">–</td>
</tr>
<tr class="even">
<td align="left"><code>response_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>response_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>chroma_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>chroma_spct</code></td>
</tr>
</tbody>
</table>
<hr />
<div class="sourceCode" id="cb287"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb287-1"><a href="#cb287-1" tabindex="-1"></a><span class="sc">-</span>sun.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb289"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb289-1"><a href="#cb289-1" tabindex="-1"></a><span class="fu">sqrt</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
</div>
<div id="options" class="section level3">
<h3>Options</h3>
<p>Table 7 lists all the recognized options affecting maths operators
and functions, and their default values. Within the suite all functions
have a default value which is used when the options are undefined.
Options are set using base R’s function <code>options</code>, and
queried with functions <code>options</code> and
<code>getOption</code>.</p>
<hr />
<p><strong>Table 7. Options used in the ‘r4photobiology suite’ and
recognized by methods, operators and functions in the ‘photobiology’
package.</strong> Option names, accepted and default values, and the
purpose of the options are given. Option
<code>photobiology.verbose</code> is set to the value of R’s own
<code>verbose</code> option at the time the ‘photobiology’ package is
attached to the session.</p>
<table>
<colgroup>
<col width="20%" />
<col width="21%" />
<col width="37%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Option</th>
<th align="left"><code>values</code>, <strong>default</strong></th>
<th align="left">purpose, <em>unit</em></th>
<th><em>convenience function</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>Base R</strong></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr class="even">
<td align="left"><code>digits</code></td>
<td align="left">7</td>
<td align="left"><span class="math inline">\(d - 3\)</span> used by
<code>summary</code></td>
<td></td>
</tr>
<tr class="odd">
<td align="left"><strong>tibble</strong></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr class="even">
<td align="left">tibble.print_max</td>
<td align="left"><strong>20</strong></td>
<td align="left">Maximum number of rows printed</td>
<td></td>
</tr>
<tr class="odd">
<td align="left">tibble.print_min</td>
<td align="left"><strong>10</strong></td>
<td align="left">Number of rows printed if row number threshold is
exceeded</td>
<td></td>
</tr>
<tr class="even">
<td align="left">tibble.width</td>
<td align="left"><strong>NULL</strong></td>
<td align="left">Output width</td>
<td></td>
</tr>
<tr class="odd">
<td align="left"><strong>r4photobiology</strong></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr class="even">
<td align="left">photobiology.radiation.unit</td>
<td align="left"><strong>“energy”</strong></td>
<td align="left"><span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span></td>
<td><code>using_energy()</code>, <code>energy_as_default()</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>&quot;photon&quot;</code></td>
<td align="left"><span class="math inline">\(\mu
mol\,m^{-2}\,nm^{-1}\)</span></td>
<td><code>using_photon()</code>, <code>photon_as_default()</code></td>
</tr>
<tr class="even">
<td align="left">photobiology.filter.qty</td>
<td align="left"><strong>“transmittance”</strong></td>
<td align="left"><span class="math inline">\(/1\)</span></td>
<td><code>using_Tfr()</code>, <code>Tfr_as_default()</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>&quot;absorptance&quot;</code></td>
<td align="left"><span class="math inline">\(/1\)</span></td>
<td><code>using_Afr()</code>, <code>Afr_as_default()</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>&quot;absorbance&quot;</code></td>
<td align="left">a.u. <span class="math inline">\(\log_{10}\)</span>
base</td>
<td><code>using_A()</code>, <code>A_as_default()</code></td>
</tr>
<tr class="odd">
<td align="left">photobiology.strict.range</td>
<td align="left"><code>NA</code></td>
<td align="left">skip range test</td>
<td><code>strict_range_as_default(NA)</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>TRUE</code></td>
<td align="left">trigger an error</td>
<td><code>strict_range_as_default(TRUE)</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><strong>FALSE</strong></td>
<td align="left">trigger a warning</td>
<td><code>strict_range_as_default(FALSE)</code></td>
</tr>
<tr class="even">
<td align="left">photobiology.check.spct</td>
<td align="left"><strong>TRUE</strong></td>
<td align="left">enable <code>check_spct()</code></td>
<td><code>enable_check_spct()</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>FALSE</code></td>
<td align="left">disable <code>check_spct()</code></td>
<td><code>disable_check_spct()</code></td>
</tr>
<tr class="even">
<td align="left">photobiology.waveband.trim</td>
<td align="left"><code>FALSE</code></td>
<td align="left">exclude</td>
<td><code>wb_trim_as_default(FALSE)</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><strong>TRUE</strong></td>
<td align="left">trim or exclude</td>
<td><code>wb_trim_as_default(TRUE)</code></td>
</tr>
<tr class="even">
<td align="left">photobiology.use.cached.mult</td>
<td align="left"><strong>FALSE</strong></td>
<td align="left">do not cache intermediate results</td>
<td><code>use_cached_mult_as_default(FALSE)</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>TRUE</code></td>
<td align="left">cache intermediate results</td>
<td><code>use_cached_mult_as_default(TRUE)</code></td>
</tr>
<tr class="even">
<td align="left">photobiology.verbose</td>
<td align="left"><code>FALSE</code></td>
<td align="left">minimal warnings and messages</td>
<td><code>verbose_as_default(FALSE)</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>TRUE</code></td>
<td align="left">all warnings and messages</td>
<td><code>verbose_as_default(TRUE)</code></td>
</tr>
</tbody>
</table>
<p>The behaviour of the operators defined in this package depends on the
value of two global options. For example, if we would like the operators
to operate on spectral photon irradiance and return spectral photon
irradiance instead of spectral energy irradiance, this behaviour can be
set, and will remain active until unset or reset. It is possible to
change options using base R’s function <code>options()</code> as shown
in the next code chunk. The other options listed in the Table above can
be set similarly, while to unset any option, they can be given a
<code>NULL</code> value.</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb291-1"><a href="#cb291-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">photobiology.radiation.unit =</span> <span class="st">&quot;photon&quot;</span>)</span>
<span id="cb291-2"><a href="#cb291-2" tabindex="-1"></a>sun.spct <span class="sc">*</span> UVB.wb</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280-315 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 37 × 2
##   w.length s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 33 more rows</code></pre>
<div class="sourceCode" id="cb293"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb293-1"><a href="#cb293-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">photobiology.radiation.unit =</span> <span class="st">&quot;energy&quot;</span>)</span>
<span id="cb293-2"><a href="#cb293-2" tabindex="-1"></a>sun.spct <span class="sc">*</span> UVB.wb</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280-315 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 37 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 33 more rows</code></pre>
<p>However using convenience functions is easier. The chunk above can be
rewritten as below.</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb295-1"><a href="#cb295-1" tabindex="-1"></a><span class="fu">photon_as_default</span>()</span>
<span id="cb295-2"><a href="#cb295-2" tabindex="-1"></a>sun.spct <span class="sc">*</span> UVB.wb</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280-315 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 37 × 2
##   w.length s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 33 more rows</code></pre>
<div class="sourceCode" id="cb297"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb297-1"><a href="#cb297-1" tabindex="-1"></a><span class="fu">energy_as_default</span>()</span>
<span id="cb297-2"><a href="#cb297-2" tabindex="-1"></a>sun.spct <span class="sc">*</span> UVB.wb</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280-315 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 37 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 33 more rows</code></pre>
<div class="sourceCode" id="cb299"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb299-1"><a href="#cb299-1" tabindex="-1"></a><span class="fu">unset_radiation_unit_default</span>()</span></code></pre></div>
<p>Furthermore, it is possible to temporarily change the options for the
evaluation of a single, possibly compound, R expression using a
different syntax, reminiscent of that of R’s <code>with()</code>.</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb300-1"><a href="#cb300-1" tabindex="-1"></a><span class="fu">using_photon</span>(sun.spct <span class="sc">*</span> UVB.wb)</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280-315 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 37 × 2
##   w.length s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 33 more rows</code></pre>
<div class="sourceCode" id="cb302"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb302-1"><a href="#cb302-1" tabindex="-1"></a><span class="fu">using_energy</span>(sun.spct <span class="sc">*</span> UVB.wb)</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280-315 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 37 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 33 more rows</code></pre>
</div>
</div>
<div id="transformations-methods-and-functions" class="section level2">
<h2>Transformations: methods and functions</h2>
<p>In this section we describe methods and functions that take one or
more spectral objects, and in some cases also waveband objects, as
arguments and return another spectral object (see Tables 8 and 9) or
that take a collection of spectral objects, and in some cases also
waveband objects, as arguments and return a collection of spectral
objects.</p>
<hr />
<p><strong>Table 8. Transformation methods for spectra.</strong> Key: +
available, – not available.</p>
<table style="width:100%;">
<colgroup>
<col width="13%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">methods</th>
<th align="center">raw/cps</th>
<th align="center">source</th>
<th align="center">response</th>
<th align="center">filter</th>
<th align="center">reflector</th>
<th align="center">object</th>
<th align="center">chroma</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">merge</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">rbindspct</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">e2q, q2e</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">A2T, T2A</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">Afr2T, T2Afr</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">any2T, any2A, any2Afr</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">convertTfrType</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">convertThickness</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">subset</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">clip_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">trim_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">(trim_spct)</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">thin_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">interpolate_wl</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">(interpolate_spct)</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">fscale</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">fshift</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">normalize</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">clean</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">despike</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left"><em>maths operators</em></td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left"><em>maths functions</em></td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">tag</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">untag</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
</tbody>
</table>
<hr />
<hr />
<p><strong>Table 9. Transformation methods for collections of
spectra.</strong> Key: + available, – not available, <strong>ms</strong>
use <code>msmsply()</code> or <code>convolve_each()</code> to apply
function or operator to collection members.</p>
<table style="width:100%;">
<colgroup>
<col width="13%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">methods</th>
<th align="center">raw/cps</th>
<th align="center">source</th>
<th align="center">response</th>
<th align="center">filter</th>
<th align="center">reflector</th>
<th align="center">object</th>
<th align="center">chroma</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">convolve_each</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">msmsply</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">msdply</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">mslply</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">msaply</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">rbindspct</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">c</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left"><em>maths operators</em></td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
</tr>
<tr class="odd">
<td align="left"><em>maths functions</em></td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
</tr>
<tr class="even">
<td align="left">e2q, q2e</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">A2T, T2A</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">Afr2T, T2Afr</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">any2T, any2A, any2Afr</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">convertTfrType</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">convertThickness</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">clip_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">trim_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">trim2overlap</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">extend2extremes</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">(trim_mspct)</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">thin_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">interpolate_wl</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">(interpolate_mspct)</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">fscale</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">fshift</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">normalize</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">clean</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">despike</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">tag</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">untag</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
</tbody>
</table>
<hr />
<div id="manipulating-spectra" class="section level3">
<h3>Manipulating spectra</h3>
<p>Sometimes, especially for plotting, we may want to row-bind spectra.
When the aim is that the returned object retains its class and other
attributes like the time unit. Package ‘<strong>photobiology</strong>’
provides function <code>rbinspct</code> for row-binding spectra, with
the necessary checks for consistency of the bound spectra.</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb304-1"><a href="#cb304-1" tabindex="-1"></a><span class="co"># STOPGAP</span></span>
<span id="cb304-2"><a href="#cb304-2" tabindex="-1"></a>shade.spct <span class="ot">&lt;-</span> sun.spct</span></code></pre></div>
<p>By default an ID factor named <code>spct.idx</code> is added allow to
identify the source of the observations after the binding. If the
supplied list has named members, then these names are used as factor
levels. If a character value is supplied to as <code>idfactor</code>
argument, this is used as name for the factor.</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb305-1"><a href="#cb305-1" tabindex="-1"></a><span class="fu">rbindspct</span>(<span class="fu">list</span>(sun.spct, shade.spct))</span></code></pre></div>
<pre><code>## Object: source_spct [1,044 x 4]
## containing 2 spectra in long form
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## spct_1 measured on 2010-06-22 09:51:00 UTC
## spct_2 measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 1,044 × 4
##   w.length s.e.irrad s.q.irrad spct.idx
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;   
## 1     280          0         0 spct_1  
## 2     281.         0         0 spct_1  
## 3     282.         0         0 spct_1  
## 4     283.         0         0 spct_1  
## # ℹ 1,040 more rows</code></pre>
<div class="sourceCode" id="cb307"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb307-1"><a href="#cb307-1" tabindex="-1"></a><span class="fu">rbindspct</span>(<span class="fu">list</span>(<span class="at">A =</span> sun.spct, <span class="at">B =</span> shade.spct), <span class="at">idfactor =</span> <span class="st">&quot;site&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1,044 x 4]
## containing 2 spectra in long form
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## A measured on 2010-06-22 09:51:00 UTC
## B measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 1,044 × 4
##   w.length s.e.irrad s.q.irrad site 
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;
## 1     280          0         0 A    
## 2     281.         0         0 A    
## 3     282.         0         0 A    
## 4     283.         0         0 A    
## # ℹ 1,040 more rows</code></pre>
<p>The name of the ID factor is stored as metadata in attribute
<code>&quot;idfactor&quot;</code> of the spectral data object.</p>
<p>Special <em>Extract</em> methods for spectral objects have been
implemented. These are used by default and preserve the attributes used
by this package, except when the returned value is a single column from
the spectral object.</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb309-1"><a href="#cb309-1" tabindex="-1"></a>sun.spct[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, ]</span></code></pre></div>
<pre><code>## Object: source_spct [10 x 3]
## Wavelength range 280-288.30769 nm, step 0.9230769 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 10 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 6 more rows</code></pre>
<div class="sourceCode" id="cb311"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb311-1"><a href="#cb311-1" tabindex="-1"></a>sun.spct[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="dv">1</span>]</span></code></pre></div>
<pre><code>##  [1] 280.0000 280.9231 281.8462 282.7692 283.6923 284.6154 285.5385 286.4615
##  [9] 287.3846 288.3077</code></pre>
<div class="sourceCode" id="cb313"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb313-1"><a href="#cb313-1" tabindex="-1"></a>sun.spct[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="dv">1</span>, drop <span class="ot">=</span> <span class="cn">TRUE</span>]</span></code></pre></div>
<pre><code>##  [1] 280.0000 280.9231 281.8462 282.7692 283.6923 284.6154 285.5385 286.4615
##  [9] 287.3846 288.3077</code></pre>
<div class="sourceCode" id="cb315"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb315-1"><a href="#cb315-1" tabindex="-1"></a>sun.spct[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="st">&quot;w.length&quot;</span>, drop <span class="ot">=</span> <span class="cn">TRUE</span>]</span></code></pre></div>
<pre><code>##  [1] 280.0000 280.9231 281.8462 282.7692 283.6923 284.6154 285.5385 286.4615
##  [9] 287.3846 288.3077</code></pre>
<p>In contrast to <code>trim_spct</code>, <code>subset</code> never
interpolates or inserts <em>hinges</em>. On the other hand, the
<code>subset</code> argument accepts any logical expression and can be
consequently used to do subsetting, for example, based on factors. Both
<code>subset()</code> and <code>trim()</code> methods preserve
attributes.</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb317-1"><a href="#cb317-1" tabindex="-1"></a><span class="fu">subset</span>(sun.spct, s.e.irrad <span class="sc">&gt;</span> <span class="fl">0.2</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [475 x 3]
## Wavelength range 324-800 nm, step 1-3 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 475 × 3
##   w.length s.e.irrad   s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1      324     0.208 0.000000562
## 2      325     0.217 0.000000589
## 3      326     0.277 0.000000756
## 4      327     0.285 0.000000779
## # ℹ 471 more rows</code></pre>
<div class="sourceCode" id="cb319"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb319-1"><a href="#cb319-1" tabindex="-1"></a><span class="fu">subset</span>(sun.spct, w.length <span class="sc">&gt;</span> <span class="dv">600</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [200 x 3]
## Wavelength range 601-800 nm, step 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 200 × 3
##   w.length s.e.irrad  s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1      601     0.630 0.00000316
## 2      602     0.631 0.00000317
## 3      603     0.636 0.00000321
## 4      604     0.658 0.00000332
## # ℹ 196 more rows</code></pre>
<div class="sourceCode" id="cb321"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb321-1"><a href="#cb321-1" tabindex="-1"></a><span class="fu">subset</span>(sun.spct, <span class="fu">c</span>(<span class="cn">TRUE</span>, <span class="fu">rep</span>(<span class="cn">FALSE</span>, <span class="dv">99</span>)))</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 3]
## Wavelength range 280-779 nm, step 99-100 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 6 × 3
##   w.length s.e.irrad  s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1      280     0     0         
## 2      379     0.413 0.00000131
## 3      479     0.754 0.00000302
## 4      579     0.647 0.00000313
## 5      679     0.580 0.00000329
## 6      779     0.471 0.00000307</code></pre>
<p>R’s Extract methods <code>$</code> and <code>[[</code> can be used to
extract whole columns. Replace methods <code>$&lt;-</code> and
<code>[&lt;-</code> have definitions for spectral objects, which allow
their safe use. They work identically to those for data frames but check
the validity of the spectra after the replacement.</p>
</div>
<div id="conversions-between-radiation-units" class="section level3">
<h3>Conversions between radiation units</h3>
<p>The functions <code>e2q</code> and <code>q2e</code> can be used on
source spectra to convert spectral energy irradiance into spectral
photon irradiance and vice versa. They can be also used with response
spectra. A second optional argument sets the action with
<code>&quot;add&quot;</code> and <code>&quot;replace&quot;</code> as possible values. By
default these functions use normal copy semantics but also support
reference semantics.</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb323-1"><a href="#cb323-1" tabindex="-1"></a><span class="fu">e2q</span>(sun.spct, <span class="st">&quot;add&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb325"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb325-1"><a href="#cb325-1" tabindex="-1"></a><span class="fu">e2q</span>(sun.spct, <span class="st">&quot;replace&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<p>When a normalized spectrum is converted, the normalization is
reapplied to the converted data.</p>
</div>
<div id="conversions-among-transmission-quantities" class="section level3">
<h3>Conversions among transmission quantities</h3>
<p>For <code>filter_spct</code> objects functions <code>any2T()</code>,
<code>any2A()</code>, and <code>any2Afr()</code> allow conversion among
spectral transmittance, spectral absorptance and spectral absorbance.
Although some conversions require a known reflectance, either as an
<code>Rfr</code> column in the data or an <code>Rfr.constant</code> in
the attribute <code>filter.properties</code>.</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb327-1"><a href="#cb327-1" tabindex="-1"></a>polyester.spct</span></code></pre></div>
<pre><code>## Object: filter_spct [561 x 2]
## Wavelength range 240-800 nm, step 1 nm 
## Label: Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Rfr (/1): 0.074, thickness (mm): 0.125, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 561 × 2
##   w.length     Tfr
##      &lt;int&gt;   &lt;dbl&gt;
## 1      240 0.00482
## 2      241 0.00464
## 3      242 0.00446
## 4      243 0.00429
## # ℹ 557 more rows</code></pre>
<div class="sourceCode" id="cb329"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb329-1"><a href="#cb329-1" tabindex="-1"></a><span class="fu">any2Afr</span>(polyester.spct, <span class="st">&quot;add&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_spct [561 x 3]
## Wavelength range 240-800 nm, step 1 nm 
## Label: Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Rfr (/1): 0.074, thickness (mm): 0.125, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1]
##  Afr: Spectral absorptance [/1] 
## --
## # A tibble: 561 × 3
##   w.length     Tfr   Afr
##      &lt;int&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1      240 0.00482 0.921
## 2      241 0.00464 0.921
## 3      242 0.00446 0.922
## 4      243 0.00429 0.922
## # ℹ 557 more rows</code></pre>
<div class="sourceCode" id="cb331"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb331-1"><a href="#cb331-1" tabindex="-1"></a><span class="fu">any2Afr</span>(polyester.spct, <span class="st">&quot;replace&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_spct [561 x 2]
## Wavelength range 240-800 nm, step 1 nm 
## Label: Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Rfr (/1): 0.074, thickness (mm): 0.125, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Afr: Spectral absorptance [/1] 
## --
## # A tibble: 561 × 2
##   w.length   Afr
##      &lt;int&gt; &lt;dbl&gt;
## 1      240 0.921
## 2      241 0.921
## 3      242 0.922
## 4      243 0.922
## # ℹ 557 more rows</code></pre>
<p>When a normalized spectrum is converted, the normalization is not
reapplied to the converted data. <em>This will change in the
future.</em></p>
</div>
<div id="normalizing-a-spectrum" class="section level3">
<h3>Normalizing a spectrum</h3>
<p>Normalization is a way rescaling a spectrum so that the spectral
quantity takes a fixed value, in most cases exactly 1, at a specific
wavelength. Frequently this wavelength corresponds to the maximum value
of the spectral quantity.</p>
<p><span class="math display">\[Q_\mathrm{norm}(\lambda) =
\frac{Q(\lambda)}{\max{Q(\lambda)}}\]</span> When normalizing to a
specific wavelength, say 300 nm, the equation becomes <span class="math display">\[Q_\mathrm{norm}(\lambda) =
\frac{Q(\lambda)}{{Q(\lambda = 300)}}\]</span> Function
<code>normalize</code> permits normalizing a spectrum to a value of one
at an arbitrary wavelength (nm) or to the wavelength of either the
maximum or the minimum spectral value. It supports all the different
spectral classes. In the example we use a <code>source_spct</code>
object. (Equivalent functions with names spelled with “s” instead of “z”
are available.)</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb333-1"><a href="#cb333-1" tabindex="-1"></a><span class="fu">normalize</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Spectral data in s.e.irrad, s.q.irrad normalized to 1 at 451 nm, 531 nm (max in 280-800 nm)
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [normalized]
##  s.q.irrad: Spectral photon irradiance [normalized] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<p>Which is equivalent to supplying <code>&quot;max&quot;</code> as argument to
<code>norm</code>, it is also possible to give a range within which the
maximum should be searched.</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb335-1"><a href="#cb335-1" tabindex="-1"></a><span class="fu">normalize</span>(sun.spct, <span class="at">range =</span> PAR.wb, <span class="at">norm =</span> <span class="st">&quot;max&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Spectral data in s.e.irrad, s.q.irrad normalized to 1 at 451 nm, 531 nm (max in 400-700 nm)
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [normalized]
##  s.q.irrad: Spectral photon irradiance [normalized] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<p>It is also possible to normalize to an arbitrary wavelength within
the range of the data, even if it is not one of the wavelength values
present in the spectral object, as interpolation is used when
needed.</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb337-1"><a href="#cb337-1" tabindex="-1"></a><span class="fu">normalize</span>(sun.spct, <span class="at">norm =</span> <span class="fl">600.3</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Spectral data in s.e.irrad, s.q.irrad normalized to 1 at 600.3 nm, 600.3 nm (wavelength)
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [normalized]
##  s.q.irrad: Spectral photon irradiance [normalized] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<p>The normalization status of a spectral object can be tested with
method <code>is_normalized()</code> and the normalization used can be
recalled with method <code>getNormalized()</code>.</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb339-1"><a href="#cb339-1" tabindex="-1"></a>my.spct <span class="ot">&lt;-</span> <span class="fu">normalize</span>(sun.spct)</span>
<span id="cb339-2"><a href="#cb339-2" tabindex="-1"></a><span class="fu">is_normalized</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb341"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb341-1"><a href="#cb341-1" tabindex="-1"></a><span class="fu">getNormalized</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Once a spectrum is normalized, summary methods that return values in
absolute units such as <code>irrad()</code>, will trigger an error if
applied. Ratios and similar summaries that are invariant with respect to
normalization can be calculated. Already normalized spectra can be
normalized again.</p>
<p>Applying method <code>fscale()</code> removes the normalization and
clears the corresponding attribute where the normalization information
is stored. This attribute also can be cleared with method
<code>setNormalized()</code>, but this is rarely valid or of any
use.</p>
</div>
<div id="rescaling-a-spectrum" class="section level3">
<h3>Rescaling a spectrum</h3>
<p>While normalization is done with respect to a single wavelength,
rescaling as implemented in this package is more flexible. The scaling
factor is computed as a summary over a range of wavelengths. This allows
us, among other things to rescale spectral irradiance so that irradiance
in a specific waveband is equal to one, or to some other user supplied
target value.</p>
<p><span class="math display">\[Q^\prime(\lambda) =
\frac{Q(\lambda)}{f(Q(\lambda))_{\ \mathrm{for}\ \
\lambda_1\geq\lambda&gt;\lambda_2}}\times \alpha\]</span> where <span class="math inline">\(\alpha\)</span> is the target value for <span class="math inline">\(f(Q(\lambda))\)</span>.</p>
<p>In other words, function <code>fscale()</code> rescales a spectrum by
dividing each spectral data value by a value calculated with a function
(f) selected by a character string (“total” or “mean”), or an actual R
function which can accept the spectrum object supplied as its first
argument. Additional named arguments can be also passed.</p>
<p>How metadata is set in the returned object is controlled by a logical
argument to parameter <code>set.scaled</code>. If <code>TRUE</code>, the
data are labelled as being expressed in relative units and if
<code>FALSE</code> this attribute is not set. The default argument
depends on the value passed as argument to <code>target</code>. If this
value is one, then the data are marked as no longer being expressed in
absolute units. If the <code>target</code> is any other numeric value
then it is assumed that the intention is to re-scale the data and that
absolute physical units remain meaningful. It is important that the
metadata matches the actual use as printing of summaries and plot
labelling depends on them.</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb343-1"><a href="#cb343-1" tabindex="-1"></a><span class="fu">fscale</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Rescaled to &#39;mean of s.e.irrad&#39; = 1 for wavelengths in 280-800 nm
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [scaled] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb345"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb345-1"><a href="#cb345-1" tabindex="-1"></a><span class="fu">fscale</span>(sun.spct, <span class="at">set.scaled =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb347"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb347-1"><a href="#cb347-1" tabindex="-1"></a><span class="fu">fscale</span>(sun.spct, <span class="at">target =</span> <span class="dv">100</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb349"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb349-1"><a href="#cb349-1" tabindex="-1"></a><span class="fu">fscale</span>(sun.spct, <span class="at">target =</span> <span class="dv">100</span>, <span class="at">set.scaled =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Rescaled to &#39;mean of s.e.irrad&#39; = 100 for wavelengths in 280-800 nm
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [scaled] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<p>The default for <code>f</code> can be overridden. R functions passed
as argument should be suitable for summarizing spectral objects as they
will receive as first argument a spectrum rather than a numeric vector.
Behind this requirement is the need to take into account wavelength
steps for integration to be meaningful. In the example below we compute
energy and photon irradiances. (The character arguments
<code>&quot;mean&quot;</code> and <code>&quot;total&quot;</code> call functions specific to
spectral data.)</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb351-1"><a href="#cb351-1" tabindex="-1"></a><span class="fu">fscale</span>(sun.spct, <span class="at">f =</span> <span class="st">&quot;integral&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Rescaled to &#39;integral of s.e.irrad&#39; = 1 for wavelengths in 280-800 nm
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [scaled] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb353"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb353-1"><a href="#cb353-1" tabindex="-1"></a><span class="fu">fscale</span>(sun.spct, <span class="at">range =</span> PAR.wb, <span class="at">f =</span> e_irrad)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Rescaled to &#39;a user supplied R function of s.e.irrad&#39; = 1 for wavelengths in 400-700-none-NULL-NULL-NULL-NULL-c(399.999999999999, 400, 699.999999999999, 700)-PAR-PAR nm
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [scaled] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb355"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb355-1"><a href="#cb355-1" tabindex="-1"></a><span class="fu">fscale</span>(sun.spct, <span class="at">range =</span> PAR.wb, <span class="at">f =</span> q_irrad, <span class="at">target =</span> <span class="fl">800e-6</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<p>In the third example, the spectral data is rescaled so that the
corresponding photosynthetically-active irradiance is equal to one.</p>
<p>The normalization status of a spectral object can be tested with
method <code>is_normalized()</code> and the normalization used can be
recalled with method <code>getNormalized()</code>.</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb357-1"><a href="#cb357-1" tabindex="-1"></a>my.spct <span class="ot">&lt;-</span> <span class="fu">fscale</span>(sun.spct)</span>
<span id="cb357-2"><a href="#cb357-2" tabindex="-1"></a><span class="fu">is_scaled</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb359"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb359-1"><a href="#cb359-1" tabindex="-1"></a><span class="fu">getScaled</span>(my.spct)</span></code></pre></div>
<pre><code>## $multiplier
## [1] 1.932188
## 
## $f
## [1] &quot;mean&quot;
## 
## $range
## [1] 280 800
## 
## $target
## [1] 1
## 
## $cols
## [1] &quot;s.e.irrad&quot;</code></pre>
<p>Once a spectrum is scaled, summary methods that return values in
absolute units such as <code>irrad()</code>, will trigger a warning if
applied. Ratios and similar summaries that are invariant with respect to
normalization do not trigger warnings.</p>
<p>Applying method <code>normalize()</code> removes the scaling and
clears the corresponding attribute where the scaling information is
stored. This attribute also can be cleared with method
<code>setScaled()</code>, and this can be useful is some cases such as
when irradiance has been measured separately from the emission
spectrum.</p>
</div>
<div id="shifting-the-zero-of-the-spectral-data-scale" class="section level3">
<h3>Shifting the zero of the spectral data scale</h3>
<p>While re-scaling relies on a multiplicative factor shifting of the
scale is done by addition (or subtraction) or constant. This allows us,
among other things to remove a baseline computed from a region known to
be equal to zero.</p>
<p><span class="math display">\[Q^\prime(\lambda) = Q(\lambda) -
f(Q(\lambda))_{\ \mathrm{for}\ \
\lambda_1\geq\lambda&gt;\lambda_2}\]</span> Function
<code>fshift()</code> shifts the zero of the scale of a spectrum by
subtracting from each spectral data value a value calculated with a
function (f) selected by a character string (“mean”, “min” or “max”), or
an actual R function which can accept the spectrum object supplied as
its first argument. The range argument selects a region of the spectrum
to be used as <em>reference</em> in the calculation of the summary.</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb361-1"><a href="#cb361-1" tabindex="-1"></a><span class="fu">fshift</span>(white_led.source_spct, <span class="at">range =</span> UVB.wb, <span class="at">f =</span> <span class="st">&quot;mean&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1,421 x 2]
## Wavelength range 251.16-898.81 nm, step 0.43-0.48 nm 
## Label: led_desk201 
## Measured on 2016-12-19 16:19:57.298874 UTC 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,421 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     251.         0
## 2     252.         0
## 3     252.         0
## 4     253.         0
## # ℹ 1,417 more rows</code></pre>
<div class="sourceCode" id="cb363"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb363-1"><a href="#cb363-1" tabindex="-1"></a><span class="fu">fshift</span>(sun.spct, <span class="at">range =</span> <span class="fu">c</span>(<span class="dv">280</span>,<span class="dv">290</span>), <span class="at">f =</span> <span class="st">&quot;min&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 518 more rows</code></pre>
<p>In the first example, the spectral data shifted so that the mean
spectral irradiance becomes zero for the UV-B region. In the second
example the minimum value in the range of wavelengths between 280~nm and
290~nm is used as zero reference for the scale.</p>
</div>
<div id="replacing-off-range-spectral-data-values" class="section level3">
<h3>Replacing off-range spectral data values</h3>
<p>Method <code>clean()</code> should be used with care as off-range
values stem almost always from calibration errors or measuring noise.
This function allows one to replace such values, but in many cases a
zero shift or rescaling could be a better option. Even when the
off-range values are the result of random noise, replacing them with the
boundary values can cause bias, by censoring the data. In such cases
smoothing may be applied first to reduce the possible bias caused by
<code>clean()</code>. Here we create <em>artificial</em> off-range
values by subtracting a constant from each spectrum.</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb365-1"><a href="#cb365-1" tabindex="-1"></a><span class="fu">clean</span>(polyester.spct <span class="sc">-</span> <span class="fl">0.053</span>)</span></code></pre></div>
<pre><code>## Warning: Found 74/561 off-range &#39;Tfr&#39; values [-0.050..0.872] instead of [0..1]</code></pre>
<pre><code>## Object: filter_spct [561 x 2]
## Wavelength range 240-800 nm, step 1 nm 
## Label: Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Rfr (/1): 0.074, thickness (mm): 0.125, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 561 × 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      240     0
## 2      241     0
## 3      242     0
## 4      243     0
## # ℹ 557 more rows</code></pre>
<p>It is possible to restrict the <em>cleaning</em> to a range of
wavelengths and to provide a value to be used as replacement for the
off-range data.</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb368-1"><a href="#cb368-1" tabindex="-1"></a><span class="fu">clean</span>(sun.spct <span class="sc">-</span> <span class="fl">0.01</span>, <span class="at">range =</span> <span class="fu">c</span>(<span class="fl">280.5</span>, <span class="dv">282</span>), <span class="at">fill =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 522 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280      -0.01
## 2     281.     NA   
## 3     282.     NA   
## 4     283.     -0.01
## # ℹ 518 more rows</code></pre>
</div>
<div id="removing-spikes" class="section level3">
<h3>Removing spikes</h3>
<p>Method <code>despike()</code> replaces spikes (very narrow peaks, or
valleys) by values estimated from neighbouring pixels. This method
should be also used carefully and the results inspected as it can remove
features of interest from the data. Usually one knows from theory or
experience if spikes can be real features or not.</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb370-1"><a href="#cb370-1" tabindex="-1"></a><span class="fu">spikes</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [2 x 2]
## Wavelength range 398-432 nm, step 34 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 2 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1      398     0.504
## 2      432     0.646</code></pre>
<div class="sourceCode" id="cb372"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb372-1"><a href="#cb372-1" tabindex="-1"></a>my_sun.spct <span class="ot">&lt;-</span> <span class="fu">despike</span>(sun.spct)</span>
<span id="cb372-2"><a href="#cb372-2" tabindex="-1"></a><span class="fu">spikes</span>(my_sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [0 x 2]
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 0 × 2
## # ℹ 2 variables: w.length &lt;dbl&gt;, s.e.irrad &lt;dbl&gt;</code></pre>
</div>
<div id="smoothing-of-spectra" class="section level3">
<h3>Smoothing of spectra</h3>
<p>We can use smoothing both to average out random variation among
nearby pixels caused by measuring noise, or to filter out the real fine
structure of a spectrum to better assess the larger features. The
methods described here work by averaging the spectral data from
neighbouring wavelengths. The simplest methods are running medians and
running means (or “boxcar smoothing” in the terminology used in some
software). There are several methods for smoothing available in R based
on different algorithms. Some of these methods also automatically set
the degree of smoothing based on the data being smoothed. Package
‘photobiology’ defines function <code>smooth_spct</code>, which at the
moment supports three different methods. Two are wrappers on R’s own
methods and a third one, <code>&quot;custom&quot;</code>, is designed to use
stronger smoothing for values close to zero, where noise in spectral
irradiance measurements is proportionally more. The strength of the
smoothing and the range of wavelengths operated upon can be adjusted
through arguments to parameters. The <code>comment</code> attribute is
updated.</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb374-1"><a href="#cb374-1" tabindex="-1"></a><span class="fu">smooth_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<div class="sourceCode" id="cb376"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb376-1"><a href="#cb376-1" tabindex="-1"></a><span class="fu">smooth_spct</span>(polyester.spct, <span class="at">method =</span> <span class="st">&quot;supsmu&quot;</span>, <span class="at">strength =</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## Object: filter_spct [561 x 2]
## Wavelength range 240-800 nm, step 1 nm 
## Label: Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Rfr (/1): 0.074, thickness (mm): 0.125, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 561 × 2
##   w.length     Tfr
##      &lt;int&gt;   &lt;dbl&gt;
## 1      240 0.00460
## 2      241 0.00453
## 3      242 0.00445
## 4      243 0.00438
## # ℹ 557 more rows</code></pre>
</div>
<div id="wavelength-interpolation" class="section level3">
<h3>Wavelength interpolation</h3>
<p>Converting spectra available at a given set of wavelengths values to
a different one, is frequently needed when operating with several
spectra of different origin. One can increase the <em>apparent</em>
resolution by interpolation, and reduce it by local averaging or
smoothing and resampling. The same function works on all
<code>spct</code> objects, interpolating every numeric column except
<code>w.length</code> which is set to the new wavelength values supplied
as argument. The optional argument <code>fill.value</code> controls what
value is assigned to the “interpolated” data columns at wavelengths in
the new data that are outside the range of wavelengths in the original
spectrum being interpolated.</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb378-1"><a href="#cb378-1" tabindex="-1"></a><span class="fu">interpolate_wl</span>(sun.spct, <span class="fu">seq</span>(<span class="dv">400</span>, <span class="dv">500</span>, <span class="at">by =</span> <span class="fl">0.1</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [1,001 x 3]
## Wavelength range 400-500 nm, step 0.1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 1,001 × 3
##   w.length s.e.irrad  s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1     400      0.608 0.00000203
## 2     400.     0.610 0.00000204
## 3     400.     0.612 0.00000205
## 4     400.     0.614 0.00000205
## # ℹ 997 more rows</code></pre>
</div>
<div id="trimming-clipping-and-thining" class="section level3">
<h3>Trimming, clipping and thining</h3>
<div id="method-clip_wl" class="section level4">
<h4>Method <code>clip_wl()</code></h4>
<p>Sometimes it is desirable to change the range of wavelengths included
in a spectrum. If we are interested in a given part of the spectrum,
there is no need to do calculations or plotting the whole spectrum. To
select part of a spectrum based on a range of wavelengths we may use the
<code>clip_wl()</code> method. Method <code>clip_wl()</code> simply
selects a range from the existing spectrum, and unless the range exactly
matches the wavelength values present in the spectrum, the range of
wavelengths in the returned clipped spectrum will be slightly narrower
than the requested by <code>range</code>.</p>
<p>The range of wavelengths expressed in nanometres can be given as
numeric vector of length two.</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb380-1"><a href="#cb380-1" tabindex="-1"></a><span class="fu">clip_wl</span>(sun.spct, <span class="at">range =</span> <span class="fu">c</span>(<span class="dv">400</span>, <span class="dv">402</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [3 x 3]
## Wavelength range 400-402 nm, step 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 3 × 3
##   w.length s.e.irrad  s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1      400     0.608 0.00000203
## 2      401     0.626 0.00000210
## 3      402     0.650 0.00000218</code></pre>
<div class="sourceCode" id="cb382"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb382-1"><a href="#cb382-1" tabindex="-1"></a><span class="fu">clip_wl</span>(sun.spct, <span class="at">range =</span> <span class="fu">c</span>(<span class="dv">400</span>, <span class="cn">NA</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [401 x 3]
## Wavelength range 400-800 nm, step 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 401 × 3
##   w.length s.e.irrad  s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1      400     0.608 0.00000203
## 2      401     0.626 0.00000210
## 3      402     0.650 0.00000218
## 4      403     0.621 0.00000209
## # ℹ 397 more rows</code></pre>
<p>As for other methods in the package, the range can be also supplied
as a <code>waveband</code> object, or any other object for which
<code>range()</code> returns a numeric range. Even a different spectrum
object is acceptable, and in many cases useful.</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb384-1"><a href="#cb384-1" tabindex="-1"></a><span class="fu">clip_wl</span>(sun.spct, <span class="at">range =</span> UVA.wb)</span></code></pre></div>
<pre><code>## Object: source_spct [86 x 3]
## Wavelength range 315-400 nm, step 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 86 × 3
##   w.length s.e.irrad   s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1      315     0.113 0.000000297
## 2      316     0.102 0.000000270
## 3      317     0.149 0.000000394
## 4      318     0.141 0.000000376
## # ℹ 82 more rows</code></pre>
<p>The result can be a spectrum of length zero.</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb386-1"><a href="#cb386-1" tabindex="-1"></a><span class="fu">clip_wl</span>(sun.spct, <span class="at">range =</span> <span class="fu">c</span>(<span class="dv">100</span>, <span class="dv">200</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [0 x 3]
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 0 × 3
## # ℹ 3 variables: w.length &lt;dbl&gt;, s.e.irrad &lt;dbl&gt;, s.q.irrad &lt;dbl&gt;</code></pre>
</div>
<div id="method-trim_wl" class="section level4">
<h4>Method <code>trim_wl()</code></h4>
<p>Sometimes, we need more flexibility. We may want to replace the
observed values outside a certain range or expand the range of
wavelengths, filling the expansion of all other variables with a certain
value (i.e. a number, or NA.). In contrast to <em>clipping</em> (or
functionally equivalent, indexing, or subsetting), <em>trimming</em>
ensures that there will be spectral data returned at the boundaries of
the trimmed region. These values are obtained by interpolation when they
are not already present in the data.</p>
<p>More flexibility is available in method <code>trim_wl()</code>, to
which we can supply arguments <code>range</code>,
<code>use.hinges</code>, and <code>fill</code>. By default interpolation
is used at the boundaries of the <code>range</code>, in which case the
range of wavelengths in the returned spectrum is that passed as argument
to <code>range</code>.</p>
<div class="sourceCode" id="cb388"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb388-1"><a href="#cb388-1" tabindex="-1"></a><span class="fu">trim_wl</span>(sun.spct, <span class="fu">c</span>(<span class="fl">282.5</span>, <span class="cn">NA</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [520 x 3]
## Wavelength range 282.5-800 nm, step 0.2692308-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 520 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     282.         0         0
## 2     283.         0         0
## 3     284.         0         0
## 4     285.         0         0
## # ℹ 516 more rows</code></pre>
<div class="sourceCode" id="cb390"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb390-1"><a href="#cb390-1" tabindex="-1"></a><span class="fu">clip_wl</span>(sun.spct, <span class="fu">c</span>(<span class="fl">282.5</span>, <span class="cn">NA</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [519 x 3]
## Wavelength range 282.76923-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 519 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     283.         0         0
## 2     284.         0         0
## 3     285.         0         0
## 4     286.         0         0
## # ℹ 515 more rows</code></pre>
<p>As for <code>clip_wl()</code> the range can be also supplied as a
<code>waveband</code> object, or any other object for which
<code>range()</code> returns a numeric range. Even a different spectrum
object is acceptable.</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb392-1"><a href="#cb392-1" tabindex="-1"></a><span class="fu">trim_wl</span>(sun.spct, PAR.wb)</span></code></pre></div>
<pre><code>## Object: source_spct [301 x 3]
## Wavelength range 400-700 nm, step 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 301 × 3
##   w.length s.e.irrad  s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1      400     0.608 0.00000203
## 2      401     0.626 0.00000210
## 3      402     0.650 0.00000218
## 4      403     0.621 0.00000209
## # ℹ 297 more rows</code></pre>
<p>The default for <code>fill</code> is <code>NULL</code> which results
in deletion values outside the trimmed region. However, it is possible
to supply a different argument, to be used to replace the off-range data
values.</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb394-1"><a href="#cb394-1" tabindex="-1"></a><span class="fu">trim_wl</span>(sun.spct, <span class="fu">c</span>(<span class="fl">281.5</span>, <span class="cn">NA</span>), <span class="at">fill =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 3]
## Wavelength range 280-800 nm, step 1.023182e-12-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 524 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280         NA        NA
## 2     281.        NA        NA
## 3     281.        NA        NA
## 4     282.         0         0
## # ℹ 520 more rows</code></pre>
<p>Furthermore, when fill is not <code>NULL</code>, expansion is
possible.</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb396-1"><a href="#cb396-1" tabindex="-1"></a><span class="fu">trim_wl</span>(sun.spct, <span class="fu">c</span>(<span class="dv">275</span>, <span class="cn">NA</span>), <span class="at">fill =</span> <span class="dv">0</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [529 x 3]
## Wavelength range 275-800 nm, step 1.023182e-12-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 529 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     275          0         0
## 2     276.         0         0
## 3     277.         0         0
## 4     277.         0         0
## # ℹ 525 more rows</code></pre>
<p>By default interpolation at the boundaries is used, but setting
<code>use.hinges</code> to <code>FALSE</code> results in clipping, a
behaviour similar to that of <code>clip_wl</code> only if
<code>fill == NULL</code>.</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb398-1"><a href="#cb398-1" tabindex="-1"></a><span class="fu">trim_wl</span>(sun.spct, <span class="fu">c</span>(<span class="fl">281.5</span>, <span class="cn">NA</span>), <span class="at">fill =</span> <span class="cn">NA</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 3]
## Wavelength range 280-800 nm, step 1.023182e-12-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 524 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280         NA        NA
## 2     281.        NA        NA
## 3     281.        NA        NA
## 4     282.         0         0
## # ℹ 520 more rows</code></pre>
<div class="sourceCode" id="cb400"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb400-1"><a href="#cb400-1" tabindex="-1"></a><span class="fu">trim_wl</span>(sun.spct, <span class="fu">c</span>(<span class="fl">281.5</span>, <span class="cn">NA</span>), <span class="at">fill =</span> <span class="cn">NA</span>, <span class="at">use.hinges =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280-800 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 522 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280         NA        NA
## 2     281.        NA        NA
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 518 more rows</code></pre>
<p>When <code>use.hinges == TRUE</code> and expansion or replacement is
done, two observations are inserted at each boundary, differing in
wavelength by <span class="math inline">\(1 \times 10^{-12}\)</span>,nm
to prevent rounding errors in later calculations.</p>
</div>
<div id="functions-trim2ovelap-and-extend2extremes" class="section level4">
<h4>Functions <code>trim2ovelap()</code> and
<code>extend2extremes()</code></h4>
<p>Functions <code>trim2ovelap()</code> and
<code>extend2extremes()</code> are defined only for collections of
spectra. They are convenience functions, as they handle special use
cases of <code>trim_wl()</code> with a simplified syntax. They can be
used to make the wavelength range of the different members of a
collection of spectra consistent, either by trimming all spectra to the
range of overlapping wavelengths, or by extending the wavelength ranges
as needed and filling the added spectral values with a constant
value.</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb402-1"><a href="#cb402-1" tabindex="-1"></a><span class="fu">trim2overlap</span>(two.mspct)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2015-10-31 08:00:00 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## --- Member: time.02 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2015-10-31 09:00:00 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## 
## --- END ---</code></pre>
<div class="sourceCode" id="cb404"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb404-1"><a href="#cb404-1" tabindex="-1"></a><span class="fu">extend2extremes</span>(two.mspct, <span class="at">fill =</span> <span class="dv">0</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: time.01 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2015-10-31 08:00:00 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## --- Member: time.02 ---
## Object: source_spct [1,593 x 2]
## Wavelength range 290-1000 nm, step 0.34-0.47 nm 
## Label: cosine.hour.9 
## Measured on 2015-10-31 09:00:00 UTC 
## Measured at 60.227 N, 24.018 E; Viikki, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1,593 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     290          0
## 2     290.         0
## 3     291.         0
## 4     291.         0
## # ℹ 1,589 more rows
## 
## --- END ---</code></pre>
</div>
<div id="method-thin_wl" class="section level4">
<h4>Method <code>thin_wl()</code></h4>
<p>One possible way of decreasing the storage space occupied by spectral
data is to vary the density of wavelength values stored based on the
local change in slope (second derivative) of the plot a spectrum. Method
<code>thin_wl()</code> can be used to remove or “thin” down the
wavelength values stored in those regions of the spectrum where this
would result in minimal loss of information. The algorithm currently in
use is suboptimal in the removal of wavelength values but fast and easy
to implement. <strong>Which wavelength values are retained or not could
change with future implementations.</strong></p>
<div class="sourceCode" id="cb406"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb406-1"><a href="#cb406-1" tabindex="-1"></a><span class="fu">nrow</span>(yellow_gel.spct)</span></code></pre></div>
<pre><code>## [1] 611</code></pre>
<div class="sourceCode" id="cb408"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb408-1"><a href="#cb408-1" tabindex="-1"></a><span class="fu">wl_stepsize</span>(yellow_gel.spct)</span></code></pre></div>
<pre><code>## [1] 1 1</code></pre>
<div class="sourceCode" id="cb410"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb410-1"><a href="#cb410-1" tabindex="-1"></a>thinned.spct <span class="ot">&lt;-</span> <span class="fu">thin_wl</span>(yellow_gel.spct)</span>
<span id="cb410-2"><a href="#cb410-2" tabindex="-1"></a><span class="fu">nrow</span>(thinned.spct)</span></code></pre></div>
<pre><code>## [1] 267</code></pre>
<div class="sourceCode" id="cb412"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb412-1"><a href="#cb412-1" tabindex="-1"></a><span class="fu">wl_stepsize</span>(thinned.spct)</span></code></pre></div>
<pre><code>## [1] 1 8</code></pre>
<p>The strength of the thinning can be adjusted by passing arguments to
parameters <code>max.wl.step</code> and <code>max.slope.delta</code>.
This method is implemented for objects of all spectral classes that a
single default data column in addition to wavelengths and also for
collections of those objects.</p>
<p><strong>NOTE:</strong> Thinning, obviously, almost always changes
spectra originally expressed at the same set of wavelength values into
spectra expressed at two different sets of wavelengths values. This
forbid some operations among them, like <em>parallel</em> operations in
collections of spectra or combining them into a wide data frame. Most of
these restrictions have been removed by implementing on-the-fly
interpolation in version 0.10.15.</p>
</div>
</div>
<div id="convolving-weights" class="section level3">
<h3>Convolving weights</h3>
<p>It is very instructive to look at weighted spectral data to
understand how effective irradiances are calculated. Plotting effective
spectral irradiance data can be very informative when analysing
interactions among photoreceptors and ambient radiation. It can also
illustrate the large effect that small measuring errors can have on the
estimated effective irradiances or exposures when SWFs have a steep
slope.</p>
<p>For biologically effective energy irradiance <span class="math inline">\(E_\mathrm{BE}\)</span> the following equation
describes the convolution, wavelength by wavelength, between spectral
energy irradiance and a biological spectral weighting function</p>
<p><span class="math display">\[E_\mathrm{BE}(\lambda) = E(\lambda)
\times w_E(\lambda)\]</span> or for biologically effective photon
irradiance <span class="math inline">\(Q_\mathrm{BE}\)</span> <span class="math display">\[Q_\mathrm{BE}(\lambda) = Q(\lambda) \times
w_Q(\lambda)\]</span> For the convolution to be possible, both spectral
irradiance and spectral weights should be available for the same basis
of expression and at the same discrete wavelength values.</p>
<div id="individual-spectra" class="section level4">
<h4>Individual spectra</h4>
<p>The multiplication operator is defined for operations between a
<code>source_spct</code> and a <code>waveband</code>, so this is the
easiest way of doing the calculations.</p>
<div class="sourceCode" id="cb414"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb414-1"><a href="#cb414-1" tabindex="-1"></a>sun.spct <span class="sc">*</span> CIE.wb</span></code></pre></div>
<pre><code>## Object: source_spct [122 x 2]
## Wavelength range 280-400 nm, step 0.9230769-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Data weighted using &#39;range.250.400.wtd&#39; BSWF
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 122 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ℹ 118 more rows</code></pre>
</div>
</div>
<div id="tagging-with-bands-and-colours" class="section level3">
<h3>Tagging with bands and colours</h3>
<p>We call tagging, to the process of adding reference information to
spectral data. For example we can add a factor indicating regions or
bands in the spectrum. We can add also information on the colour, as
seen by humans, for each observed value, or for individual regions or
bands of the spectrum. In most cases this additional information is used
for annotations when plotting the spectral data.</p>
<div id="individual-spectra-1" class="section level4">
<h4>Individual spectra</h4>
<p>The function <code>tag</code> can be used to tag different parts of a
spectrum according to wavebands.</p>
<div class="sourceCode" id="cb416"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb416-1"><a href="#cb416-1" tabindex="-1"></a><span class="fu">tag</span>(sun.spct, PAR.wb)</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 6]
## Wavelength range 280-800 nm, step 1.023182e-12-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 524 × 6
##   w.length s.e.irrad s.q.irrad wl.color wb.color wb.f 
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;fct&gt;
## 1     280          0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 2     281.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 3     282.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 4     283.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## # ℹ 520 more rows</code></pre>
<div class="sourceCode" id="cb418"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb418-1"><a href="#cb418-1" tabindex="-1"></a><span class="fu">tag</span>(sun.spct, UV_bands.lst)</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 6]
## Wavelength range 280-800 nm, step 1.023182e-12-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 524 × 6
##   w.length s.e.irrad s.q.irrad wl.color wb.color wb.f 
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;fct&gt;
## 1     280          0         0 #000000  black    UVB  
## 2     281.         0         0 #000000  black    UVB  
## 3     282.         0         0 #000000  black    UVB  
## 4     283.         0         0 #000000  black    UVB  
## # ℹ 520 more rows</code></pre>
<p>The added factor and colour data can be used for further processing
or for plotting. Information about the tagging and wavebands is stored
in an attribute <code>tag.attr</code> in every tagged spectrum, this
yields a more compact output and keeps a <em>trace</em> of the
tagging.</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb420-1"><a href="#cb420-1" tabindex="-1"></a>tg.sun.spct <span class="ot">&lt;-</span> <span class="fu">tag</span>(sun.spct, PAR.wb)</span>
<span id="cb420-2"><a href="#cb420-2" tabindex="-1"></a><span class="fu">attr</span>(tg.sun.spct, <span class="st">&quot;spct.tags&quot;</span>)</span></code></pre></div>
<pre><code>## $valid
## [1] TRUE
## 
## $time.unit
## [1] &quot;second&quot;
## 
## $wb.key.name
## [1] &quot;Bands&quot;
## 
## $wl.color
## [1] TRUE
## 
## $wb.color
## [1] TRUE
## 
## $wb.num
## [1] 1
## 
## $wb.colors
## [1] &quot;#735B57&quot;
## 
## $wb.names
## [1] &quot;PAR&quot;
## 
## $wb.list
## $wb.list[[1]]
## PAR 
## low (nm) 400 
## high (nm) 700 
## weighted none</code></pre>
<p>Additional functions are available which return a tagged spectrum and
take as input a list of wavebands, but no spectral data. They
<em>build</em> a spectrum from the data in the wavebands, and are useful
for plotting the boundaries of wavebands.</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb422-1"><a href="#cb422-1" tabindex="-1"></a><span class="fu">wb2tagged_spct</span>(UV_bands.lst)</span></code></pre></div>
<pre><code>## Object: generic_spct [8 x 12]
## Wavelength range 100-400 nm, step 9.947598e-13-180 nm 
## Variables:
##   
## --
## # A tibble: 8 × 12
##   w.length counts   cps s.e.irrad s.q.irrad   Tfr   Rfl s.e.response wl.color
##      &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;   
## 1     100.      0     0         0         0     0     0            0 #000000 
## 2     100       0     0         0         0     0     0            0 #000000 
## 3     280.      0     0         0         0     0     0            0 #000000 
## 4     280       0     0         0         0     0     0            0 #000000 
## # ℹ 4 more rows
## # ℹ 3 more variables: wb.color &lt;chr&gt;, wb.f &lt;fct&gt;, y &lt;dbl&gt;</code></pre>
<div class="sourceCode" id="cb424"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb424-1"><a href="#cb424-1" tabindex="-1"></a><span class="fu">wb2rect_spct</span>(UV_bands.lst)</span></code></pre></div>
<pre><code>## Object: generic_spct [3 x 15]
## Wavelength range 190-357.5 nm, step 60-107.5 nm 
## Variables:
##   
## --
## # A tibble: 3 × 15
##   w.length counts   cps s.e.irrad s.q.irrad   Tfr   Rfl s.e.response wl.color
##      &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;   
## 1     190       0     0         0         0     0     0            0 #000000 
## 2     298.      0     0         0         0     0     0            0 #000000 
## 3     358.      0     0         0         0     0     0            0 #000000 
## # ℹ 6 more variables: wb.color &lt;chr&gt;, wb.name &lt;chr&gt;, wb.f &lt;fct&gt;, wl.high &lt;dbl&gt;,
## #   wl.low &lt;dbl&gt;, y &lt;dbl&gt;</code></pre>
<p>Function <code>wb2tagged_spct</code> returns a tagged spectrum, with
two rows for each waveband, corresponding to the low and high wavelength
boundaries, while function <code>wb2rect_spct</code> returns a spectrum
with only one row per waveband, with <code>w.length</code> set to its
midpoint but with additional columns <code>xmin</code> and
<code>xmax</code> corresponding to the low and high wavelength
boundaries of the wavebands.</p>
<p>Function <code>is_tagged</code> can be used to query if an spectrum
is tagged or not, and function <code>untag</code> removes the tags.</p>
<div class="sourceCode" id="cb426"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb426-1"><a href="#cb426-1" tabindex="-1"></a>tg.sun.spct</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 6]
## Wavelength range 280-800 nm, step 1.023182e-12-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 524 × 6
##   w.length s.e.irrad s.q.irrad wl.color wb.color wb.f 
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;fct&gt;
## 1     280          0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 2     281.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 3     282.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 4     283.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## # ℹ 520 more rows</code></pre>
<div class="sourceCode" id="cb428"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb428-1"><a href="#cb428-1" tabindex="-1"></a><span class="fu">is_tagged</span>(tg.sun.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb430"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb430-1"><a href="#cb430-1" tabindex="-1"></a>untg.sun.spct <span class="ot">&lt;-</span> <span class="fu">untag</span>(tg.sun.spct)</span>
<span id="cb430-2"><a href="#cb430-2" tabindex="-1"></a><span class="fu">is_tagged</span>(untg.sun.spct)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>In the chuck above, we can see how this works, using in this case the
default <code>byref = FALSE</code> which adds the tags to a copy of the
spectrum object. In contrast, setting <code>byref = TRUE</code> adds the
tags in place, or “by reference”“, to the spct object supplied as
argument. Passing arguments by reference is unusual for R and is best
avoided.</p>
<div class="sourceCode" id="cb432"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb432-1"><a href="#cb432-1" tabindex="-1"></a><span class="fu">is_tagged</span>(untg.sun.spct)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb434"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb434-1"><a href="#cb434-1" tabindex="-1"></a><span class="fu">untag</span>(tg.sun.spct, <span class="at">byref =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 3]
## Wavelength range 280-800 nm, step 1.023182e-12-1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 524 × 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ℹ 520 more rows</code></pre>
<div class="sourceCode" id="cb436"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb436-1"><a href="#cb436-1" tabindex="-1"></a><span class="fu">is_tagged</span>(untg.sun.spct)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
</div>
</div>
</div>
<div id="summaries" class="section level2">
<h2>Summaries</h2>
<p>Summaries can be calculated both from individual spectral objects
(Table 10) and from collections of spectral objects (Table 11). They
return a <em>simpler</em> object than the spectral data in their
arguments. For example a vector of numeric values, possibly of length
one, in the case of individual spectra, or a data frame containing one
row of summary data for each spectrum in a collection of spectra.</p>
<hr />
<p><strong>Table 10. Summary methods for spectra.</strong> Key: +
available, - not available, (+) object_spct objects can be converted
into filter_spct or reflector_spct objects before applying these
methods.</p>
<table style="width:100%;">
<colgroup>
<col width="20%" />
<col width="11%" />
<col width="10%" />
<col width="12%" />
<col width="10%" />
<col width="14%" />
<col width="10%" />
<col width="10%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">methods</th>
<th align="center">raw/cps</th>
<th align="center">source</th>
<th align="center">response</th>
<th align="center">filter</th>
<th align="center">reflector</th>
<th align="center">object</th>
<th align="center">chroma</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">irrad</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">e_irrad</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">q_irrad</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">fluence</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">e_fluence</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">q_fluence</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">ratio</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">e_ratio</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">q_ratio</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">qe_ratio</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">eq_ratio</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">e_response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">q_response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">transmittance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">absorptance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">absorbance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">reflectance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">wl_range</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">wl_min</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">wl_max</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">wl_stepsize</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">wl_expanse</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">wl_midpoint</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">labels</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">summary</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">peaks</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="left">spikes</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="odd">
<td align="left">valleys</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="left">wls_at_target</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="odd">
<td align="left">integrate_spct</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">average_spct</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">color_of</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
</tbody>
</table>
<hr />
<p>As mentioned above, summary methods for collections of spectra return
data frame objects. In many cases preserving the attributes from the
different members of the collection in the returned value is important,
and can be achieved easily by passing a suitable character vector as
argument to parameter <code>attr2tb</code>, using the same syntax as
described for function <code>add_attr2tb</code>.</p>
<hr />
<p><strong>Table 11. Summary methods for collections of
spectra.</strong> Key: + available, * <code>attr2tb</code> supported, –
not available, <strong>ms</strong> use <code>msmsply()</code> to apply
function to collection members, <strong>d</strong> use
<code>msdply()</code>, <strong>l</strong> use <code>mslply</code> to
apply function to collection members, <strong>a</strong> use
<code>msaply</code> to apply function to collection members.</p>
<table>
<colgroup>
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">methods</th>
<th align="center">raw/cps</th>
<th align="center">source</th>
<th align="center">response</th>
<th align="center">filter</th>
<th align="center">reflector</th>
<th align="center">object</th>
<th align="center">chroma</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">irrad</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">e_irrad</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">q_irrad</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">fluence</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">e_fluence</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">q_fluence</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">ratio</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">e_ratio</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">q_ratio</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">qe_ratio</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">eq_ratio</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">e_response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">q_response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">transmittance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">absorptance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">absorbance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">reflectance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">color_of</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">wl_range</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">wl_min</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">wl_max</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">wl_stepsize</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">wl_spread</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">wl_midpoint</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">labels</td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
</tr>
<tr class="odd">
<td align="left">summary</td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
</tr>
<tr class="even">
<td align="left">peaks</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="odd">
<td align="left">valleys</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="left">spikes</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="odd">
<td align="left">wls_at_target</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="left">integrate_spct</td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
</tr>
<tr class="odd">
<td align="left">average_spct</td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
</tr>
</tbody>
</table>
<hr />
<div id="summary-1" class="section level3">
<h3>Summary</h3>
<p>Specialized definitions of <code>summary</code> and the corresponding
<code>print</code> methods are available for spectral objects.
Attributes <code>&quot;what.measured&quot;</code>, <code>&quot;when.measured&quot;</code>
and <code>&quot;where.measured&quot;</code> are included in the summary print out
only if set in the spectral object summarized.</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb438-1"><a href="#cb438-1" tabindex="-1"></a><span class="fu">summary</span>(sun.spct)</span></code></pre></div>
<pre><code>## Summary of source_spct [522 x 3] object: sun.spct
## Wavelength range 280-800 nm, step 0.9230769-1 nm
## Label:  sunlight, simulated 
## Measured on  2010-06-22 09:51:00  UTC
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
##     w.length       s.e.irrad        s.q.irrad        
##  Min.   :280.0   Min.   :0.0000   Min.   :0.000e+00  
##  1st Qu.:409.2   1st Qu.:0.4115   1st Qu.:1.980e-06  
##  Median :539.5   Median :0.5799   Median :2.929e-06  
##  Mean   :539.5   Mean   :0.5160   Mean   :2.407e-06  
##  3rd Qu.:669.8   3rd Qu.:0.6664   3rd Qu.:3.155e-06  
##  Max.   :800.0   Max.   :0.8205   Max.   :3.375e-06</code></pre>
<p>In the case of collections of spectra, by default a conscise summary
is printed.</p>
<div class="sourceCode" id="cb440"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb440-1"><a href="#cb440-1" tabindex="-1"></a><span class="fu">summary</span>(two_filters.mspct)</span></code></pre></div>
<pre><code>## Summary of filter_mspct [2 x 1] object: two_filters.mspct
## # A tibble: 2 × 8
##   spct.idx class   dim   w.length.min w.length.max colnames multiple.wl Tfr.type
##   &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;        &lt;int&gt;        &lt;int&gt; &lt;list&gt;         &lt;dbl&gt; &lt;chr&gt;   
## 1 spct_1   filter… [561…          240          800 &lt;chr&gt;              1 total   
## 2 spct_2   filter… [611…          190          800 &lt;chr&gt;              1 total</code></pre>
<p>However, the spectra can be also summarized individually.</p>
<div class="sourceCode" id="cb442"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb442-1"><a href="#cb442-1" tabindex="-1"></a><span class="fu">summary</span>(two_filters.mspct, <span class="at">expand =</span> <span class="st">&quot;each&quot;</span>)</span></code></pre></div>
<pre><code>## $spct_1
## Summary of filter_spct [561 x 2] object: anonymous
## Wavelength range 240-800 nm, step 1 nm
## Label:  Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
##     w.length        Tfr        
##  Min.   :240   Min.   :0.0030  
##  1st Qu.:380   1st Qu.:0.8971  
##  Median :520   Median :0.9141  
##  Mean   :520   Mean   :0.7747  
##  3rd Qu.:660   3rd Qu.:0.9211  
##  Max.   :800   Max.   :0.9254  
## 
## $spct_2
## Summary of filter_spct [611 x 2] object: anonymous
## Wavelength range 190-800 nm, step 1 nm
## Label:  Theatrical &#39;gel&#39;, type &#39;Canary Supergel no312; new; from Rosco, UK 
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
##     w.length          Tfr         
##  Min.   :190.0   Min.   :0.00001  
##  1st Qu.:342.5   1st Qu.:0.00001  
##  Median :495.0   Median :0.18800  
##  Mean   :495.0   Mean   :0.42606  
##  3rd Qu.:647.5   3rd Qu.:0.89771  
##  Max.   :800.0   Max.   :0.90179</code></pre>
<p>In the case of multiple spectra in long form, by default a single
summary is printed.</p>
<div class="sourceCode" id="cb444"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb444-1"><a href="#cb444-1" tabindex="-1"></a><span class="fu">summary</span>(two_filters.spct)</span></code></pre></div>
<pre><code>## Summary of filter_spct [1,172 x 3] object: two_filters.spct
## containing  2  spectra in long form
## Wavelength range 240-800 nm, step -610-1 nm
## Label:  Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
##     w.length          Tfr            spct.idx  
##  Min.   :190.0   Min.   :0.00001   spct_1:561  
##  1st Qu.:361.0   1st Qu.:0.00400   spct_2:611  
##  Median :507.5   Median :0.89736               
##  Mean   :507.0   Mean   :0.59292               
##  3rd Qu.:654.0   3rd Qu.:0.91361               
##  Max.   :800.0   Max.   :0.92543</code></pre>
<p>Passing <code>expand = &quot;collection&quot;</code> we obtain the same
condensed summary as shown above as the default for collections of
spectra. (Output not shown here.)</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb446-1"><a href="#cb446-1" tabindex="-1"></a><span class="fu">summary</span>(two_filters.spct, <span class="at">expand =</span> <span class="st">&quot;collection&quot;</span>)</span></code></pre></div>
<p>Passing <code>expand = &quot;each&quot;</code> we obtain the same expanded
summary as shown above for <code>expand = &quot;each&quot;</code> for collections
of spectra. (Output not shown here.)</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb447-1"><a href="#cb447-1" tabindex="-1"></a><span class="fu">summary</span>(two_filters.spct, <span class="at">expand =</span> <span class="st">&quot;each&quot;</span>)</span></code></pre></div>
</div>
<div id="wavelength" class="section level3">
<h3>Wavelength</h3>
<div id="individual-spectra-2" class="section level4">
<h4>Individual spectra</h4>
<p>The <em>usual</em> and three new summary methods are available for
spectra, but redefined to return <em>wavelength</em>-based summaries in
nanometres (nm) directly from spectra. For clarity, synonyms with names
starting with <code>wl_</code> are provided. The three new generic
methods <code>midpoint()</code>, <code>expanse()</code> and
<code>stepsize()</code> are also defined for <code>numeric</code>.</p>
<div class="sourceCode" id="cb448"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb448-1"><a href="#cb448-1" tabindex="-1"></a><span class="fu">wl_range</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 280 800</code></pre>
<div class="sourceCode" id="cb450"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb450-1"><a href="#cb450-1" tabindex="-1"></a><span class="fu">wl_min</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 280</code></pre>
<div class="sourceCode" id="cb452"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb452-1"><a href="#cb452-1" tabindex="-1"></a><span class="fu">wl_max</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 800</code></pre>
<div class="sourceCode" id="cb454"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb454-1"><a href="#cb454-1" tabindex="-1"></a><span class="fu">wl_midpoint</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 540</code></pre>
<div class="sourceCode" id="cb456"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb456-1"><a href="#cb456-1" tabindex="-1"></a><span class="fu">wl_expanse</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 520</code></pre>
<div class="sourceCode" id="cb458"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb458-1"><a href="#cb458-1" tabindex="-1"></a><span class="fu">wl_stepsize</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 0.9230769 1.0000000</code></pre>
</div>
<div id="collections-of-spectra-1" class="section level4">
<h4>Collections of spectra</h4>
<hr />
<p>Most frequently used summary methods are implemented for collections
of spectra. See the Table 11 for those methods that need to be applied
with functions <code>msaply</code>, <code>msdply</code> or
<code>mslply</code> to members in a collection returning the results in
an array (vector, or matrix), a data frame or a list object. In many
cases depending of the class desired for the result, one can chose a
suitable <em>apply</em> function, and sometimes it is best to use such a
function, even when the corresponding method is implemented for
collections of spectra.</p>
<hr />
<p>Collections of spectra can be useful not only for time-series of
spectra or spectral images, but also when dealing with a small group of
related spectra. In the example below we show how to use a collection of
spectra for calculating summaries. The spectra in a collection do
<strong>not</strong> need to have been measured at the same wavelength
values, or have the same number of rows or even of columns.
Consequently, in many cases applying the wavelength summary functions
described above to collections of spectra can be useful. The value
returned is a data frame, with a number of data columns equal to the
length of the returned value by the corresponding method for individual
spectra.</p>
<div class="sourceCode" id="cb460"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb460-1"><a href="#cb460-1" tabindex="-1"></a>filters.mspct <span class="ot">&lt;-</span> <span class="fu">filter_mspct</span>(<span class="fu">list</span>(<span class="at">none =</span> clear.spct,</span>
<span id="cb460-2"><a href="#cb460-2" tabindex="-1"></a>                                   <span class="at">pet =</span> polyester.spct,</span>
<span id="cb460-3"><a href="#cb460-3" tabindex="-1"></a>                                   <span class="at">yellow =</span> yellow_gel.spct))</span>
<span id="cb460-4"><a href="#cb460-4" tabindex="-1"></a><span class="fu">wl_range</span>(filters.mspct)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   spct.idx min.wl max.wl
##   &lt;fct&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1 none        100   5000
## 2 pet         240    800
## 3 yellow      190    800</code></pre>
</div>
</div>
<div id="peaks-valleys-and-spikes" class="section level3">
<h3>Peaks, valleys and spikes</h3>
<p>Peaks and valleys in spectra are usually features of interest, while
in most cases spikes (very narrow peaks or valleys) are undesired
“noise”. Of course, there are exceptions and for this reason methods
used for extract any of these features have a similar interface.</p>
<p>Peaks and valleys can be identified simply as local maxima and
minima, or their actual location better estimated by fitted a model to
the local maximum or minimum and its neighbours.</p>
<div id="individual-spectra-3" class="section level4">
<h4>Individual spectra</h4>
<p>Methods <code>peaks</code> and <code>valleys</code> take spectra as
first argument and return a subset of the spectral object data
corresponding to local maxima and local minima of the measured variable.
<code>span</code> defines the width of the <em>window</em> used as a
number of observations.</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb462-1"><a href="#cb462-1" tabindex="-1"></a><span class="fu">peaks</span>(sun.spct, <span class="at">span =</span> <span class="dv">51</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [3 x 2]
## Wavelength range 451-747 nm, step 44-252 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 3 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1      451     0.820
## 2      495     0.790
## 3      747     0.503</code></pre>
<div class="sourceCode" id="cb464"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb464-1"><a href="#cb464-1" tabindex="-1"></a><span class="fu">valleys</span>(sun.spct, <span class="at">span =</span> <span class="dv">51</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [9 x 2]
## Wavelength range 358-761 nm, step 30-72 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 9 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1      358     0.254
## 2      393     0.242
## 3      431     0.414
## 4      487     0.651
## # ℹ 5 more rows</code></pre>
<p>A value of <code>NULL</code> as argument to <code>span</code>
searches for a single maximum for the whole spectrum.</p>
<div class="sourceCode" id="cb466"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb466-1"><a href="#cb466-1" tabindex="-1"></a><span class="fu">peaks</span>(sun.spct, <span class="at">span =</span> <span class="cn">NULL</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1 x 2]
## Wavelength range 451-451 nm, step NA nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1      451     0.820</code></pre>
<p>By passing <code>refine.wl = TRUE</code> we request that location of
the peaks is <em>refined</em> by fitting a model to describe the peak.
<strong>The interpolated <code>w.length</code> estimate can be usually
trusted as good if the data are not noisy, while the
<code>s.e.irrad</code> and <code>s.q.irrad</code> estimates should be
always checked as their values are frequently suspect.</strong></p>
<div class="sourceCode" id="cb468"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb468-1"><a href="#cb468-1" tabindex="-1"></a><span class="fu">peaks</span>(sun.spct, </span>
<span id="cb468-2"><a href="#cb468-2" tabindex="-1"></a>      <span class="at">span =</span> <span class="cn">NULL</span>,</span>
<span id="cb468-3"><a href="#cb468-3" tabindex="-1"></a>      <span class="at">refine.wl =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1 x 2]
## Wavelength range 451.02685-451.02685 nm, step NA nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     451.     0.821</code></pre>
<p>In the case of <code>source_spct</code> and
<code>response_spct</code> methods <code>unit.out</code> can be used to
force peaks to be searched using either energy or photon based spectral
irradiance. The default is energy, or the option
<code>&quot;photobiology.radiation.unit&quot;</code> if set. As expected, the
wavelength at the maximum differs when the data are expressed as a flux
of energy or of photons.</p>
<div class="sourceCode" id="cb470"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb470-1"><a href="#cb470-1" tabindex="-1"></a><span class="fu">peaks</span>(sun.spct, </span>
<span id="cb470-2"><a href="#cb470-2" tabindex="-1"></a>      <span class="at">span =</span> <span class="cn">NULL</span>, </span>
<span id="cb470-3"><a href="#cb470-3" tabindex="-1"></a>      <span class="at">unit.out =</span> <span class="st">&quot;energy&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1 x 2]
## Wavelength range 451-451 nm, step NA nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1      451     0.820</code></pre>
<div class="sourceCode" id="cb472"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb472-1"><a href="#cb472-1" tabindex="-1"></a><span class="fu">peaks</span>(sun.spct, </span>
<span id="cb472-2"><a href="#cb472-2" tabindex="-1"></a>      <span class="at">span =</span> <span class="cn">NULL</span>, </span>
<span id="cb472-3"><a href="#cb472-3" tabindex="-1"></a>      <span class="at">unit.out =</span> <span class="st">&quot;photon&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1 x 2]
## Wavelength range 531-531 nm, step NA nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.q.irrad: Spectral photon irradiance [mol s-1 m-2 nm-1] 
## --
## # A tibble: 1 × 2
##   w.length  s.q.irrad
##      &lt;dbl&gt;      &lt;dbl&gt;
## 1      531 0.00000337</code></pre>
<p>As <code>span</code> is given as a number of successive observations,
if this step varies significantly, the algorithm fails except for the
global maximum. In such a case a warning is issued.</p>
<div class="sourceCode" id="cb474"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb474-1"><a href="#cb474-1" tabindex="-1"></a><span class="fu">peaks</span>(sun.spct, <span class="at">span =</span> <span class="cn">NULL</span>, <span class="at">refine.wl =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1 x 2]
## Wavelength range 451.02685-451.02685 nm, step NA nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 1 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     451.     0.821</code></pre>
<p>Frequently, we are not interested in all local maxima, but instead
only in those that exceed a certain heigh globally or locally (within
the window of width <code>span</code>). Arguments passed to additional
parameters make this possible as described in the help page of
<code>peaks()</code>and <code>valleys()</code> methods.</p>
<p>Method <code>spikes</code> differs from <code>peaks</code> in that it
uses a different algorithm that detects only very narrow peaks, usually
called by the name of spikes. The value returned is as in the case of
<code>peaks</code> a subset of the original spectrum. The parameters
controlling the sensitivity also differ.</p>
<div class="sourceCode" id="cb476"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb476-1"><a href="#cb476-1" tabindex="-1"></a><span class="fu">spikes</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [2 x 2]
## Wavelength range 398-432 nm, step 34 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Variables:
##  w.length: Wavelength [nm]
##  s.e.irrad: Spectral energy irradiance [W m-2 nm-1] 
## --
## # A tibble: 2 × 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1      398     0.504
## 2      432     0.646</code></pre>
<p>Low level functions <code>find_peaks</code>,
<code>find_valleys</code>, <code>fit_peaks</code>,
<code>fit_valleys</code>, and <code>find_spikes</code> take numeric
vectors as first argument.</p>
</div>
<div id="collections-of-spectra-2" class="section level4">
<h4>Collections of spectra</h4>
<p>The methods are also implemented for collections of spectra.</p>
<div class="sourceCode" id="cb478"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb478-1"><a href="#cb478-1" tabindex="-1"></a><span class="fu">msmsply</span>(filters.mspct, peaks, <span class="at">span =</span> <span class="dv">21</span>)</span></code></pre></div>
<pre><code>## &#39;peaks()&#39; assumes consistent w.length steps! max step / min step = 4898</code></pre>
<pre><code>## Object: filter_mspct [3 x 1]
## --- Member: none ---
## Object: filter_spct [0 x 2]
## Label: theoretical fully transparent object 
## Rfr (/1): 0.000, thickness (mm): 1.000e+03, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Internal spectral transmittance [/1] 
## --
## # A tibble: 0 × 2
## # ℹ 2 variables: w.length &lt;dbl&gt;, Tfr &lt;dbl&gt;
## --- Member: pet ---
## Object: filter_spct [38 x 2]
## Wavelength range 267-740 nm, step 1-162 nm 
## Label: Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Rfr (/1): 0.074, thickness (mm): 0.125, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 38 × 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      267 0.004
## 2      268 0.004
## 3      269 0.004
## 4      270 0.004
## # ℹ 34 more rows
## --- Member: yellow ---
## Object: filter_spct [143 x 2]
## Wavelength range 206-768 nm, step 1-191 nm 
## Label: Theatrical &#39;gel&#39;, type &#39;Canary Supergel no312; new; from Rosco, UK 
## Rfr (/1): 0.080, thickness (mm): 0.0900, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 143 × 2
##   w.length       Tfr
##      &lt;int&gt;     &lt;dbl&gt;
## 1      206 0.0000100
## 2      207 0.0000100
## 3      208 0.0000100
## 4      209 0.0000100
## # ℹ 139 more rows
## 
## --- END ---</code></pre>
<p>Two of the filters in the collection do not have peaks, and a
spectrum object of length zero is returned for them.</p>
</div>
</div>
<div id="wavelengths-at-target-value" class="section level3">
<h3>Wavelengths at target value</h3>
<p>Method <code>wls_at_target</code> takes a spectrum as first argument
and returns a subset of the spectral object data or a new object
corresponding to wavelengths at which the spectrum is at the target
value. Geometrically is equivalent to finding the wavelengths at which a
horizontal <em>target</em> line intercepts the curve depicting the
spectrum.</p>
<div class="sourceCode" id="cb481"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb481-1"><a href="#cb481-1" tabindex="-1"></a><span class="fu">wls_at_target</span>(Ler_leaf_trns.spct, </span>
<span id="cb481-2"><a href="#cb481-2" tabindex="-1"></a>              <span class="at">target =</span> <span class="st">&quot;half.maximum&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_spct [1 x 2]
## Wavelength range 709.35352-709.35352 nm, step NA nm 
## Label: Ler_06_black.spct 
## Measured on 2017-07-03 13:18:18.615114 UTC 
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 1 × 2
##   w.length   Tfr
##      &lt;dbl&gt; &lt;dbl&gt;
## 1     709. 0.222</code></pre>
<div class="sourceCode" id="cb483"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb483-1"><a href="#cb483-1" tabindex="-1"></a><span class="fu">wls_at_target</span>(Ler_leaf_trns.spct, </span>
<span id="cb483-2"><a href="#cb483-2" tabindex="-1"></a>              <span class="at">target =</span> <span class="st">&quot;half.maximum&quot;</span>, </span>
<span id="cb483-3"><a href="#cb483-3" tabindex="-1"></a>              <span class="at">interpolate =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## Object: filter_spct [1 x 2]
## Wavelength range 709.50991-709.50991 nm, step NA nm 
## Label: Ler_06_black.spct 
## Measured on 2017-07-03 13:18:18.615114 UTC 
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 1 × 2
##   w.length   Tfr
##      &lt;dbl&gt; &lt;dbl&gt;
## 1     710. 0.224</code></pre>
<p>This function can be used with all spectral classes defined in the
package. In the case of <code>source_spct</code> and
<code>response_spct</code> methods parameter <code>unit.out</code>
allows to switch between energy and photon units for the search and
returned value, while in the case of <code>filter_spct</code> methods
filter.qty` allows to switch between transmittance, absorptance and
absorbance.</p>
<div id="collections-of-spectra-3" class="section level4">
<h4>Collections of spectra</h4>
<p>The method is also implemented for collections of spectra.</p>
<div class="sourceCode" id="cb485"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb485-1"><a href="#cb485-1" tabindex="-1"></a><span class="fu">wls_at_target</span>(filters.mspct, <span class="at">target =</span> <span class="st">&quot;half.maximum&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_mspct [3 x 1]
## --- Member: none ---
## Object: filter_spct [0 x 2]
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 0 × 2
## # ℹ 2 variables: w.length &lt;dbl&gt;, Tfr &lt;dbl&gt;
## --- Member: pet ---
## Object: filter_spct [1 x 2]
## Wavelength range 322-322 nm, step NA nm 
## Label: Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDermit Autotype; new 
## Rfr (/1): 0.074, thickness (mm): 0.125, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 1 × 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      322 0.462
## --- Member: yellow ---
## Object: filter_spct [1 x 2]
## Wavelength range 509-509 nm, step NA nm 
## Label: Theatrical &#39;gel&#39;, type &#39;Canary Supergel no312; new; from Rosco, UK 
## Rfr (/1): 0.080, thickness (mm): 0.0900, attenuation mode: absorption.
## Variables:
##  w.length: Wavelength [nm]
##  Tfr: Total spectral transmittance [/1] 
## --
## # A tibble: 1 × 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      509 0.457
## 
## --- END ---</code></pre>
</div>
</div>
<div id="irradiance" class="section level3">
<h3>Irradiance</h3>
<p>Energy irradiance is the integral over wavelengths of spectral energy
irradiance</p>
<p><span class="math display">\[E = \int_{\lambda = \lambda_1}^{\lambda
= \lambda_2} E(\lambda)\ \mathrm{d}\lambda\]</span> where <span class="math inline">\(\lambda_1 \geq \lambda &gt; \lambda_2\)</span>
defines a waveband, or range of wavelengths.</p>
<p>Photon (=quantum) irradiance is the integral over wavelengths of
spectral photon irradiance.</p>
<p><span class="math display">\[Q = \int_{\lambda = \lambda_1}^{\lambda
= \lambda_2} Q(\lambda)\ \mathrm{d}\lambda\]</span> Spectrally weighted
(or biologically effective) energy irradiance is the integral of the
result of the convolution of spectral energy irradiance by a spectral
weighting function <span class="math inline">\(w(\lambda)\)</span>.</p>
<p><span class="math display">\[E_{BE} = \int_{\lambda =
\lambda_1}^{\lambda = \lambda_2} E(\lambda) \cdot w_E(\lambda)\
\mathrm{d}\lambda\]</span> Spectrally weighted (or effective) photon
irradiance can be computed similarly with the corresponding weighting
function <span class="math inline">\(w_Q(\lambda)\)</span>.</p>
<div id="individual-spectra-4" class="section level4">
<h4>Individual spectra</h4>
<p>The code using <code>spct</code> objects is simple; to integrate the
whole spectrum we can use <code>irrad()</code> that returns by default
energy irradiance, unless an R option is set to make photon-based units
the default. When this flexibility is not needed, <code>e_irrad()</code>
and <code>q_irrad()</code> should be preferred. For most examples we use
energy-based units and <code>e_irrad()</code>, but they also apply
unchanged to <code>q_irrad()</code> and photon-based units, and
<em>vice-versa</em> for those examples using <code>q_irrad()</code>.</p>
<p>The abbreviations <em>E</em> and <em>Q</em> are used to denote these
two quantities, usually with the waveband as a subscript. In what
follows “Total” as subscript denotes the whole range of wavelengths in
the spectrum. This is the default.</p>
<div class="sourceCode" id="cb487"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb487-1"><a href="#cb487-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct)</span></code></pre></div>
<pre><code>##  E_Total 
## 269.1249 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<p>To integrate one restricted range of wavelengths from a spectrum, we
can provide a wavelength definition. In this example, waveband
<code>PAR.wb</code> giving the definition of <em>photosynthetically
active radiation</em>. (<code>PAR.wb</code> was defined above.)</p>
<div class="sourceCode" id="cb489"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb489-1"><a href="#cb489-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct, PAR.wb)</span></code></pre></div>
<pre><code>##    E_PAR 
## 196.6343 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<p>It is also valid to pass as argument for <code>w.band</code> a
numeric range representing wavelengths in manometers (nm), which is
converted into a waveband definition on-the-fly. Note, however, that the
automatically assigned name gives only the range.</p>
<div class="sourceCode" id="cb491"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb491-1"><a href="#cb491-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct, <span class="fu">c</span>(<span class="dv">400</span>, <span class="dv">700</span>))</span></code></pre></div>
<pre><code>## E_range.400.700 
##        196.6343 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<p>The ‘photobiology’ package uses base SI units, so by default photon
irradiance (= quantum irradiance) is expressed in <span class="math inline">\(mol\,s^{-1}\,m^{-2}\)</span>. We can pass a
scaling factor as shown below if needed.</p>
<div class="sourceCode" id="cb493"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb493-1"><a href="#cb493-1" tabindex="-1"></a><span class="fu">q_irrad</span>(sun.spct, PAR.wb, <span class="at">scale.factor =</span> <span class="fl">1e6</span>) <span class="co"># umol s-1 m-2</span></span></code></pre></div>
<pre><code>##    Q_PAR 
## 894.1483 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<p>It is possible to supply a time unit to use, instead of the default
of seconds, as basis of expression for the returned value. However, be
aware that conversion into a different time unit than that used during
measurement, is only valid for sources like lamps, which have an output
the remains constant in time.</p>
<div class="sourceCode" id="cb495"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb495-1"><a href="#cb495-1" tabindex="-1"></a><span class="fu">q_irrad</span>(white_led.source_spct, PAR.wb, <span class="at">time.unit =</span> <span class="st">&quot;hour&quot;</span>)</span></code></pre></div>
<pre><code>##    Q_PAR 
## 1.585662 
## attr(,&quot;time.unit&quot;)
## [1] &quot;hour&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<p>Using a shorter time unit than the original, yields an average value
re-expressed on a new time unit base.</p>
<div class="sourceCode" id="cb497"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb497-1"><a href="#cb497-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun_daily.spct, PAR.wb, <span class="at">time.unit =</span> <span class="st">&quot;second&quot;</span>)</span></code></pre></div>
<pre><code>##    E_PAR 
## 92.16251 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<p>Lists of wavebands are also accepted as argument for parameter
<code>w.band</code> in which case a named numeric vector of summary
values is returned by default.</p>
<div class="sourceCode" id="cb499"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb499-1"><a href="#cb499-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct, UV_bands.lst) <span class="co"># W m-2</span></span></code></pre></div>
<pre><code>##      E_UVB      E_UVA 
##  0.6445105 27.9842061 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<div class="sourceCode" id="cb501"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb501-1"><a href="#cb501-1" tabindex="-1"></a><span class="fu">q_irrad</span>(sun.spct, UV_bands.lst) <span class="co"># mol s-1 m-2</span></span></code></pre></div>
<pre><code>##        Q_UVB        Q_UVA 
## 1.675387e-06 8.482093e-05 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<div class="sourceCode" id="cb503"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb503-1"><a href="#cb503-1" tabindex="-1"></a><span class="fu">q_irrad</span>(sun.spct, UV_bands.lst, <span class="at">scale.factor =</span> <span class="fl">1e6</span>) <span class="co"># umol s-1 m-2</span></span></code></pre></div>
<pre><code>##     Q_UVB     Q_UVA 
##  1.675387 84.820933 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<p>These functions have an additional argument <code>quantity</code>,
with default <code>&quot;total&quot;</code>, which can take values controlling the
output. The value “total” yields <strong>irradiance</strong> in <span class="math inline">\(W\,m^{-2}\)</span>, integrated over wavelengths
for each waveband, while “average” yields the mean <strong>spectral
irradiance</strong> within each waveband in <span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span>.</p>
<div class="sourceCode" id="cb505"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb505-1"><a href="#cb505-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct, UV_bands.lst, <span class="at">quantity =</span> <span class="st">&quot;total&quot;</span>) <span class="co"># watt m-2</span></span></code></pre></div>
<pre><code>##      E_UVB      E_UVA 
##  0.6445105 27.9842061 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<div class="sourceCode" id="cb507"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb507-1"><a href="#cb507-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct, UV_bands.lst, <span class="at">quantity =</span> <span class="st">&quot;average&quot;</span>) <span class="co"># watt m-2 nm-1</span></span></code></pre></div>
<pre><code>##  E(wl)_UVB  E(wl)_UVA 
## 0.01841458 0.32922595 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;average energy irradiance&quot;</code></pre>
<p>When <code>quantity = &quot;contribution&quot;</code> irradiances for
individual wavebands are expressed relative to the irradiance computed
for the whole spectrum, while for <code>quantity = &quot;relative&quot;</code>
they are expressed relative to the sum of the irradiances for all the
wavebands. In both cases values are expressed as fractions of one.</p>
<div class="sourceCode" id="cb509"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb509-1"><a href="#cb509-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct, UV_bands.lst, <span class="at">quantity =</span> <span class="st">&quot;contribution&quot;</span>)</span></code></pre></div>
<pre><code>##  E/Etot_UVB  E/Etot_UVA 
## 0.002394838 0.103982226 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;contribution energy irradiance&quot;</code></pre>
<div class="sourceCode" id="cb511"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb511-1"><a href="#cb511-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct, UV_bands.lst, <span class="at">quantity =</span> <span class="st">&quot;relative&quot;</span>)</span></code></pre></div>
<pre><code>## E/Esum_UVB E/Esum_UVA 
## 0.02251273 0.97748727 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;relative energy irradiance&quot;</code></pre>
<p>When setting <code>&quot;contribution.pc&quot;</code> or
<code>&quot;relative.pc&quot;</code> as <code>quantity</code> the same values as
in the examples above, are expressed as percentages instead of
fractions.</p>
<div class="sourceCode" id="cb513"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb513-1"><a href="#cb513-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct, UV_bands.lst, <span class="at">quantity =</span> <span class="st">&quot;contribution.pc&quot;</span>)</span></code></pre></div>
<pre><code>## E/Etot_UVB E/Etot_UVA 
##  0.2394838 10.3982226 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;contribution.pc energy irradiance&quot;</code></pre>
<div class="sourceCode" id="cb515"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb515-1"><a href="#cb515-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct, UV_bands.lst, <span class="at">quantity =</span> <span class="st">&quot;relative.pc&quot;</span>)</span></code></pre></div>
<pre><code>## E/Esum_UVB E/Esum_UVA 
##   2.251273  97.748727 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;relative.pc energy irradiance&quot;</code></pre>
<p>The total radiation received on a surface during an exposure event
can be also calculated with methods <code>irrad()</code>,
<code>e_irrad()</code> and <code>q_irrad()</code>, but the values
returned are irradiances expressed on a very unusual time basis. These
are no longer W m-2 (J s-1 m-2), but instead J per 8 hours per square
meter.</p>
<div class="sourceCode" id="cb517"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb517-1"><a href="#cb517-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun.spct, PAR.wb, <span class="at">time.unit =</span> <span class="fu">duration</span>(<span class="dv">8</span>, <span class="st">&quot;hours&quot;</span>))</span></code></pre></div>
<pre><code>##   E_PAR 
## 5663067 
## attr(,&quot;time.unit&quot;)
## [1] &quot;28800s (~8 hours)&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<p>When the intention is to calculate a total fluence or exposure for an
event, function <code>fluence()</code>, <code>e_fluence()</code> or
<code>q_fluence()</code> should be used as this will add the correct
metadata attributes to the returned value: expressed as energy or
photons per unit area per event. See later sections for details.</p>
<div class="sourceCode" id="cb519"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb519-1"><a href="#cb519-1" tabindex="-1"></a><span class="fu">e_fluence</span>(sun.spct, PAR.wb, <span class="at">exposure.time =</span> <span class="fu">duration</span>(<span class="dv">8</span>, <span class="st">&quot;hours&quot;</span>))</span></code></pre></div>
<pre><code>##   E_PAR 
## 5663067 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;energy fluence (J m-2)&quot;
## attr(,&quot;exposure.duration&quot;)
## [1] &quot;28800s (~8 hours)&quot;</code></pre>
<p>In all earlier examples in this section, the default naming of
returned values was active. The default naming of the values is an
abbreviation of the physical quantity plus the name of the wavelength.
Alternatively <code>&quot;short&quot;</code> naming uses only the name of the
wavebands as shown below, obtained from the label stored in the waveband
definitions.</p>
<div class="sourceCode" id="cb521"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb521-1"><a href="#cb521-1" tabindex="-1"></a><span class="fu">q_irrad</span>(sun.spct, UV_bands.lst, <span class="at">naming =</span> <span class="st">&quot;short&quot;</span>)</span></code></pre></div>
<pre><code>##          UVB          UVA 
## 1.675387e-06 8.482093e-05 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<p>Naming can also be completely suppressed.</p>
<div class="sourceCode" id="cb523"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb523-1"><a href="#cb523-1" tabindex="-1"></a><span class="fu">q_irrad</span>(sun.spct, UV_bands.lst, <span class="at">naming =</span> <span class="st">&quot;none&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 1.675387e-06 8.482093e-05
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<p>Names of members of a list of wavebands, override the labels in
waveband definitions.</p>
<div class="sourceCode" id="cb525"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb525-1"><a href="#cb525-1" tabindex="-1"></a><span class="fu">names</span>(UV_bands.lst) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;UV-C&quot;</span>, <span class="st">&quot;UV-B&quot;</span>, <span class="st">&quot;UV-A&quot;</span>)</span>
<span id="cb525-2"><a href="#cb525-2" tabindex="-1"></a><span class="fu">q_irrad</span>(sun.spct, UV_bands.lst, <span class="at">naming =</span> <span class="st">&quot;short&quot;</span>, <span class="at">scale.factor =</span> <span class="fl">1e6</span>)</span></code></pre></div>
<pre><code>##      UV-B      UV-A 
##  1.675387 84.820933 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
</div>
<div id="collections-of-spectra-4" class="section level4">
<h4>Collections of spectra</h4>
<p>Collections of spectra can be useful not only for time-series of
spectra or spectral images, but also when dealing with a small group of
related spectra. In the example below we show how to use a collection of
spectra to estimate irradiances under different filters set up in
sunlight.</p>
<p>Methods <code>irrad()</code>, <code>e_irrad()</code> and
<code>q_irrad()</code> can be used for collections of spectra exactly as
for a single spectrum (as described above). We here only show the
additional features that apply to collections. In this first example, we
can see that the returned object is a data frame instead of a named
numeric vector.</p>
<div class="sourceCode" id="cb527"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb527-1"><a href="#cb527-1" tabindex="-1"></a><span class="fu">e_irrad</span>(sun_evening.mspct, <span class="at">w.band =</span> PAR.wb)</span></code></pre></div>
<pre><code>## # A tibble: 5 × 2
##   spct.idx E_PAR
##   &lt;fct&gt;    &lt;dbl&gt;
## 1 time.01   16.2
## 2 time.02   15.7
## 3 time.03   15.7
## 4 time.04   15.8
## 5 time.05   16.4</code></pre>
<p>Spectral objects can contain metadata as attributes. When summarizing
a collection of spectra it is frequently very useful to copy some of
these metadata, extracted from each member of the collection, to columns
in the returned data frame. This can be done as follows.</p>
<div class="sourceCode" id="cb529"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb529-1"><a href="#cb529-1" tabindex="-1"></a><span class="fu">q_irrad</span>(sun_evening.mspct, </span>
<span id="cb529-2"><a href="#cb529-2" tabindex="-1"></a>        <span class="at">w.band =</span> PAR.wb,</span>
<span id="cb529-3"><a href="#cb529-3" tabindex="-1"></a>        <span class="at">scale.factor =</span> <span class="fl">1e6</span>, <span class="co"># umol m-2 s-1</span></span>
<span id="cb529-4"><a href="#cb529-4" tabindex="-1"></a>        <span class="at">attr2tb =</span> <span class="fu">c</span>(<span class="at">when.measured =</span> <span class="st">&quot;time&quot;</span>, <span class="at">lon =</span> <span class="st">&quot;lon&quot;</span>, <span class="at">lat =</span> <span class="st">&quot;lat&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 5 × 5
##   spct.idx Q_PAR time                  lon   lat
##   &lt;fct&gt;    &lt;dbl&gt; &lt;dttm&gt;              &lt;dbl&gt; &lt;dbl&gt;
## 1 time.01   72.7 2023-06-12 18:38:00  24.0  60.2
## 2 time.02   70.5 2023-06-12 18:39:00  24.0  60.2
## 3 time.03   70.7 2023-06-12 18:40:00  24.0  60.2
## 4 time.04   70.9 2023-06-12 18:41:00  24.0  60.2
## 5 time.05   74.2 2023-06-12 18:42:00  24.0  60.2</code></pre>
<p>For a more advanced example, we reuse the collection of filter
spectra <code>filters.mspct</code> from an earlier section. We convolve
each filter’s spectral transmittance by the spectral irradiance of the
light source so as to predict the irradiances under the filters. We
specify the name of the column where the names of the spectra (their
index) is stored.</p>
<div class="sourceCode" id="cb531"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb531-1"><a href="#cb531-1" tabindex="-1"></a>filtered_sun <span class="ot">&lt;-</span> <span class="fu">convolve_each</span>(filters.mspct, sun.spct)</span>
<span id="cb531-2"><a href="#cb531-2" tabindex="-1"></a><span class="fu">q_irrad</span>(filtered_sun,</span>
<span id="cb531-3"><a href="#cb531-3" tabindex="-1"></a>        <span class="fu">list</span>(UVA.wb, PAR.wb),</span>
<span id="cb531-4"><a href="#cb531-4" tabindex="-1"></a>        <span class="at">scale.factor =</span> <span class="fl">1e6</span>,</span>
<span id="cb531-5"><a href="#cb531-5" tabindex="-1"></a>        <span class="at">idx =</span> <span class="st">&quot;Filter&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   Filter  Q_UVA Q_PAR
##   &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 none   84.8    894.
## 2 pet    70.2    823.
## 3 yellow  0.105  536.</code></pre>
<p>The code above example can also be written as a single statement.
Here we also tweak column names, delete one column, and swap the
position of the remaining columns.</p>
<div class="sourceCode" id="cb533"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb533-1"><a href="#cb533-1" tabindex="-1"></a><span class="fu">q_irrad</span>(<span class="fu">convolve_each</span>(filters.mspct, sun.spct), </span>
<span id="cb533-2"><a href="#cb533-2" tabindex="-1"></a>        <span class="fu">list</span>(<span class="st">&quot;UV-A&quot;</span> <span class="ot">=</span> UVA.wb, PAR.wb),</span>
<span id="cb533-3"><a href="#cb533-3" tabindex="-1"></a>        <span class="at">scale.factor =</span> <span class="fl">1e6</span>,  <span class="co"># umol m-2 s-1</span></span>
<span id="cb533-4"><a href="#cb533-4" tabindex="-1"></a>        <span class="at">naming =</span> <span class="st">&quot;short&quot;</span>,</span>
<span id="cb533-5"><a href="#cb533-5" tabindex="-1"></a>        <span class="at">attr2tb =</span> <span class="fu">c</span>(<span class="at">what.measured =</span> <span class="st">&quot;Filter type&quot;</span>))[ , <span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">3</span>)]</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   `Filter type`                                                     `UV-A`   PAR
##   &lt;chr&gt;                                                              &lt;dbl&gt; &lt;dbl&gt;
## 1 theoretical fully transparent object                              84.8    894.
## 2 Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDer… 70.2    823.
## 3 Theatrical &#39;gel&#39;, type &#39;Canary Supergel no312; new; from Rosco, …  0.105  536.</code></pre>
<p>It is also possible to use an <em>apply</em> function. See sections
<em>apply</em> functions and <code>convolve</code> for more details, as
in certain cases only one or the other can be used.</p>
</div>
</div>
<div id="fluence" class="section level3">
<h3>Fluence</h3>
<p>Energy fluence is energy irradiance integrated over a lapse of time
or event, and is expressed as energy per area.</p>
<p>Energy fluence is the integral over wavelengths and time of spectral
energy irradiance</p>
<p><span class="math display">\[F_E = \int_{\lambda =
\lambda_1}^{\lambda = \lambda_2} \int_{t = t_1}^{t = t_2} E(\lambda)\
\mathrm{d}\lambda\,\mathrm{d}t\]</span> where <span class="math inline">\(\lambda_1 \geq \lambda &gt; \lambda_2\)</span>
defines a waveband, or range of wavelengths, and <span class="math inline">\(t_1 \geq t &gt; t_2\)</span>.</p>
<p>However, if we assume that irradiance does not vary in time it
simplifies to <span class="math display">\[F_E =  \Delta
t\times\int_{\lambda = \lambda_1}^{\lambda = \lambda_2} E(\lambda)\
\mathrm{d}\lambda\]</span> where <span class="math inline">\(\Delta t =
t_2 - t_1\)</span>.</p>
<p>The equivalent equation for photon fluence is <span class="math display">\[F_Q =  \Delta t\times\int_{\lambda =
\lambda_1}^{\lambda = \lambda_2} Q(\lambda)\
\mathrm{d}\lambda\]</span></p>
<p>Spectrally weighted (or effective) energy fluence is the integral
over wavelengths and time of the result of the convolution of spectral
energy irradiance by a spectral weight function <span class="math inline">\(w(\lambda)\)</span>. Assuming that spectral
irradiance does not vary with time the corresponding equation is</p>
<p><span class="math display">\[F_{E_{BE}} = \Delta t\times\int_{\lambda
= \lambda_1}^{\lambda = \lambda_2} E(\lambda) \times w_E(\lambda)\
\mathrm{d}\lambda\]</span></p>
<p>Spectrally weighted (or effective) photon fluence can be computed
similarly with the corresponding weighting function <span class="math inline">\(w_Q(\lambda)\)</span>.</p>
<div id="individual-spectra-5" class="section level4">
<h4>Individual spectra</h4>
<p>The calculation of fluence values (time-integrated irradiance) is
identical to that for irradiance, except that a
<code>exposure.time</code> argument needs to be supplied. The exposure
time must be a <code>lubridate::duration</code>, but any argument
accepted by <code>as.duration</code> can also be used. Functions
<code>fluence</code>, <code>e_fluence</code> and <code>q_fluence</code>
correspond to <code>irrad</code>, <code>e_irrad</code> and
<code>q_irrad</code>,</p>
<div class="sourceCode" id="cb535"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb535-1"><a href="#cb535-1" tabindex="-1"></a><span class="fu">fluence</span>(sun.spct, <span class="at">exposure.time =</span> <span class="fu">duration</span>(<span class="dv">1</span>, <span class="st">&quot;hours&quot;</span>))</span></code></pre></div>
<pre><code>##  E_Total 
## 968849.6 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;energy fluence (J m-2)&quot;
## attr(,&quot;exposure.duration&quot;)
## [1] &quot;3600s (~1 hours)&quot;</code></pre>
<p>or</p>
<div class="sourceCode" id="cb537"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb537-1"><a href="#cb537-1" tabindex="-1"></a><span class="fu">fluence</span>(sun.spct, <span class="at">exposure.time =</span> <span class="dv">3600</span>) <span class="co"># seconds</span></span></code></pre></div>
<pre><code>## converting &#39;time.unit&#39; 3600 into a lubridate::duration</code></pre>
<pre><code>##  E_Total 
## 968849.6 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;energy fluence (J m-2)&quot;
## attr(,&quot;exposure.duration&quot;)
## [1] 3600</code></pre>
<p>and, to obtain the photon fluence for a range of wavelengths, in the
example, photosynthetically active radiation, we use the
<code>PAR.wb</code> waveband object earlier defined, and integrate for
25 minutes of exposure.</p>
<div class="sourceCode" id="cb540"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb540-1"><a href="#cb540-1" tabindex="-1"></a><span class="fu">q_fluence</span>(sun.spct, PAR.wb, <span class="at">exposure.time =</span> <span class="fu">duration</span>(<span class="dv">25</span>, <span class="st">&quot;minutes&quot;</span>))</span></code></pre></div>
<pre><code>##    Q_PAR 
## 1.341222 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;photon fluence (mol m-2)&quot;
## attr(,&quot;exposure.duration&quot;)
## [1] &quot;1500s (~25 minutes)&quot;</code></pre>
</div>
</div>
<div id="photon-and-energy-ratios" class="section level3">
<h3>Photon and energy ratios</h3>
<p>A way to summarize the “colour” of light is to compute a ratio
between irradiances computed for two different wavebands of the same
spectrum. They can be computed either on an energy or photon (quantum)
basis, and although not a requirement, use of two wavelength bands with
the same expanse is usually most informative. Photon ratios are usually
preferred compared to energy ratios in work related to photobiology and
photochemistry.</p>
<p><span class="math display">\[Q_1 : Q_2 = \frac{\int_{\lambda =
\lambda_1}^{\lambda = \lambda_2} Q(\lambda)\ \mathrm{d}\lambda}
{\int_{\lambda = \lambda_3}^{\lambda = \lambda_4} Q(\lambda)\
\mathrm{d}\lambda}\]</span></p>
<p>where <span class="math inline">\(\lambda_1 \geq \lambda &gt;
\lambda_2\)</span> defines the waveband for the numerator and <span class="math inline">\(\lambda_3 \geq \lambda &gt; \lambda_4\)</span>
defines the waveband for the denominator, i.e., two ranges of
wavelengths.</p>
<p>Energy ratios are computed similarly</p>
<p><span class="math display">\[E_1 : E_2 = \frac{\int_{\lambda =
\lambda_1}^{\lambda = \lambda_2} E(\lambda)\ \mathrm{d}\lambda}
{\int_{\lambda = \lambda_3}^{\lambda = \lambda_4} E(\lambda)\
\mathrm{d}\lambda}\]</span></p>
<p>where <span class="math inline">\(\lambda_1 \geq \lambda &gt;
\lambda_2\)</span> defines the waveband for the numerator and <span class="math inline">\(\lambda_3 \geq \lambda &gt; \lambda_4\)</span>
defines the waveband for the denominator, i.e., two ranges of
wavelengths.</p>
<p>An energy irradiance to photon irradiance ratio describes the average
energy per mol of photon for a waveband or range of wavelengths.</p>
<p><span class="math display">\[E : Q = \frac{\int_{\lambda =
\lambda_1}^{\lambda = \lambda_2} E(\lambda)\ \mathrm{d}\lambda}
{\int_{\lambda = \lambda_1}^{\lambda = \lambda_2} Q(\lambda)\
\mathrm{d}\lambda}\]</span></p>
<p>where <span class="math inline">\(\lambda_1 \geq \lambda &gt;
\lambda_2\)</span> defines a waveband, or range of wavelengths.</p>
<p>We can compute the photon to energy ratio (<span class="math inline">\(Q : E\)</span>) similarly.</p>
<p>Although all these ratios are usually computed without use of
spectral weighting functions, their computation can be easily done by
including in the equations above a weighting functions (<span class="math inline">\(w(\lambda)\)</span>) as described in the section
on irradiance.</p>
<div id="individual-spectra-6" class="section level4">
<h4>Individual spectra</h4>
<p>The functions described here, in there simplest use, calculate a
ratio between two wavebands. The function <code>q_ratio</code> returning
photon ratios. However both waveband parameters can take lists of
wavebands as arguments, with normal recycling rules in effect. The
corresponding function <code>e_ratio</code> returns energy ratios.</p>
<p>A single ratio.</p>
<div class="sourceCode" id="cb542"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb542-1"><a href="#cb542-1" tabindex="-1"></a><span class="fu">q_ratio</span>(sun.spct, UVB.wb, PAR.wb)</span></code></pre></div>
<pre><code>## UVB:PAR[q:q] 
##  0.001873724 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;q:q ratio&quot;</code></pre>
<p>If no waveband is passed as numerator, the whole spectrum is used.
The waveband fully outside the wavelength range of the spectrum is
dropped silently.</p>
<div class="sourceCode" id="cb544"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb544-1"><a href="#cb544-1" tabindex="-1"></a><span class="fu">q_ratio</span>(sun.spct, <span class="fu">list</span>(UVC.wb, UVB.wb, UVA.wb))</span></code></pre></div>
<pre><code>## UVB:Total[q:q] UVA:Total[q:q] 
##    0.001334593    0.067567343 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;q:q ratio&quot;</code></pre>
<p>Three denominators (one skipped) and a single denominator.</p>
<div class="sourceCode" id="cb546"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb546-1"><a href="#cb546-1" tabindex="-1"></a><span class="fu">q_ratio</span>(sun.spct, <span class="fu">list</span>(UVC.wb, UVB.wb, UVA.wb), PAR.wb)</span></code></pre></div>
<pre><code>## UVB:PAR[q:q] UVA:PAR[q:q] 
##  0.001873724  0.094862270 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;q:q ratio&quot;</code></pre>
<p>Function <code>qe_ratio</code>, has only one waveband parameter, and
returns the <em>photon</em> to <em>energy</em> ratio, while its
complement <code>eq_ratio</code> returns the <em>energy</em> to
<em>photon</em> ratio. Here we show how parameters
<code>scale.factor</code> and <code>name.tag</code> make scaling the
returned value easy.</p>
<div class="sourceCode" id="cb548"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb548-1"><a href="#cb548-1" tabindex="-1"></a><span class="fu">qe_ratio</span>(sun.spct,</span>
<span id="cb548-2"><a href="#cb548-2" tabindex="-1"></a>         <span class="fu">list</span>(<span class="st">&quot;UV-B&quot;</span> <span class="ot">=</span> UVB.wb, PAR.wb), </span>
<span id="cb548-3"><a href="#cb548-3" tabindex="-1"></a>         <span class="at">scale.factor =</span> <span class="fl">1e6</span>,</span>
<span id="cb548-4"><a href="#cb548-4" tabindex="-1"></a>         <span class="at">name.tag =</span> <span class="st">&quot; (umol/J)&quot;</span>)</span></code></pre></div>
<pre><code>## UV-B (umol/J)  PAR (umol/J) 
##      2.599472      4.547266 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;q:e ratio&quot;</code></pre>
</div>
<div id="collections-of-spectra-5" class="section level4">
<h4>Collections of spectra</h4>
<p>As other summary methods, <code>q_ratio()</code>,
<code>e_ratio()</code>, <code>qe_ratio()</code> and
<code>eq_ratio()</code> when applied to a collection of spectra, they
return a data frame.</p>
<div class="sourceCode" id="cb550"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb550-1"><a href="#cb550-1" tabindex="-1"></a><span class="fu">q_ratio</span>(filtered_sun, </span>
<span id="cb550-2"><a href="#cb550-2" tabindex="-1"></a>        <span class="fu">list</span>(UVB.wb, UVA.wb),</span>
<span id="cb550-3"><a href="#cb550-3" tabindex="-1"></a>        PAR.wb)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   spct.idx `UVB:PAR[q:q]` `UVA:PAR[q:q]`
##   &lt;fct&gt;             &lt;dbl&gt;          &lt;dbl&gt;
## 1 none         0.00187          0.0949  
## 2 pet          0.0000720        0.0853  
## 3 yellow       0.00000387       0.000196</code></pre>
<p>Additional parameters allow the scaling and customized column names
possible.</p>
<div class="sourceCode" id="cb552"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb552-1"><a href="#cb552-1" tabindex="-1"></a><span class="fu">q_ratio</span>(filtered_sun, </span>
<span id="cb552-2"><a href="#cb552-2" tabindex="-1"></a>        <span class="fu">list</span>(UVB.wb, UVA.wb),</span>
<span id="cb552-3"><a href="#cb552-3" tabindex="-1"></a>        PAR.wb, </span>
<span id="cb552-4"><a href="#cb552-4" tabindex="-1"></a>        <span class="at">scale.factor =</span> <span class="dv">100</span>, </span>
<span id="cb552-5"><a href="#cb552-5" tabindex="-1"></a>        <span class="at">name.tag =</span> <span class="st">&quot; (% photons)&quot;</span>, </span>
<span id="cb552-6"><a href="#cb552-6" tabindex="-1"></a>        <span class="at">idx =</span> <span class="st">&quot;Filter&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   Filter `UVB:PAR (% photons)` `UVA:PAR (% photons)`
##   &lt;fct&gt;                  &lt;dbl&gt;                 &lt;dbl&gt;
## 1 none                0.187                   9.49  
## 2 pet                 0.00720                 8.53  
## 3 yellow              0.000387                0.0196</code></pre>
</div>
</div>
<div id="transmittance-reflectance-absorptance-and-absorbance" class="section level3">
<h3>Transmittance, reflectance, absorptance and absorbance</h3>
<p>Given the laws of conservation of energy, transmittance, reflectance
and absorptance, expressed as fractions, always add up to one.</p>
<p><span class="math display">\[1 = R_\mathrm{fr,total} +
A_\mathrm{fr,total} + T_\mathrm{fr,total}\]</span> Transmittance can be
defined either as the fraction of the radiation “entering” an object
that is transmitted, called internal transmittance (<span class="math inline">\(T_\mathrm{fr,internal}\)</span>) or as the
fraction of the ration incident on an object that is transmitted (<span class="math inline">\(T_\mathrm{fr,total}\)</span>).</p>
<p><span class="math display">\[1 \times R_\mathrm{fr,total}
=  A_\mathrm{fr,internal} + T_\mathrm{fr,internal}\]</span> giving</p>
<p><span class="math display">\[T_\mathrm{fr,internal} =
T_\mathrm{fr,total} / R_\mathrm{fr,total}\]</span> and <span class="math display">\[A_\mathrm{fr,internal} = T_\mathrm{fr,total} /
R_\mathrm{fr,total}\]</span> In the case of reflectance, “total” has a
different meaning, and refers to whether all reflected light or that an
specific angle in considered.</p>
<p>In practice, both definitions of transmittance and absorptance are in
use, while as it is easier to measure total- than internal
transmittance, internal transmittance allows the computation of
transmittance for different thickness of a material.</p>
<p>Consequently, absorptance can be computed as:</p>
<p><span class="math display">\[A_\mathrm{fr,internal} = 1 -
T_\mathrm{fr,internal}\]</span> or as</p>
<p><span class="math display">\[A_\mathrm{fr,total} = 1 -
T_\mathrm{fr,total} - R_\mathrm{fr,total}\]</span> Absorbance, is a log
transformed quantity that tends to be used when the range of values
spans several orders of magnitude. It is frequently based on internal
absorptance, but can be also based on total absorptance.</p>
<p><span class="math display">\[A_\mathrm{internal} = -\log_{10}(1
-A_\mathrm{fr,internal}) = -\log_{10}(T_\mathrm{fr,internal}) \]</span>
and</p>
<p><span class="math display">\[A_\mathrm{total} = -\log_{10}(1 -
A_\mathrm{fr,total}) = -\log_{10}(T_\mathrm{fr,total} +
R_\mathrm{fr,total})\]</span> When using a spectrophotometer, if our
reference is a cuvette with pure solvent and the sample a solution of a
compound in the same solvent we measure <em>internal</em> transmittance,
absorptance or absorbance. If we instead measure the transmittance of a
piece of glass or plastic with air as reference, we measure
<em>total</em> transmittance, absorptance or absorbance. This is so
because in the first case the reference is the light transmitted after
the reflectance on the cuvette walls has taken place while in the second
case the reflections at the glass-air interfaces are missing from the
reference.</p>
<p>As a result of these different definitions, the implementation of the
class <code>filter_spct()</code> and <code>object_spct</code> and their
methods, need to keep track of whether quantities are expressed as
internal or total. As in many glasses reflectance varies very weakly
with wavelength, storing a constant value for <span class="math inline">\(R_\mathrm{fr,total}\)</span> is also supported.
The refractive index of a material can also be used to estimate <span class="math inline">\(R_\mathrm{fr,total}\)</span> for a polished
surface. Lack of a value for <span class="math inline">\(R_\mathrm{fr,total}\)</span> can make some
conversions and computations impossible.</p>
<div id="individual-spectra-7" class="section level4">
<h4>Individual spectra</h4>
<p>The functions <code>transmittance</code>, <code>absorptance</code>
and <code>absorbance</code> take <code>filter_spct</code> as argument,
while function <code>reflectance</code> takes
<code>reflector_spct</code> objects as argument. Functions
<code>transmittance</code>, <code>reflectance</code> and
<code>absorptance</code> are also implemented for
<code>object_spct</code>. These functions return as default an average
value for these quantities <strong>assuming</strong> a light source with
a flat spectral energy output, but this can be changed as described
above for <code>irrad()</code>.</p>
<div class="sourceCode" id="cb554"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb554-1"><a href="#cb554-1" tabindex="-1"></a><span class="fu">transmittance</span>(polyester.spct, <span class="fu">list</span>(UVB.wb, UVA.wb, PAR.wb))</span></code></pre></div>
<pre><code>## Tfr(wl)_UVB Tfr(wl)_UVA Tfr(wl)_PAR 
## 0.009722449 0.781851261 0.920239286 
## attr(,&quot;Tfr.type&quot;)
## [1] &quot;total&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;transmittance average&quot;</code></pre>
<p>We can obtain numerical values without names if needed,</p>
<div class="sourceCode" id="cb556"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb556-1"><a href="#cb556-1" tabindex="-1"></a><span class="fu">transmittance</span>(polyester.spct, </span>
<span id="cb556-2"><a href="#cb556-2" tabindex="-1"></a>              <span class="fu">list</span>(UVB.wb, UVA.wb, PAR.wb),</span>
<span id="cb556-3"><a href="#cb556-3" tabindex="-1"></a>              <span class="at">naming =</span> <span class="st">&quot;none&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 0.009722449 0.781851261 0.920239286
## attr(,&quot;Tfr.type&quot;)
## [1] &quot;total&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;transmittance average&quot;</code></pre>
<p>or named only according to the wavebands.</p>
<div class="sourceCode" id="cb558"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb558-1"><a href="#cb558-1" tabindex="-1"></a><span class="fu">transmittance</span>(polyester.spct, </span>
<span id="cb558-2"><a href="#cb558-2" tabindex="-1"></a>              <span class="fu">list</span>(UVB.wb, UVA.wb, PAR.wb),</span>
<span id="cb558-3"><a href="#cb558-3" tabindex="-1"></a>              <span class="at">naming =</span> <span class="st">&quot;short&quot;</span>)</span></code></pre></div>
<pre><code>##         UVB         UVA         PAR 
## 0.009722449 0.781851261 0.920239286 
## attr(,&quot;Tfr.type&quot;)
## [1] &quot;total&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;transmittance average&quot;</code></pre>
<p>The reflectance of a leaf.</p>
<div class="sourceCode" id="cb560"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb560-1"><a href="#cb560-1" tabindex="-1"></a><span class="fu">reflectance</span>(green_leaf.spct, <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">600</span>, <span class="dv">700</span>)))</span></code></pre></div>
<pre><code>## Rfr(wl)_range.600.700 
##              0.089647 
## attr(,&quot;Rfr.type&quot;)
## [1] &quot;total&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;reflectance average&quot;</code></pre>
</div>
<div id="collections-of-spectra-6" class="section level4">
<h4>Collections of spectra</h4>
<p>Here we calculate the transmittance of a collection of spectra for
three filters in two wavebands, obtaining the results as a data frame,
with one row per filter, and one column per waveband. We reuse once more
<code>filters.mspct</code> from an earlier section.</p>
<p>Column names formed from quantity abbreviation and label in waveband
definitions.</p>
<div class="sourceCode" id="cb562"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb562-1"><a href="#cb562-1" tabindex="-1"></a><span class="fu">transmittance</span>(filters.mspct, </span>
<span id="cb562-2"><a href="#cb562-2" tabindex="-1"></a>              <span class="at">w.band =</span> <span class="fu">list</span>(UVA.wb, PAR.wb))</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   spct.idx `Tfr(wl)_UVA` `Tfr(wl)_PAR`
##   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;
## 1 none           1.00            1.00 
## 2 pet            0.782           0.920
## 3 yellow         0.00160         0.566</code></pre>
<p>With <code>naming = &quot;short&quot;</code> column names are the labels of
waveband definitions.</p>
<div class="sourceCode" id="cb564"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb564-1"><a href="#cb564-1" tabindex="-1"></a><span class="fu">transmittance</span>(filters.mspct, </span>
<span id="cb564-2"><a href="#cb564-2" tabindex="-1"></a>              <span class="at">w.band =</span> <span class="fu">list</span>(UVA.wb, PAR.wb),</span>
<span id="cb564-3"><a href="#cb564-3" tabindex="-1"></a>              <span class="at">naming =</span> <span class="st">&quot;short&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   spct.idx     UVA   PAR
##   &lt;fct&gt;      &lt;dbl&gt; &lt;dbl&gt;
## 1 none     1.00    1.00 
## 2 pet      0.782   0.920
## 3 yellow   0.00160 0.566</code></pre>
<p>If list members are named, column names are formed from quantity
abbreviation and name of list members, overriding the labels in the
waveband definitions.</p>
<div class="sourceCode" id="cb566"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb566-1"><a href="#cb566-1" tabindex="-1"></a><span class="fu">transmittance</span>(filters.mspct, </span>
<span id="cb566-2"><a href="#cb566-2" tabindex="-1"></a>              <span class="at">w.band =</span> <span class="fu">list</span>(<span class="st">&quot;UV-A&quot;</span> <span class="ot">=</span> UVA.wb, <span class="at">PAR =</span> PAR.wb))</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   spct.idx `Tfr(wl)_UV-A` `Tfr(wl)_PAR`
##   &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;
## 1 none            1.00            1.00 
## 2 pet             0.782           0.920
## 3 yellow          0.00160         0.566</code></pre>
<p>If list members are named, with <code>naming = &quot;short&quot;</code> column
names are the names of list members.</p>
<div class="sourceCode" id="cb568"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb568-1"><a href="#cb568-1" tabindex="-1"></a><span class="fu">transmittance</span>(filters.mspct, </span>
<span id="cb568-2"><a href="#cb568-2" tabindex="-1"></a>              <span class="at">w.band =</span> <span class="fu">list</span>(<span class="at">UVA =</span> UVA.wb, <span class="at">PAR =</span> PAR.wb),</span>
<span id="cb568-3"><a href="#cb568-3" tabindex="-1"></a>              <span class="at">naming =</span> <span class="st">&quot;short&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   spct.idx     UVA   PAR
##   &lt;fct&gt;      &lt;dbl&gt; &lt;dbl&gt;
## 1 none     1.00    1.00 
## 2 pet      0.782   0.920
## 3 yellow   0.00160 0.566</code></pre>
<p>We can add metadata attributes as columns, changing the name if
desired.</p>
<div class="sourceCode" id="cb570"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb570-1"><a href="#cb570-1" tabindex="-1"></a><span class="fu">transmittance</span>(filters.mspct, </span>
<span id="cb570-2"><a href="#cb570-2" tabindex="-1"></a>              <span class="at">w.band =</span> UVA.wb,</span>
<span id="cb570-3"><a href="#cb570-3" tabindex="-1"></a>              <span class="at">naming =</span> <span class="st">&quot;short&quot;</span>,</span>
<span id="cb570-4"><a href="#cb570-4" tabindex="-1"></a>              <span class="at">attr2tb =</span> <span class="fu">c</span>(<span class="st">&quot;what.measured&quot;</span> <span class="ot">=</span> <span class="st">&quot;Filter type&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 3 × 3
##   spct.idx     UVA `Filter type`                                                
##   &lt;fct&gt;      &lt;dbl&gt; &lt;chr&gt;                                                        
## 1 none     1.00    theoretical fully transparent object                         
## 2 pet      0.782   Polyester, clear film, 0.000125 m thick, Autostat CT5 from M…
## 3 yellow   0.00160 Theatrical &#39;gel&#39;, type &#39;Canary Supergel no312; new; from Ros…</code></pre>
<p>We can add metadata attributes as a column, and select and rearrange
the columns.</p>
<div class="sourceCode" id="cb572"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb572-1"><a href="#cb572-1" tabindex="-1"></a><span class="fu">transmittance</span>(filters.mspct,</span>
<span id="cb572-2"><a href="#cb572-2" tabindex="-1"></a>              <span class="at">w.band =</span> UVA.wb,</span>
<span id="cb572-3"><a href="#cb572-3" tabindex="-1"></a>              <span class="at">attr2tb =</span> <span class="st">&quot;what.measured&quot;</span>)[ , <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>)]</span></code></pre></div>
<pre><code>## # A tibble: 3 × 2
##   what.measured                                                    `Tfr(wl)_UVA`
##   &lt;chr&gt;                                                                    &lt;dbl&gt;
## 1 theoretical fully transparent object                                   1.00   
## 2 Polyester, clear film, 0.000125 m thick, Autostat CT5 from McDe…       0.782  
## 3 Theatrical &#39;gel&#39;, type &#39;Canary Supergel no312; new; from Rosco,…       0.00160</code></pre>
</div>
</div>
<div id="normalized-difference-indexes" class="section level3">
<h3>Normalized difference indexes</h3>
<p>Like the ratios discussed above normalized differences are a way of
summarizing or describing the colour of light sources or objects
independently of the overall irradiance. As their name tells, they are
defined as differences relative to a sum.</p>
<p>Normalized difference indexes are used to summarize the spectral
characteristics of light or objects. They are most frequently used in
the analysis of spectral reflectance data in remote sensing.</p>
<p><span class="math display">\[NDI_{a, b} = \frac{R_a - R_b}{R_a +
R_b}\]</span></p>
<p>where <span class="math inline">\(R_a\)</span> and <span class="math inline">\(R_b\)</span> are reflectances computed from the
same spectrum using two different wavebands.</p>
<p>The most frequently used NDI is the NDVI or normalized difference
vegetation index, which compares reflectance in the red and far-red
regions as a way of assessing the presence of vegetation vs. bare land
in remote sensing imagery.</p>
<p>However, they can be computed based on energy or photon irradiances
for two wavebands as shown here, or for any other spectral quantity.</p>
<p><span class="math display">\[NDI_{a, b} = \frac{Q_a - Q_b}{Q_a +
Q_b}\]</span></p>
<p>where <span class="math inline">\(Q_a\)</span> and <span class="math inline">\(Q_b\)</span> are irradiances computed from the
same spectrum using two different wavebands.</p>
<p>Although we here describe how to compute normalized difference
indexes from spectral data, they are most frequently generated from data
from broad-band sensors in satellite, air-borne or terrestrial imagers.
To reconstruct from spectral data indexes computed from these
instruments we need to use waveband definitions that mimic the spectral
response of the imager of interest. Package ‘photobiologyWavebands’
provides pre-defined wavebands for several different satellite imagers
as well as for wavelength ranges in common use.</p>
<div id="individual-spectra-8" class="section level4">
<h4>Individual spectra</h4>
<p>Here we give an example of a possible definition of NDVI using
function <code>normalized_diff_ind()</code> can be used to calculate, or
any index with a similar formulation structure.</p>
<div class="sourceCode" id="cb574"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb574-1"><a href="#cb574-1" tabindex="-1"></a><span class="fu">normalized_diff_ind</span>(Ler_leaf_rflt.spct,</span>
<span id="cb574-2"><a href="#cb574-2" tabindex="-1"></a>                    <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">740</span>, <span class="dv">840</span>)), <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">590</span>, <span class="dv">690</span>)),</span>
<span id="cb574-3"><a href="#cb574-3" tabindex="-1"></a>                    reflectance)</span></code></pre></div>
<pre><code>## NDI reflectance [740.840] - [590.690] 
##                             0.7653852</code></pre>
<p>Here we give an <em>unusual</em> example to demonstrate that function
<code>normalized_diff_ind()</code> can be used to calculate any index
with a similar formulation structure and using other spectral quantities
and summary functions.</p>
<div class="sourceCode" id="cb576"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb576-1"><a href="#cb576-1" tabindex="-1"></a><span class="fu">normalized_diff_ind</span>(sun.spct,</span>
<span id="cb576-2"><a href="#cb576-2" tabindex="-1"></a>                    <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">600</span>, <span class="dv">700</span>)), <span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">400</span>, <span class="dv">500</span>)),</span>
<span id="cb576-3"><a href="#cb576-3" tabindex="-1"></a>                    q_irrad)</span></code></pre></div>
<pre><code>## NDI q_irrad [600.700] - [400.500] 
##                        0.09188363</code></pre>
</div>
</div>
<div id="integrated-response" class="section level3">
<h3>Integrated response</h3>
<p>As with other spectral quantities, we can integrate over wavelengths
spectral responsiveness. In response and action spectra the quantity is
a response measured in some arbitrary unit expressed per unit
wavelengths and per unit energy or quantum.</p>
<p><span class="math display">\[X_E = \int_{\lambda =
\lambda_1}^{\lambda = \lambda_2} X_E(\lambda)\
\mathrm{d}\lambda\]</span> where <span class="math inline">\(\lambda_1
\geq \lambda &gt; \lambda_2\)</span> defines a waveband, or range of
wavelengths.</p>
<p>The conversion between energy and photon (= quantum) basis of
expression is possible as it is for radiation spectra. Depending on the
base of expression the returned integrated value is computed
<strong>assuming</strong> either a light source with a flat spectral
energy irradiance of 1 or spectral photon irradiance of 1,
respectively.</p>
<div id="individual-spectra-9" class="section level4">
<h4>Individual spectra</h4>
<p>The functions <code>response</code>, <code>e_response</code> and
<code>q_response</code> take <code>response_spct</code> objects as
arguments. If no waveband is supplied as argument, the whole spectrum is
integrated.</p>
<div class="sourceCode" id="cb578"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb578-1"><a href="#cb578-1" tabindex="-1"></a><span class="fu">response</span>(photodiode.spct)</span></code></pre></div>
<pre><code>## R[/e]_Total 
##    24.40478 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy response&quot;</code></pre>
<p>When a waveband, or list of wavebands, is supplied the response is
calculated for the wavebands.</p>
<div class="sourceCode" id="cb580"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb580-1"><a href="#cb580-1" tabindex="-1"></a><span class="fu">e_response</span>(photodiode.spct, <span class="fu">list</span>(UVB.wb, UVA.wb))</span></code></pre></div>
<pre><code>## R[/e]_]UVB  R[/e]_UVA 
##   0.346462   5.981818 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy response&quot;</code></pre>
<p>This function has an additional argument <code>quantity</code>, with
default <code>&quot;total&quot;</code>, as described for <code>irrad()</code>.</p>
</div>
<div id="collections-of-spectra-7" class="section level4">
<h4>Collections of spectra</h4>
<div class="sourceCode" id="cb582"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb582-1"><a href="#cb582-1" tabindex="-1"></a>sensors <span class="ot">&lt;-</span> <span class="fu">response_mspct</span>(<span class="fu">list</span>(<span class="at">GaAsP =</span> photodiode.spct,</span>
<span id="cb582-2"><a href="#cb582-2" tabindex="-1"></a>                               <span class="at">CCD =</span> ccd.spct))</span>
<span id="cb582-3"><a href="#cb582-3" tabindex="-1"></a><span class="fu">response</span>(sensors, <span class="fu">list</span>(UVB.wb, UVA.wb, PAR.wb), <span class="at">quantity =</span> <span class="st">&quot;contribution&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 2 × 4
##   spct.idx `R/Rtot[/e]_]UVB` `R/Rtot[/e]_UVA` `R/Rtot[/e]_PAR[`
##   &lt;fct&gt;                &lt;dbl&gt;            &lt;dbl&gt;             &lt;dbl&gt;
## 1 GaAsP               0.0142           0.245              0.741
## 2 CCD                 0.0215           0.0634             0.411</code></pre>
</div>
</div>
<div id="integration-over-wavelengths" class="section level3">
<h3>Integration over wavelengths</h3>
<p>When we need to integrate some <code>numeric</code> variable stored
in a spectral object we can use functions <code>integrate_spct</code> or
<code>average_spct</code>.</p>
<div id="calculation-from-individual-spectra" class="section level4">
<h4>Calculation from individual spectra</h4>
<p>We can integrate the values of arbitrary <code>numeric</code> columns
other than <code>w.length</code> in an spectral object. All spectral
classes are derived from <code>generic_spct</code>, so the examples in
this section apply to objects of any of the derived spectral classes as
well.</p>
<div class="sourceCode" id="cb584"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb584-1"><a href="#cb584-1" tabindex="-1"></a><span class="fu">integrate_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>##      e.irrad      q.irrad 
## 2.691249e+02 1.255354e-03</code></pre>
<p>The function <code>average_spct</code> integrates every column
holding numeric values from a spectrum object, except for
<code>w.length</code>, and divides the result by the <em>spread</em> or
width of the wavelength range integrated, returning a value expressed in
the same units as the spectral data.</p>
<div class="sourceCode" id="cb586"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb586-1"><a href="#cb586-1" tabindex="-1"></a><span class="fu">average_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>##      e.irrad      q.irrad 
## 5.175479e-01 2.414142e-06</code></pre>
</div>
</div>
</div>
<div id="comparison-of-spectra" class="section level2">
<h2>Comparison of spectra</h2>
<p>Comparison of spectra for which data is expressed at different
discrete wavelength values can be easily affected by bias if
interpolation is used. Function <code>compare_spct()</code> does a
coarse grained comparison by first summarizing each spectrum over
consecutive ranges of wavelengths, and then applying a comparison
function to these summary values.</p>
<p>The function can be used to compare pairs of spectra, stored as a
collection. In the next example we compare two <code>source_spct</code>
objects using defaults for most arguments.</p>
<div class="sourceCode" id="cb588"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb588-1"><a href="#cb588-1" tabindex="-1"></a><span class="fu">compare_spct</span>(<span class="fu">source_mspct</span>(<span class="fu">list</span>(<span class="at">sun1 =</span> sun.spct, <span class="at">sun2 =</span> sun.spct <span class="sc">*</span> <span class="dv">2</span>)))</span></code></pre></div>
<pre><code>## Object: generic_spct [52 x 6]
## Wavelength range 285-795 nm, step 10 nm 
## Variables:
##   
## --
## # A tibble: 52 × 6
##   w.length wl.min wl.max sun1.irrad sun2.irrad comparison.result
##      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;             &lt;dbl&gt;
## 1      285    280    290    0          0                     NaN
## 2      295    290    300    0.00204    0.00407                 2
## 3      305    300    310    0.203      0.406                   2
## 4      315    310    320    1.13       2.26                    2
## # ℹ 48 more rows</code></pre>
<p>The value returned by default is a <code>generic_spct</code> object
containing the computed summaries for each waveband plus the result of
the comparison between the summaries. The first three columns contain
the wavelength at the midpoint of the wavelength range of waveband plus
its extremes.</p>
<p>In this example we compare two <code>filter_spct</code> objects,
using summaries over 50-nm-wide bands, and using an operator returning a
logical value for the comparison instead of the default division
operator.</p>
<div class="sourceCode" id="cb590"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb590-1"><a href="#cb590-1" tabindex="-1"></a><span class="fu">compare_spct</span>(<span class="fu">filter_mspct</span>(<span class="fu">list</span>(<span class="at">pet =</span> polyester.spct,</span>
<span id="cb590-2"><a href="#cb590-2" tabindex="-1"></a>                              <span class="at">yllw =</span> yellow_gel.spct)),</span>
<span id="cb590-3"><a href="#cb590-3" tabindex="-1"></a>             <span class="at">w.band =</span> <span class="dv">50</span>,</span>
<span id="cb590-4"><a href="#cb590-4" tabindex="-1"></a>            <span class="at">.comparison.fun =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>)</span></code></pre></div>
<pre><code>## Object: generic_spct [11 x 6]
## Wavelength range 265-765 nm, step 50 nm 
## Variables:
##   
## --
## # A tibble: 11 × 6
##   w.length wl.min wl.max pet.transmittance yllw.transmittance comparison.result
##      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;             &lt;dbl&gt;              &lt;dbl&gt; &lt;lgl&gt;            
## 1      265    240    290           0.00386          0.0000100 TRUE             
## 2      315    290    340           0.292            0.00220   TRUE             
## 3      365    340    390           0.861            0.000825  TRUE             
## 4      415    390    440           0.918            0.0000100 TRUE             
## # ℹ 7 more rows</code></pre>
</div>
<div id="illumination-and-light-as-seen-by-humans" class="section level2">
<h2>Illumination and light as seen by humans</h2>
<div id="illuminance" class="section level3">
<h3>Illuminance</h3>
<p>Illuminance, or luminous flux incident on a surface, is relevant to
human vision. It is an approximate quantity as the spectral response
function of human vision varies among individuals, with their age and
the conditions during measurement. The SI unit for illuminance is lux
(lx) or lumnes per square meter.</p>
<p>When function <code>illuminance()</code> is applied to spectral
(energy) irradiance or spectral photon irradiance, illuminance can be
directly computed using the same time base of 1 s.</p>
<div class="sourceCode" id="cb592"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb592-1"><a href="#cb592-1" tabindex="-1"></a><span class="fu">illuminance</span>(sun.spct)</span></code></pre></div>
<pre><code>##   Ev[lx] 
## 52191.33 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;scaled illuminance [lx]; CIE2deg&quot;</code></pre>
<p>The response of the human eye depends on the size of the target, and
response spectra have been defined by CIE for both 2 degrees and 10
degrees targets.</p>
<div class="sourceCode" id="cb594"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb594-1"><a href="#cb594-1" tabindex="-1"></a><span class="fu">illuminance</span>(sun.spct, <span class="at">std =</span> <span class="st">&quot;CIE10deg&quot;</span>)</span></code></pre></div>
<pre><code>##   Ev[lx] 
## 55066.41 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;scaled illuminance [lx]; CIE10deg&quot;</code></pre>
<p>If one attempts to compute illuminance from spectral fluence or
radiation spectra expressed as a flux of energy or photons over a period
of time different to 1 s, the average illuminance is returned, in
lux.</p>
<div class="sourceCode" id="cb596"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb596-1"><a href="#cb596-1" tabindex="-1"></a><span class="fu">illuminance</span>(sun_daily.spct)</span></code></pre></div>
<pre><code>##   Ev[lx] 
## 24475.59 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;mean illuminance [lx]; CIE2deg&quot;</code></pre>
</div>
<div id="cct-and-cri" class="section level3">
<h3>CCT and CRI</h3>
<p>Colour temperature and colour rendition index can be computed from
spectral irradiance. Package ‘colorSpec’ implement these and other
calcualtions related to colour. Package ‘photobiologyInOut’ provides
wrappers to facilitate the computation of CCT and CRI directly from
<code>source_spct</code> objects by on-the-fly conversion and calling
functions from ‘colorSpec’.</p>
</div>
<div id="rgb-colours" class="section level3">
<h3>RGB colours</h3>
<p>Different <code>color_of()</code> methods allow calculation of RGB
colour values for light sources or objects. The returned values are R
colour definitions. Method <code>color_of()</code> works rather
differently depending on the object. The method for <code>numeric</code>
vectors assumes the numbers are wavelengths in nanometres, and returns a
vector of colour definitions of the same length assuming monochromatic
light.</p>
<div class="sourceCode" id="cb598"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb598-1"><a href="#cb598-1" tabindex="-1"></a><span class="fu">color_of</span>(<span class="dv">550</span>) <span class="co"># green</span></span></code></pre></div>
<pre><code>## wl.550.nm.CMF 
##     &quot;#00FF00&quot;</code></pre>
<div class="sourceCode" id="cb600"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb600-1"><a href="#cb600-1" tabindex="-1"></a><span class="fu">color_of</span>(<span class="dv">630</span>) <span class="co"># red</span></span></code></pre></div>
<pre><code>## wl.630.nm.CMF 
##     &quot;#FF0000&quot;</code></pre>
<div class="sourceCode" id="cb602"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb602-1"><a href="#cb602-1" tabindex="-1"></a><span class="fu">color_of</span>(<span class="fu">c</span>(<span class="dv">550</span>, <span class="dv">630</span>, <span class="dv">380</span>, <span class="dv">750</span>)) <span class="co"># vectorized</span></span></code></pre></div>
<pre><code>## wl.550.nm.CMF wl.630.nm.CMF wl.380.nm.CMF wl.750.nm.CMF 
##     &quot;#00FF00&quot;     &quot;#FF0000&quot;     &quot;#000000&quot;     &quot;#000000&quot;</code></pre>
<p>The method for <code>source_spct</code> objects returns a single
colour definition corresponding to the whole spectrum of a light
sources.</p>
<div class="sourceCode" id="cb604"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb604-1"><a href="#cb604-1" tabindex="-1"></a><span class="fu">color_of</span>(sun.spct)</span></code></pre></div>
<pre><code>## source.CMF 
##  &quot;#544F4B&quot;</code></pre>
<div class="sourceCode" id="cb606"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb606-1"><a href="#cb606-1" tabindex="-1"></a><span class="fu">color_of</span>(sun.spct <span class="sc">*</span> yellow_gel.spct)</span></code></pre></div>
<pre><code>## source.CMF 
##  &quot;#946000&quot;</code></pre>
<p>There are no methods for <code>filter_spct</code> and
<code>reflector_spct</code> objects so as shown above we need to
convolve them with spectral irradiance from a <code>source_spct</code>
object.</p>
<p>The method for <code>waveband</code> objects returns one colour
definition per waveband, corresponding to their central wavelength.</p>
<div class="sourceCode" id="cb608"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb608-1"><a href="#cb608-1" tabindex="-1"></a><span class="fu">color_of</span>(<span class="fu">waveband</span>(<span class="fu">c</span>(<span class="dv">400</span>, <span class="dv">500</span>), <span class="at">wb.name =</span> <span class="st">&quot;my_BL&quot;</span>))</span></code></pre></div>
<pre><code>## my_BL.CMF 
## &quot;#000EFF&quot;</code></pre>
<p>By default CIE coordinates for <em>typical</em> human vision are
used, but the functions have a parameter that can be used for supplying
a different chromaticity definition as a <code>chroma_spct</code>
object.</p>
<div class="sourceCode" id="cb610"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb610-1"><a href="#cb610-1" tabindex="-1"></a><span class="fu">color_of</span>(sun.spct, <span class="at">chroma.type =</span> <span class="st">&quot;CC&quot;</span>)</span></code></pre></div>
<pre><code>## source.CC 
## &quot;#B63C37&quot;</code></pre>
<div class="sourceCode" id="cb612"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb612-1"><a href="#cb612-1" tabindex="-1"></a><span class="fu">color_of</span>(sun.spct, <span class="at">chroma.type =</span> <span class="st">&quot;CMF&quot;</span>)</span></code></pre></div>
<pre><code>## source.CMF 
##  &quot;#544F4B&quot;</code></pre>
<div class="sourceCode" id="cb614"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb614-1"><a href="#cb614-1" tabindex="-1"></a><span class="fu">color_of</span>(sun.spct, <span class="at">chroma.type =</span> beesxyzCMF.spct)</span></code></pre></div>
<pre><code>## source.chroma 
##     &quot;#CD1F11&quot;</code></pre>
<p>In the case of bees, the RGB values represent a shift towards longer
wavelengths compared to the true sensitivity. In other words, they are
translated into colours that humans can see and monitors and printers
can generate.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
