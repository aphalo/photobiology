<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Pedro J. Aphalo" />

<meta name="date" content="2020-06-05" />

<title>User Guide: 2 Radiation</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">User Guide: 2 Radiation</h1>
<h3 class="subtitle">Package ‘photobiology’ 0.10.4</h3>
<h4 class="author">Pedro J. Aphalo</h4>
<h4 class="date">2020-06-05</h4>


<div id="TOC">
<ul>
<li><a href="#spectra">Spectra</a><ul>
<li><a href="#getting-started">Getting started</a></li>
<li><a href="#classes">Classes</a></li>
<li><a href="#data-assumptions">Data assumptions</a></li>
<li><a href="#querying-the-class">Querying the class</a></li>
<li><a href="#construction">Construction</a></li>
<li><a href="#metadata-attributes">Metadata attributes</a></li>
</ul></li>
<li><a href="#collections-of-spectra">Collections of spectra</a><ul>
<li><a href="#classes-1">Classes</a></li>
<li><a href="#construction-1">Construction</a></li>
<li><a href="#conversion-into-a-wide-data-frame">Conversion into a “wide” data frame</a></li>
<li><a href="#querying-the-class-1">Querying the class</a></li>
<li><a href="#extract-replace-and-combine">Extract, replace and combine</a></li>
<li><a href="#transform-or-apply-functions">Transform or <em>apply</em> functions</a></li>
<li><a href="#summary-spectra">Summary spectra</a></li>
<li><a href="#convolution">Convolution</a></li>
<li><a href="#metadata-attributes-1">Metadata attributes</a></li>
</ul></li>
<li><a href="#wavebands">Wavebands</a><ul>
<li><a href="#construction-2">Construction</a></li>
<li><a href="#querying-the-class-2">Querying the class</a></li>
<li><a href="#retrieving-properties">Retrieving properties</a></li>
</ul></li>
<li><a href="#collections-of-wavebands">Collections of wavebands</a><ul>
<li><a href="#construction-3">Construction</a></li>
</ul></li>
<li><a href="#object-inspection-methods">Object <em>inspection</em> methods</a><ul>
<li><a href="#printing">Printing</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#handling-nas">Handling <code>NA</code>s</a></li>
</ul></li>
<li><a href="#transformations-using-operators">Transformations: using operators</a><ul>
<li><a href="#binary-operators">Binary operators</a></li>
<li><a href="#unary-operators-and-maths-functions">Unary operators and maths functions</a></li>
<li><a href="#options">Options</a></li>
</ul></li>
<li><a href="#transformations-methods-and-functions">Transformations: methods and functions</a><ul>
<li><a href="#manipulating-spectra">Manipulating spectra</a></li>
<li><a href="#conversions-between-radiation-units">Conversions between radiation units</a></li>
<li><a href="#conversions-among-transmission-quantities">Conversions among transmission quantities</a></li>
<li><a href="#normalizing-a-spectrum">Normalizing a spectrum</a></li>
<li><a href="#rescaling-a-spectrum">Rescaling a spectrum</a></li>
<li><a href="#shifting-the-zero-of-the-spectral-data-scale">Shifting the zero of the spectral data scale</a></li>
<li><a href="#replacing-off-range-spectral-data-values">Replacing off-range spectral data values</a></li>
<li><a href="#removing-spikes">Removing spikes</a></li>
<li><a href="#smoothing-of-spectra">Smoothing of spectra</a></li>
<li><a href="#wavelength-interpolation">Wavelength interpolation</a></li>
<li><a href="#trimming-clipping-and-thining">Trimming, clipping and thining</a></li>
<li><a href="#convolving-weights">Convolving weights</a></li>
<li><a href="#tagging-with-bands-and-colours">Tagging with bands and colours</a></li>
</ul></li>
<li><a href="#summaries">Summaries</a><ul>
<li><a href="#summary-1">Summary</a></li>
<li><a href="#wavelength">Wavelength</a></li>
<li><a href="#peaks-valleys-and-spikes">Peaks, valleys and spikes</a></li>
<li><a href="#wavelengths-at-target-value">Wavelengths at target value</a></li>
<li><a href="#irradiance">Irradiance</a></li>
<li><a href="#fluence">Fluence</a></li>
<li><a href="#photon-and-energy-ratios">Photon and energy ratios</a></li>
<li><a href="#normalized-difference-indexes">Normalized difference indexes</a></li>
<li><a href="#individual-spectra-7">Individual spectra</a></li>
<li><a href="#transmittance-reflectance-absorptance-and-absorbance">Transmittance, reflectance, absorptance and absorbance</a></li>
<li><a href="#integrated-response">Integrated response</a></li>
<li><a href="#integration-over-wavelengths">Integration over wavelengths</a></li>
</ul></li>
<li><a href="#comparison-of-spectra">Comparison of spectra</a></li>
<li><a href="#rgb-colours">RGB colours</a></li>
</ul>
</div>

<div id="spectra" class="section level2">
<h2>Spectra</h2>
<p>Package ‘<strong>photobiology</strong>’ defines a family of classes based on the <code>tibble</code> class, mostly compatible with R’s data frames. The present package by imposing some restrictions on the naming of the member vectors, allows methods to <em>find</em> the data when passed one of these objects as argument. In addition, as the data are checked when the object is built or modified, there is no need to test for their validity each time a calculation is carried out. Other advantage of using spectrum objects, is that specialized versions of generic functions like <code>print</code> and operators like <code>+</code> are defined for spectra. <code>___spct</code> objects are also <code>tibble</code> and <code>data.frame</code> objects, as a result of how classes have been derived. In this package we define a <em>generic</em> or <em>base</em> spectrum class, derived from <code>tibble</code>, which in turn has been derived from <code>data.frame</code>. Classes for specialized types of spectra are derived from <code>generic_spct</code>. This <em>parenthood</em> hierarchy means that spectra objects can be used almost anywhere where a <code>data.frame</code> is expected. Specializations of many methods including extraction (indexing) methods and partial assignment methods are defined to ensure that the expectations on the variables contained in objects of these classes is guaranteed in most situations. Other specializations of methods and functions are related to achieving a convenient and concise syntax tailored for spectral data as in the case of mathematical operators and functions.</p>
<p>Another important aspect is that when spectral data are stored in objects of these classes, the physical quantities and units of expression are known. Furthermore, attributes are used to keep track of both metadata related to the origin of the data and of later transformations that affect their interpretation, such as normalization or re-scaling. Although sanity tests are applied at the time of object creation, to a large extent the responsibility of ensuring that the numbers provided as argument to object constructors comply with expectations remains with the users of the package.</p>
<p>In addition to the classes for storing individual spectra, classes for storing collections of spectra are defined. These classes are derived from class <code>list</code> and can contain member spectra of different lengths and measured at different wavelength values.</p>
<p>We give in this vignette brief descriptions and examples of the use of different classes, methods, functions and operators. We start with the simplest and most frequently used methods.</p>
<div id="getting-started" class="section level3">
<h3>Getting started</h3>
<p>We load two packages in addition to ‘<strong>photobiology</strong>’, ‘<strong>lubridate</strong>’ and ‘<strong>dplyr</strong>’, as they will be used in the examples.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(photobiology)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">library</span>(lubridate)</span></code></pre></div>
<pre><code>## 
## Attaching package: &#39;lubridate&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     date, intersect, setdiff, union</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">library</span>(dplyr)</span></code></pre></div>
<pre><code>## 
## Attaching package: &#39;dplyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union</code></pre>
</div>
<div id="classes" class="section level3">
<h3>Classes</h3>
<p>Package ‘<strong>photobiology</strong>’ defines several classes intended to be used to store different types of spectral data. They are all derived from <code>generic_spct</code>, which in turn is derived from <code>tibble::tibble</code>. Table 1 lists these classes. Attributes are used in objects of these classes to store <em>metadata</em> such as information about units of expression.</p>
<hr>
<p><strong>Table 1. Classes for spectral data.</strong> In addition to the required variables listed in the table, additional arbitrary variables are partly supported—some operations will not include them in returned values to avoid ambiguity and other possible conflicts. In addition to the attributes listed in the table, all spectral objects support attributes <code>multiple.wl</code>, <code>idfactor</code>, <code>normalized</code>, <code>scaled</code>, <code>when.measured</code>, <code>where.measured</code>, <code>what.measured</code>, <code>how.measured</code> plus the normal attributes of <code>tibble</code> (and <code>data.frame</code>) objects including <code>comment</code>. All these attributes plus attributes <code>instrument.descriptor</code> and <code>instrument.settings</code> are retained across operations on spectra as long as they remain valid.</p>
<table>
<colgroup>
<col width="21%"></col>
<col width="29%"></col>
<col width="49%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Class name</th>
<th align="left">Required variables</th>
<th align="left">Attributes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>generic_spct</code></td>
<td align="left"><code>w.length</code></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>calibration_spct</code></td>
<td align="left"><code>w.length</code>, <code>irrad.mult</code></td>
<td align="left"><code>instr.desc</code></td>
</tr>
<tr class="odd">
<td align="left"><code>raw_spct</code></td>
<td align="left"><code>w.length</code>, <code>counts</code></td>
<td align="left"><code>instr.desc</code>, <code>instr.settings</code>, <code>linearized</code></td>
</tr>
<tr class="even">
<td align="left"><code>cps_spct</code></td>
<td align="left"><code>w.length</code>, <code>cps</code></td>
<td align="left"><code>instr.desc</code>, <code>instr.settings</code>, <code>linearized</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="left"><code>w.length</code>, <code>s.e.irrad</code></td>
<td align="left"><code>instr.desc</code>, <code>instr.settings</code>, <code>time.unit</code>, <code>bswf</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>w.length</code>, <code>s.q.irrad</code></td>
<td align="left"><code>time.unit</code>, <code>bswf</code></td>
</tr>
<tr class="odd">
<td align="left"><code>filter_spct</code></td>
<td align="left"><code>w.length</code>, <code>Tfr</code></td>
<td align="left"><code>Tfr.type</code>, <code>filterProperties</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>w.length</code>, <code>A</code></td>
<td align="left"><code>Tfr.type</code>, <code>filterProperties</code></td>
</tr>
<tr class="odd">
<td align="left"><code>reflector_spct</code></td>
<td align="left"><code>w.length</code>, <code>Rfr</code></td>
<td align="left"><code>Rfr.type</code></td>
</tr>
<tr class="even">
<td align="left"><code>object_spct</code></td>
<td align="left"><code>w.length</code>, <code>Tfr</code>, <code>Rfr</code></td>
<td align="left"><code>Tfr.type</code>, <code>Rfr.type</code></td>
</tr>
<tr class="odd">
<td align="left"><code>response_spct</code></td>
<td align="left"><code>w.length</code>, <code>s.e.response</code></td>
<td align="left"><code>time.unit</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>w.length</code>, <code>s.q.response</code></td>
<td align="left"><code>time.unit</code></td>
</tr>
<tr class="odd">
<td align="left"><code>chroma_spct</code></td>
<td align="left"><code>w.length</code>, <code>x</code>, <code>y</code>, <code>z</code></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<hr>
<p>The <em>design</em> imposes the restriction that data from different observations are never present as different <em>data columns</em>, if present, additional data columns represent different properties from the same observation event. In other words, the storage format is <em>tidy</em> as defined by Hadley Wickham. In most cases, one spectral object should correspond to one spectral observation, but some functions are compatible or can be used to create spectral objects where the spectral data from different observations are stored “longitudinally” and “tagged” with a factor with a level for each observation event. These observations must use consistent units of expression and attribute values. This long format is useful, for example, when producing plots with package ‘ggplot2’. If spectra are stored in <em>long form</em>, e.g. for plotting with ‘ggplot2’, attributes are stored as named lists or enforced to be the same across spectra. This allows to reconstruct a collection of spectra from a long-form spectral object and <em>vice versa</em> preserving most of the metadata.</p>
</div>
<div id="data-assumptions" class="section level3">
<h3>Data assumptions</h3>
<p>A key assumption of the package is that wavelengths are always expressed in manometers (<span class="math inline">\(1~\mathrm{nm} = 1 \cdot 10^{-9}\,\mathrm{m}\)</span>). If the data to be analyzed use different units for wavelengths, e.g. Ångstrom (<span class="math inline">\(1~\textrm{Å} = 1 \cdot 10^{-10}\,\mathrm{m}\)</span>), the values need to be re-scaled before creating objects of the spectral classes. The same applies to all spectral quantities, as there is an expectation in every case, of using base SI units for expression. Table 2 lists the units of expression for the different variables and the metadata attributes that may determine variations in the expression of the quantities.</p>
<hr>
<p><strong>Table 2. Variables used for spectral data and their units of expression.</strong> <strong>A:</strong> as stored in objects of the spectral classes, <strong>B:</strong> also recognized by the <code>set</code> family of functions for spectra and automatically converted. <code>time.unit</code> accepts in addition to the character strings listed in the table, objects of classes <code>lubridate::duration</code> and <code>period</code>, in addition <code>numeric</code> values are interpreted as seconds. <code>exposure.time</code> accepts these same values, but not the character strings.</p>
<table>
<thead>
<tr class="header">
<th align="left">Variables</th>
<th align="left">Unit of expression</th>
<th align="left">Attribute value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>A: stored</strong></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">w.length</td>
<td align="left">nm</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">counts</td>
<td align="left"><span class="math inline">\(n\)</span></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">cps</td>
<td align="left"><span class="math inline">\(n\,s^{-1}\)</span></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">irrad.mult</td>
<td align="left"><span class="math inline">\(J\,m^{-2}\,nm^{-1}\,n^{-1}\)</span></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">s.e.irrad</td>
<td align="left"><span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “second”</td>
</tr>
<tr class="odd">
<td align="left">s.e.irrad</td>
<td align="left"><span class="math inline">\(J\,m^{-2}\,d^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “day”</td>
</tr>
<tr class="even">
<td align="left">s.e.irrad</td>
<td align="left">varies</td>
<td align="left">time.unit = <em>duration</em></td>
</tr>
<tr class="odd">
<td align="left">s.q.irrad</td>
<td align="left"><span class="math inline">\(mol\,m^{-2}\,s^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “second”</td>
</tr>
<tr class="even">
<td align="left">s.q.irrad</td>
<td align="left"><span class="math inline">\(mol\,m^{-2}\,d^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “day”</td>
</tr>
<tr class="odd">
<td align="left">s.q.irrad</td>
<td align="left"><span class="math inline">\(mol\,m^{-2}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “exposure”</td>
</tr>
<tr class="even">
<td align="left">s.q.irrad</td>
<td align="left">varies</td>
<td align="left">time.unit = <em>duration</em></td>
</tr>
<tr class="odd">
<td align="left">Tfr</td>
<td align="left">[0,1]</td>
<td align="left">Tfr.type = “total”</td>
</tr>
<tr class="even">
<td align="left">Tfr</td>
<td align="left">[0,1]</td>
<td align="left">Tfr.type = “internal”</td>
</tr>
<tr class="odd">
<td align="left">A</td>
<td align="left">a.u.</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">Afr</td>
<td align="left">[0,1]</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">Rfr</td>
<td align="left">[0,1]</td>
<td align="left">Rfr.type = “total”</td>
</tr>
<tr class="even">
<td align="left">Rfr</td>
<td align="left">[0,1]</td>
<td align="left">Rfr.type = “specular”</td>
</tr>
<tr class="odd">
<td align="left">s.e.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,J^{-1}\,s^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “second”</td>
</tr>
<tr class="even">
<td align="left">s.e.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,mol^{-1}\,d^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “day”</td>
</tr>
<tr class="odd">
<td align="left">s.e.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,J^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “exposure”</td>
</tr>
<tr class="even">
<td align="left">s.e.response</td>
<td align="left">varies</td>
<td align="left">time.unit = <em>duration</em></td>
</tr>
<tr class="odd">
<td align="left">s.q.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,mol^{-1}\,s^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “second”</td>
</tr>
<tr class="even">
<td align="left">s.q.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,mol^{-1}\,d^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “day”</td>
</tr>
<tr class="odd">
<td align="left">s.q.response</td>
<td align="left"><span class="math inline">\(\mathit{x}\,mol^{-1}\,nm^{-1}\)</span></td>
<td align="left">time.unit = “exposure”</td>
</tr>
<tr class="even">
<td align="left">s.q.response</td>
<td align="left">varies</td>
<td align="left">time.unit = <em>duration</em></td>
</tr>
<tr class="odd">
<td align="left">x, y, z</td>
<td align="left">[0,1]</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><strong>B: converted</strong></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">wl <span class="math inline">\(\to\)</span> w.length</td>
<td align="left">nm</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">wavelength <span class="math inline">\(\to\)</span> w.length</td>
<td align="left">nm</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">Tpc <span class="math inline">\(\to\)</span> Tfr</td>
<td align="left">[0,100]</td>
<td align="left">Tfr.type = “total”</td>
</tr>
<tr class="even">
<td align="left">Tpc <span class="math inline">\(\to\)</span> Tfr</td>
<td align="left">[0,100]</td>
<td align="left">Tfr.type = “internal”</td>
</tr>
<tr class="odd">
<td align="left">Rpc <span class="math inline">\(\to\)</span> Rfr</td>
<td align="left">[0,100]</td>
<td align="left">Rfr.type = “total”</td>
</tr>
<tr class="even">
<td align="left">Rpc <span class="math inline">\(\to\)</span> Rfr</td>
<td align="left">[0,100]</td>
<td align="left">Rfr.type = “specular”</td>
</tr>
<tr class="odd">
<td align="left">counts.per.second <span class="math inline">\(\to\)</span> cps</td>
<td align="left"><span class="math inline">\(n\,s^{-1}\)</span></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<hr>
<p>Energy irradiance is assumed to be expressed in <span class="math inline">\(W\,m^{-2}\)</span> and photon irradiances in <span class="math inline">\(mol^{-1}\,m^{-2}\,s^{-1}\)</span>, that is to say using second as unit for time and no SI scale factors for the measured variables. With respect to time, second is the default, but it is possible to set the unit for time to an arbitrary time duration such as day. Obviously, this applies only to rate variables like irradiance and response rates, but not to time-invariant intensive properties like transmittance of filters.</p>
<p>The default time unit used is <em>second</em>, but <em>minute</em>, <em>hour</em>, <em>day</em> and <em>exposure</em> can be used by supplying as arguments <code>&quot;minute&quot;</code>, <code>&quot;hour&quot;</code>, <code>&quot;day&quot;</code>, or <code>&quot;exposure&quot;</code>—The meaning of <code>&quot;exposure&quot;</code> is the total exposure time, in other words, fluence instead of irradiance—to the constructor <code>source_spct()</code>. In addition to these character constants objects of class <code>lubridate:duration</code> are also accepted.</p>
<p>Most attributes are set when a spectral object is created, either using default values or with values supplied as arguments to the constructor. However, methods for querying and setting these attributes are also available.</p>
<hr>
Not respecting the expectations about data inputs or setting erroneous values in the metadata attributes will yield completely wrong results if calculations are attempted! It is extremely important to make sure that the wavelengths are in nanometres as this is what all functions expect. If wavelength values are in the wrong units, the action-spectra weights and quantum to/from energy units conversions will be wrongly calculated, and the values returned by most functions wrong, without warning. Errors in some cases will be triggered at the time of object creation as the data input to constructors is tested to be within the expected range of values, which in the case of some quantities frequently allows detection of mistakes in the use unit scaling factors._
<hr>
<p>If spectral irradiance data is in <span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span>, and the wavelength in nm, as is the case for many Macam spectroradiometers, the data can be used directly and functions in the package will return irradiances in <span class="math inline">\(W\,m^{-2}\)</span>.</p>
<p>If, for example, the spectral irradiance data output by a spectroradiometer is expressed in <span class="math inline">\(mW\,m^{-2}\,nm^{-1}\)</span>, and the wavelengths are in Ångstrom then to obtain correct results when using any of the packages in the suite, we need to rescale the data when creating a new object.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># not run</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>my.spct &lt;-<span class="st"> </span><span class="kw">source_spct</span>(<span class="dt">w.length =</span> wavelength<span class="op">/</span><span class="dv">10</span>, <span class="dt">s.e.irrad =</span> irrad<span class="op">/</span><span class="dv">1000</span>)</span></code></pre></div>
<p>In the example above, we take advantage of the behavior of the R language: an operation between a scalar and a vector, is equivalent to applying this operation to each element of the vector. Consequently, in the code above, each value from the vector of wavelengths is divided by 10, and each value in the vector of spectral irradiances is divided by 1000.</p>
</div>
<div id="querying-the-class" class="section level3">
<h3>Querying the class</h3>
<p>Before giving examples of how to construct objects to store spectral data we show how to query the class of an object, and how to query the class of a spectrum. Consistently with R, the package provides <em>is</em> functions for querying the type of spectra objects. The only <em>unusual</em> function name, defined as a <em>synonym</em> for <code>is.generic_spct</code>: <code>is.any_spct()</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">is.any_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">is.generic_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">is.source_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>In addition function <code>class_spct()</code> returns directly the spectrum-related class attributes—i.e. it filters out from the output of <code>class()</code> the underlying inherited classes.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">class_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] &quot;source_spct&quot;  &quot;generic_spct&quot;</code></pre>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">class</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] &quot;source_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;</code></pre>
</div>
<div id="construction" class="section level3">
<h3>Construction</h3>
<p>There are two different approaches to the creation of spectral objects by users. The first group are constructors similar to the <code>data.frame()</code> constructor, which take vectors as arguments. The second group are constructors that convert <code>list</code> objects, and because of class derivation also <code>data.frame</code> objects, into spectral objects. Constructors in this second group are similar to <code>as.data.frame</code> from base R. In contrast to the data frame constructors, spectral object constructors require the variables or the vector arguments to be suitably named so that they can be recognized.</p>
<p>Here we briefly describe the <em>as</em> constructor functions for spectra. In the first example we create an object to store spectral irradiance data for a <em>fictitious light source</em>, by first creating a data frame, and creating the spectral object as a copy of it. In the example below we supply a single value, 1, for the spectral irradiance. This value gets recycled as is normal in R, but of course in real use it is more usual to supply a vector of the same length as the <code>w.length</code> vector.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>my.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">w.length =</span> <span class="dv">400</span><span class="op">:</span><span class="dv">410</span>, <span class="dt">s.e.irrad =</span> <span class="dv">1</span>)</span>
<span id="cb19-2"><a href="#cb19-2"></a>my.spct &lt;-<span class="st"> </span><span class="kw">as.source_spct</span>(my.df)</span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="kw">class</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] &quot;source_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">class</span>(my.df)</span></code></pre></div>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a>my.spct</span></code></pre></div>
<pre><code>## Object: source_spct [11 x 2]
## Wavelength range 400 to 410 nm, step 1 nm 
## Time unit 1s
## 
## # A tibble: 11 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      400         1
## 2      401         1
## 3      402         1
## 4      403         1
## # ... with 7 more rows</code></pre>
<p>We can make a `generic_spct’ copy of any spectrum object.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>my.g.spct &lt;-<span class="st"> </span><span class="kw">as.generic_spct</span>(my.spct)</span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">class</span>(my.g.spct)</span></code></pre></div>
<pre><code>## [1] &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;</code></pre>
<p>When constructing spectral objects from numeric vectors the names of the arguments are meaningful and convey information on the nature of the spectral data and basis of expression.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">source_spct</span>(<span class="dt">w.length =</span> <span class="dv">300</span><span class="op">:</span><span class="dv">305</span>, <span class="dt">s.e.irrad =</span> <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 2]
## Wavelength range 300 to 305 nm, step 1 nm 
## Time unit 1s
## 
## # A tibble: 6 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      300         1
## 2      301         1
## 3      302         1
## 4      303         1
## 5      304         1
## 6      305         1</code></pre>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a>z &lt;-<span class="st"> </span><span class="dv">300</span><span class="op">:</span><span class="dv">305</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>y &lt;-<span class="st"> </span><span class="dv">2</span></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="kw">source_spct</span>(<span class="dt">w.length =</span> z, <span class="dt">s.e.irrad =</span> y)</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 2]
## Wavelength range 300 to 305 nm, step 1 nm 
## Time unit 1s
## 
## # A tibble: 6 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      300         2
## 2      301         2
## 3      302         2
## 4      303         2
## 5      304         2
## 6      305         2</code></pre>
<p>When argument names are not supplied explicitly as above, the names of the variables are used to identify the data vectors.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a>w.length &lt;-<span class="st"> </span><span class="dv">300</span><span class="op">:</span><span class="dv">305</span></span>
<span id="cb31-2"><a href="#cb31-2"></a>s.e.irrad &lt;-<span class="st"> </span><span class="dv">1</span></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="kw">source_spct</span>(w.length, s.e.irrad)</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 2]
## Wavelength range 300 to 305 nm, step 1 nm 
## Time unit 1s
## 
## # A tibble: 6 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      300         1
## 2      301         1
## 3      302         1
## 4      303         1
## 5      304         1
## 6      305         1</code></pre>
<p>The different constructors have additional arguments to be used in setting non-default values for the attributes. These arguments have the same name as the attributes. Here we used the data frame created in the first code chunk of this section.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a>my.d.spct &lt;-<span class="st"> </span><span class="kw">as.source_spct</span>(my.df, <span class="dt">time.unit =</span> <span class="st">&quot;day&quot;</span>)</span></code></pre></div>
<p>Argument <code>strict.range</code> can be used to override or make more strict the validation of the data values.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">source_spct</span>(<span class="dt">w.length =</span> <span class="dv">300</span><span class="op">:</span><span class="dv">305</span>, <span class="dt">s.e.irrad =</span> <span class="dv">-1</span>)</span></code></pre></div>
<pre><code>## Warning in range_check(x, strict.range = strict.range): Negative spectral energy
## irradiance values; minimum s.e.irrad = -1.00</code></pre>
<pre><code>## Object: source_spct [6 x 2]
## Wavelength range 300 to 305 nm, step 1 nm 
## Time unit 1s</code></pre>
<pre><code>## Warning in range_check(x, strict.range = strict.range): Negative spectral energy
## irradiance values; minimum s.e.irrad = -1.00</code></pre>
<pre><code>## # A tibble: 6 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      300        -1
## 2      301        -1
## 3      302        -1
## 4      303        -1
## 5      304        -1
## 6      305        -1</code></pre>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">source_spct</span>(<span class="dt">w.length =</span> <span class="dv">300</span><span class="op">:</span><span class="dv">305</span>, <span class="dt">s.e.irrad =</span> <span class="dv">-1</span>, <span class="dt">strict.range =</span> <span class="ot">NULL</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 2]
## Wavelength range 300 to 305 nm, step 1 nm 
## Time unit 1s</code></pre>
<pre><code>## Warning in range_check(x, strict.range = strict.range): Negative spectral energy
## irradiance values; minimum s.e.irrad = -1.00</code></pre>
<pre><code>## # A tibble: 6 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      300        -1
## 2      301        -1
## 3      302        -1
## 4      303        -1
## 5      304        -1
## 6      305        -1</code></pre>
<p>Finally argument <code>comment</code> can be used to add a comment to the data at the time of construction.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a>my.cm.spct &lt;-<span class="st"> </span><span class="kw">source_spct</span>(<span class="dt">w.length =</span> <span class="dv">300</span><span class="op">:</span><span class="dv">305</span>, <span class="dt">s.e.irrad =</span> <span class="dv">1</span>,</span>
<span id="cb43-2"><a href="#cb43-2"></a>                          <span class="dt">comment =</span> <span class="st">&quot;This is a comment&quot;</span>)</span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="kw">comment</span>(my.cm.spct)</span></code></pre></div>
<pre><code>## [1] &quot;This is a comment&quot;</code></pre>
</div>
<div id="metadata-attributes" class="section level3">
<h3>Metadata attributes</h3>
<p>Metadata attributes are used in the spectral objects to store metadata in a consistently. These metadata are in some cases required for conversion among related physical quantities, while in other cases allow printing of ancillary information needed for interpretation, like units of expression. These metadata are also used in other packages in the suite, for example in ‘ggspectra’ to automatically produce axis labels, titles and annotations. A few attributes are simply a way or organizing the storage of information which is not used in any calculations, functioning as a kind of specialized comments. The metadata described in this section are stored in spectral objects using attributes, which are a normal feature of the R language. An example, is attribute <code>time.unit</code> used to indicate if spectral irradiance is expressed per second or integrated over some other time duration.</p>
<div id="attributes-supported-by-all-spectral-objects" class="section level4">
<h4>Attributes supported by all spectral objects</h4>
<p>Some attributes are meaningful for all the classes of spectra defined in the package, while most others a specific to individual classes (Table 1). Those that apply to all spectral objectsa and their summaries are <em>time of measurement</em> using attribute <code>&quot;when.measured&quot;</code>, <em>place of measurement</em> using attribute <code>&quot;where.measured&quot;</code>, a <em>user supplied label</em> using attribute <code>&quot;what.measured&quot;</code>, a label describing origin of the data using attribute <code>&quot;how.measured&quot;</code> and free-text <em>comments</em>. One can set and get comments stored in spectra by means of base R’s <code>comment()</code> and <code>comment() &lt;-</code> functions and the other attributes listed above with functions following the same syntax and named after the attributes but replacing any <code>.</code> by <code>_</code>. Functions in this package may set additional attributes to keep track of the actions. For example when a spectrum is normalized or scaled a record of these action is kept in attributes. When spectra are are operated upon the metadata that is not invalidated will be merged when possible—e.g., comments of operands are concatenated comments and set as comment to the returned object.</p>
<p>Functions <code>when_measured()</code> and <code>when_measured&lt;-()</code> are used for retrieving and setting the <code>&quot;when.measured&quot;</code> attribute to a date supplied as a <code>POSIXct</code> value. Note: we use <code>POSIXct</code> objects which describes instants in time in absolute terms as they include time zone information. Package <code>lubridate</code> makes entering and operating on <code>POSIXct</code> objects rather easy.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1"></a>my.spct &lt;-<span class="st"> </span>sun.spct</span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="kw">when_measured</span>(my.spct) &lt;-<span class="st">  </span><span class="ot">NULL</span></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="kw">when_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] NA</code></pre>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">when_measured</span>(my.spct) &lt;-<span class="st"> </span>lubridate<span class="op">::</span><span class="kw">ymd_hms</span>(<span class="st">&quot;2015-10-31 22:55:00&quot;</span>, <span class="dt">tz =</span> <span class="st">&quot;EET&quot;</span>)</span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="kw">when_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] &quot;2015-10-31 20:55:00 UTC&quot;</code></pre>
<p>Functions <code>where_measured()</code> and <code>where_measured&lt;-()</code> are used for retrieving and setting a geocode stored in a <code>data.frame</code>. This format is compatible with function <code>geocode()</code> from package <code>ggmap</code>. We pass latitude and longitude coordinates, as shown below. The returned value is always a data frame with columns <code>&quot;lon&quot;</code>, <code>&quot;lat&quot;</code> and <code>&quot;address&quot;</code>.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">where_measured</span>(my.spct) &lt;-<span class="st"> </span><span class="ot">NULL</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="kw">where_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## # A tibble: 1 x 3
##     lon   lat address
##   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  
## 1    NA    NA &lt;NA&gt;</code></pre>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">where_measured</span>(my.spct) &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">lat =</span> <span class="dv">60</span>, <span class="dt">lon =</span> <span class="dv">-10</span>)</span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="kw">where_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## # A tibble: 1 x 3
##     lat   lon address
##   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  
## 1    60   -10 &lt;NA&gt;</code></pre>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">where_measured</span>(my.spct) &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">lat =</span> <span class="dv">60</span>, <span class="dt">lon =</span> <span class="dv">-10</span>, <span class="dt">address =</span> <span class="st">&quot;Somewhere&quot;</span>)</span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="kw">where_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## # A tibble: 1 x 3
##     lat   lon address  
##   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    
## 1    60   -10 Somewhere</code></pre>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1"></a>my.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2015-10-31 20:55:00 UTC 
## Measured at 60 N, -10 E; Somewhere 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<p>Functions <code>what_measured()</code> and <code>where_measured&lt;-()</code>, and <code>how_measured()</code> and <code>how_measured&lt;-()</code> are used for retrieving or setting a text value containing information about what was measured to obtain the data.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1"></a><span class="kw">what_measured</span>(my.spct) &lt;-<span class="st"> &quot;something&quot;</span></span>
<span id="cb57-2"><a href="#cb57-2"></a><span class="kw">what_measured</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] &quot;something&quot;</code></pre>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1"></a>my.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: something 
## Measured on 2015-10-31 20:55:00 UTC 
## Measured at 60 N, -10 E; Somewhere 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<p>Functions using a different syntax are also available, for these and other attributes which are not likely to be set by users. Many of these additional attributes are meaningful only some types of spectra.</p>
</div>
<div id="attributes-supported-by-source_spct-objects" class="section level4">
<h4>Attributes supported by <code>source_spct</code> objects</h4>
<p>One example is the time unit used to express spectral irradiance. Functions are available for querying and setting the state if these attributes. <code>is_</code> functions return a logical value, and <code>get</code> functions return the values of the attributes themselves. In addition <code>set</code> functions can be used to set the value stored in the attributes. Several of the <code>set</code> functions are very rarely needed in user code, as these attributes are set during construction or as a side effect of applying other functions and/or operators to the objects. Function <code>setBSWFUsed()</code> and other <em>set</em> functions are mainly useful to programmers extending the package, but only exceptionally to users. One exception is the case when a wrong value has been assigned by mistake and needs to be overwritten.</p>
<p>We can see in the printout that the time unit is reported in the header.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1"></a>sun.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<p>For example function <code>is_effective()</code> returns <code>TRUE</code> if the spectral data has been weighted with a BSWF. The corresponding <code>getBSWFUsed()</code> function can be used, in this case to retrieve the name of the BSWF that was used. Here we demonstrate with one example, where we use a <code>waveband</code> object—constructed on-the-fly with a constructor function—, defining a range of wavelengths.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1"></a><span class="kw">is_effective</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1"></a><span class="kw">is_effective</span>(sun.spct <span class="op">*</span><span class="st"> </span><span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">400</span>, <span class="dv">700</span>)))</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Sometimes it may be desired to change the time unit used for expressing spectral irradiance or spectral response, and this can be achieved with the <em>conversion</em> function <code>convertTimeUnit</code>. This function both converts spectral data to the new unit of expression and sets the <code>time.unit</code> attribute, preserving the validity of the data object.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1"></a>ten.minutes.spct &lt;-</span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="st">  </span><span class="kw">convertTimeUnit</span>(sun.spct, <span class="dt">time.unit =</span> <span class="kw">duration</span>(<span class="dv">10</span>, <span class="st">&quot;minutes&quot;</span>))</span>
<span id="cb67-3"><a href="#cb67-3"></a>ten.minutes.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 600s (~10 minutes)
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1"></a><span class="kw">getTimeUnit</span>(ten.minutes.spct)</span></code></pre></div>
<pre><code>## [1] &quot;600s (~10 minutes)&quot;</code></pre>
</div>
<div id="attributes-supported-by-filter_spct-objects" class="section level4">
<h4>Attributes supported by <code>filter_spct</code> objects</h4>
<p>A crucial information is whether transmittance (<code>Tfr</code>) is expressed as internal or total, stored in attribute <code>Tfr.type</code>, as this affects how absorptances and absorbances are computed. The key step is when a <code>filter_spct</code> object is created, when the user has to be careful to set this attribute correctly.</p>
<p>The objects from which transmittance can differ in additional properties that affect possible calculations. Attribute <code>filter.properties</code> is used to store these in an object with fields <code>Rfr.constant</code>, <code>thickness</code> and <code>attenuation.mode</code>. When these metadata are available, in many cases we can use function <code>convertTfrType()</code> to convert internal transmittance into total transmittance and <em>vice versa</em> and function <code>convertThickness()</code> to compute the spectral transmittance of a filter of the same material but different thickness.</p>
<p>These attributes are also allowed in the case of <code>object_spct</code> and <code>reflector_spct</code> and retained during class conversions between them and <code>filter_spct</code> objects.</p>
<p>They are included in the printout of <code>filter.spct</code> objects.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1"></a>polyester.spct</span></code></pre></div>
<pre><code>## Object: filter_spct [611 x 2]
## Wavelength range 190 to 800 nm, step 1 nm 
## Label: clear polyester film 
## Transmittance of type &#39;total&#39;
## Rfr (/1): 0.07, thickness (mm): 0.125, attenuation mode: absorption.
## 
## # A tibble: 611 x 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      190 0.011
## 2      191 0.01 
## 3      192 0.011
## 4      193 0.015
## # ... with 607 more rows</code></pre>
<p>We estimate the spectral transmittance of 2 mm-thick PET film.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1"></a><span class="kw">convertThickness</span>(polyester.spct, <span class="dt">thickness =</span> <span class="fl">2e-3</span>)</span></code></pre></div>
<pre><code>## Object: filter_spct [611 x 2]
## Wavelength range 190 to 800 nm, step 1 nm 
## Label: clear polyester film 
## Transmittance of type &#39;total&#39;
## Rfr (/1): 0.07, thickness (mm): 2, attenuation mode: absorption.
## 
## # A tibble: 611 x 2
##   w.length      Tfr
##      &lt;int&gt;    &lt;dbl&gt;
## 1      190 1.36e-31
## 2      191 2.97e-32
## 3      192 1.36e-31
## 4      193 1.95e-29
## # ... with 607 more rows</code></pre>
<hr>
<p>Attributes <code>instr_desc</code> and <code>instr_settings</code> are used to store measurement-related metadata, describing the instrument used and its settings. These attributes are lists, with a few default fields and possibly unlimited <em>special</em> attributes. The present package provides functions for operating on them and print-outs include some of the default fields if the attribute is set. The expectation is that these attributes are set by other packages such as ‘ooacquire’ used for direct data acquisition or raw instrument data import.</p>
These instrument-specific attributes can contain lots of information and bloat the size of spectral objects. Two methods, <code>trimInstrDesc()</code> and <code>trimInstrSettings()</code> can be used to discard parts of these metadata, such as instrument calibration information, once the raw data has been converted into physical units.
<hr>
<hr>
Spectral objects created with earlier (pre-release) versions of this package are missing some attributes. For this reason <em>summary</em> and <em>plot</em> functions may not work as expected with them. These <em>very old</em> objects can be updated by adding the missing attributes using functions <code>setTimeUnit</code>, <code>setBSWFUsed</code>, <code>setTfrType</code> and <code>setRfrType</code>. However, in many cases function <code>update_spct</code> can be used to set the missing attributes to default values, or the scripts re-run to rebuild the data objects from raw data.
<hr>
</div>
</div>
</div>
<div id="collections-of-spectra" class="section level2">
<h2>Collections of spectra</h2>
<div id="classes-1" class="section level3">
<h3>Classes</h3>
<p>The package defines several classes intended to be used to store <em>collections</em> of different types of spectral data. They are all derived from <code>generic_mspct</code>, which in turn is derived from <code>list</code>. Table 3 lists them.</p>
<hr>
<p><strong>Table 3. Classes for collections of spectral objects.</strong> Objects of class <code>generic_mspct</code> can have member objects of any class derived from <code>generic_spct</code> and can be heterogeneous, while the other classes support homogeneous collections of spectral objects. Attributes of these objects can be queried and set with the normal R methods <code>attr</code> and <code>attributes</code> as well as with functions defined in this package. See table 1 for the attributes used in individual member spectra of collections.</p>
<table>
<thead>
<tr class="header">
<th align="left">Class name</th>
<th align="left">Class of member objects</th>
<th>Attributes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="even">
<td align="left"><code>calibration_mspct</code></td>
<td align="left"><code>calibration_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="odd">
<td align="left"><code>raw_mspct</code></td>
<td align="left"><code>raw_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="even">
<td align="left"><code>cps_mspct</code></td>
<td align="left"><code>cps_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_mspct</code></td>
<td align="left"><code>source_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="even">
<td align="left"><code>filter_mspct</code></td>
<td align="left"><code>filter_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="odd">
<td align="left"><code>reflector_mspct</code></td>
<td align="left"><code>reflector_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="even">
<td align="left"><code>object_mspct</code></td>
<td align="left"><code>object_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="odd">
<td align="left"><code>response_mspct</code></td>
<td align="left"><code>response_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
<tr class="even">
<td align="left"><code>chroma_mspct</code></td>
<td align="left"><code>chroma_spct</code></td>
<td><code>names</code>, <code>dim</code>, <code>comment</code></td>
</tr>
</tbody>
</table>
<hr>
<p>Objects of these classes, except for class <code>generic_mspct</code>, can only contain members belonging the matching class of spectra. As all other spectral object classes are derived from <code>generic_spct</code>, <code>generic_mspct</code> objects can contain heterogeneous collections of spectra. In all cases, there are no restrictions on the lengths, wavelength range and/or wavelength step size, or attributes other than <code>class</code> of the contained spectra. Mimicking R’s arrays and matrices, a <code>dim</code> attribute is always present and <code>dim</code> methods are provided. This approach allows the storage of time series of spectral data, or (hyper)spectral image data, or even higher dimensional spectral data. The handling of 1D and 2D spectral collections is already implemented in the summary methods. Handling of 3D and higher dimensional data can be implemented in the future without changing the class definitions. By having implemented <code>dim</code>, also methods <code>ncol</code> and <code>nrow</code> are available as they use <code>dim</code> internally. Array-like subscripting collections of spectra is <strong>not</strong> implemented.</p>
</div>
<div id="construction-1" class="section level3">
<h3>Construction</h3>
<div id="constructors" class="section level4">
<h4>Constructors</h4>
<p>We can construct a collection using a list of spectral objects as a starting point, in this case the spectral irradiance for sunlight.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1"></a>two_suns.mspct &lt;-<span class="st"> </span><span class="kw">source_mspct</span>(<span class="kw">list</span>(<span class="dt">sun1 =</span> sun.spct, <span class="dt">sun2 =</span> sun.spct))</span>
<span id="cb75-2"><a href="#cb75-2"></a>two_suns.mspct</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: sun1 ---
## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows
## --- Member: sun2 ---
## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
<p>We can also create heterogeneous collections, but this drastically limits the methods that are applicable to the resulting collection.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1"></a>mixed.mspct &lt;-<span class="st"> </span><span class="kw">generic_mspct</span>(<span class="kw">list</span>(<span class="dt">filter =</span> polyester.spct, <span class="dt">source =</span> sun.spct))</span>
<span id="cb77-2"><a href="#cb77-2"></a><span class="kw">class</span>(mixed.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;generic_mspct&quot; &quot;list&quot;</code></pre>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1"></a><span class="kw">lapply</span>(mixed.mspct, class_spct)</span></code></pre></div>
<pre><code>## $filter
## [1] &quot;filter_spct&quot;  &quot;generic_spct&quot;
## 
## $source
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot;</code></pre>
</div>
<div id="using-as.-functions" class="section level4">
<h4>Using <em>as.</em> functions</h4>
<p>The <code>as.</code> coercion methods for collections of spectra, not only change the class of the collection object, but can also optionally apply the corresponding <code>as.</code> functions to the member objects. A copy of the original object is made and then class-converted and returned.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1"></a>two_gen.mspct &lt;-<span class="st"> </span><span class="kw">as.generic_mspct</span>(two_suns.mspct)</span>
<span id="cb81-2"><a href="#cb81-2"></a><span class="kw">class</span>(two_gen.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;generic_mspct&quot; &quot;list&quot;</code></pre>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1"></a><span class="kw">str</span>(two_gen.mspct, <span class="dt">max.level =</span> <span class="dv">1</span>, <span class="dt">give.attr =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<pre><code>## List of 2
##  $ sun1: tibble [522 x 3] (S3: source_spct/generic_spct/tbl_df/tbl/data.frame)
##  $ sun2: tibble [522 x 3] (S3: source_spct/generic_spct/tbl_df/tbl/data.frame)</code></pre>
<p>In addition to coercion methods for lists of spectra objects, coercion methods are available for lists of data frames (or tibbles) and from matrix objects.</p>
<p>One additional feature is that if a single spectrum object or data frame are coerced into a collection of spectra, the behavior is equivalent to having passed as argument a list containing such object as its only member.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1"></a>one_sun.mspct &lt;-<span class="st"> </span><span class="kw">as.source_mspct</span>(sun.spct)</span>
<span id="cb85-2"><a href="#cb85-2"></a><span class="kw">class</span>(one_sun.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;source_mspct&quot;  &quot;generic_mspct&quot; &quot;list&quot;</code></pre>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1"></a><span class="kw">str</span>(one_sun.mspct, <span class="dt">max.level =</span> <span class="dv">1</span>, <span class="dt">give.attr =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<pre><code>## List of 1
##  $ spct_1: tibble [522 x 3] (S3: source_spct/generic_spct/tbl_df/tbl/data.frame)</code></pre>
<p>Sometimes spectral data stored in a matrix need to be coerced into a collection of spectra. Coercion methods are defined also for this cases. Several spectra may be stored in a matrix either by row or by column, but this can be deduced automatically in the case of rectangular matrices. Wavelengths values are not expected to be part of the matrix, and need to be supplied as a separate numeric vector sorted in ascending order. As in a spectrum wavelength values never repeat, the vector of wavelengths is never recycled and uniqueness of values is enforced.</p>
<p>We here use artificial data, in this first example with spectra saved by column. We assume that the values in the matrix are spectral transmittance stored as percentages (hence “Tpc”).</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1"></a>x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>, <span class="dt">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb89-2"><a href="#cb89-2"></a>wl &lt;-<span class="st"> </span><span class="dv">501</span><span class="op">:</span><span class="dv">550</span> <span class="co"># wavelengths in nanometres</span></span>
<span id="cb89-3"><a href="#cb89-3"></a><span class="kw">as.filter_mspct</span>(x, wl, <span class="st">&quot;Tpc&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_mspct [0 x 3]
## --- Member: spct_1 ---
## Object: filter_spct [50 x 2]
## Wavelength range 501 to 550 nm, step 1 nm 
## Transmittance of type &#39;total&#39;
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## 
## # A tibble: 50 x 2
##   w.length   Tfr
##      &lt;dbl&gt; &lt;dbl&gt;
## 1      501  0.01
## 2      502  0.02
## 3      503  0.03
## 4      504  0.04
## # ... with 46 more rows
## --- Member: spct_2 ---
## Object: filter_spct [50 x 2]
## Wavelength range 501 to 550 nm, step 1 nm 
## Transmittance of type &#39;total&#39;
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## 
## # A tibble: 50 x 2
##   w.length   Tfr
##      &lt;dbl&gt; &lt;dbl&gt;
## 1      501  0.51
## 2      502  0.52
## 3      503  0.53
## 4      504  0.54
## # ... with 46 more rows
## 
## --- END ---</code></pre>
<p>In a second example we supply explicit names for the spectra.</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1"></a><span class="kw">as.filter_mspct</span>(x, wl, <span class="st">&quot;Tpc&quot;</span>, <span class="dt">spct.names =</span> <span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>))</span></code></pre></div>
<pre><code>## Object: filter_mspct [0 x 3]
## --- Member: A ---
## Object: filter_spct [50 x 2]
## Wavelength range 501 to 550 nm, step 1 nm 
## Transmittance of type &#39;total&#39;
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## 
## # A tibble: 50 x 2
##   w.length   Tfr
##      &lt;dbl&gt; &lt;dbl&gt;
## 1      501  0.01
## 2      502  0.02
## 3      503  0.03
## 4      504  0.04
## # ... with 46 more rows
## --- Member: B ---
## Object: filter_spct [50 x 2]
## Wavelength range 501 to 550 nm, step 1 nm 
## Transmittance of type &#39;total&#39;
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## 
## # A tibble: 50 x 2
##   w.length   Tfr
##      &lt;dbl&gt; &lt;dbl&gt;
## 1      501  0.51
## 2      502  0.52
## 3      503  0.53
## 4      504  0.54
## # ... with 46 more rows
## 
## --- END ---</code></pre>
<p>There is no change in the call for data stored by row. We create a new matrix, with the same data as above, but stored by row, as some R packages do.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1"></a>xrow &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>, <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</span>
<span id="cb93-2"><a href="#cb93-2"></a><span class="kw">as.filter_mspct</span>(xrow, wl, <span class="st">&quot;Tpc&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_mspct [0 x 3]
## --- Member: spct_1 ---
## Object: filter_spct [50 x 2]
## Wavelength range 501 to 550 nm, step 1 nm 
## Transmittance of type &#39;total&#39;
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## 
## # A tibble: 50 x 2
##   w.length   Tfr
##      &lt;dbl&gt; &lt;dbl&gt;
## 1      501  0.01
## 2      502  0.02
## 3      503  0.03
## 4      504  0.04
## # ... with 46 more rows
## --- Member: spct_2 ---
## Object: filter_spct [50 x 2]
## Wavelength range 501 to 550 nm, step 1 nm 
## Transmittance of type &#39;total&#39;
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## 
## # A tibble: 50 x 2
##   w.length   Tfr
##      &lt;dbl&gt; &lt;dbl&gt;
## 1      501  0.51
## 2      502  0.52
## 3      503  0.53
## 4      504  0.54
## # ... with 46 more rows
## 
## --- END ---</code></pre>
<p>There is only one case when an explicit argument for <code>byrow</code> is needed: square matrices (same number of spectra as of wavelength values in each spectrum).</p>
<p>When coercing collections of spectra into matrices, the metadata contained in the individual spectral objects is discarded, and only the <code>&quot;comment&quot;</code> attribute of the collection of spectra copied to the returned object. The wavelength values are preserved in an attribute named “w.length”, but are not included as part of the matrix.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1"></a>two_suns.mat &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(two_suns.mspct, <span class="st">&quot;s.e.irrad&quot;</span>)</span>
<span id="cb95-2"><a href="#cb95-2"></a><span class="kw">class</span>(two_suns.mat)</span></code></pre></div>
<pre><code>## [1] &quot;matrix&quot; &quot;array&quot;</code></pre>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1"></a><span class="kw">dim</span>(two_suns.mat)</span></code></pre></div>
<pre><code>## [1] 522   2</code></pre>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb99-1"><a href="#cb99-1"></a><span class="kw">head</span>(<span class="kw">dimnames</span>(two_suns.mat)<span class="op">$</span>spct)</span></code></pre></div>
<pre><code>## [1] &quot;sun1&quot; &quot;sun2&quot;</code></pre>
<div class="sourceCode" id="cb101"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb101-1"><a href="#cb101-1"></a><span class="kw">head</span>(<span class="kw">dimnames</span>(two_suns.mat)<span class="op">$</span>w.length)</span></code></pre></div>
<pre><code>## [1] &quot;280&quot;              &quot;280.923076923077&quot; &quot;281.846153846154&quot; &quot;282.769230769231&quot;
## [5] &quot;283.692307692308&quot; &quot;284.615384615385&quot;</code></pre>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1"></a><span class="kw">head</span>(<span class="kw">attr</span>(two_suns.mat, <span class="st">&quot;w.length&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 280.0000 280.9231 281.8462 282.7692 283.6923 284.6154</code></pre>
<p>The argument <code>byrow</code> in the coercion into matrix methods has the same meaning as in the <code>matrix</code> constructor function.</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1"></a>two_suns.row_mat &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(two_suns.mat, <span class="st">&quot;s.e.irrad&quot;</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</span>
<span id="cb105-2"><a href="#cb105-2"></a><span class="kw">class</span>(two_suns.row_mat)</span></code></pre></div>
<pre><code>## [1] &quot;matrix&quot; &quot;array&quot;</code></pre>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1"></a><span class="kw">dim</span>(two_suns.row_mat)</span></code></pre></div>
<pre><code>## [1] 522   2</code></pre>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1"></a><span class="kw">head</span>(<span class="kw">dimnames</span>(two_suns.row_mat)<span class="op">$</span>spct)</span></code></pre></div>
<pre><code>## [1] &quot;sun1&quot; &quot;sun2&quot;</code></pre>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1"></a><span class="kw">head</span>(<span class="kw">attr</span>(two_suns.row_mat, <span class="st">&quot;w.length&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 280.0000 280.9231 281.8462 282.7692 283.6923 284.6154</code></pre>
<p>Collections of spectra have a <code>dim</code> attribute but it is discarded as it describes dimensions that could require spectral data to be stored in a three dimensional array and cannot be mapped to the two dimensions of a matrix.</p>
<p>These functions are not fully automatic, the user needs to provide the name of the variable to extract from each spectrum. If the wavelength values are not consistent among spectra, only those with the same values as the first spectrum in the collection are retained and the remaining ones dropped with a warning.</p>
</div>
<div id="converting-tidy-data" class="section level4">
<h4>Converting <em>tidy</em> data</h4>
<p>Spectral objects containing multiple spectra identified by a factor can be created by row-binding compatible spectral objects. For for binding to succeed, the list of spectra passed as argument must be homogeneous with respect to member class, as well as for certain attributes such as <code>time.unit</code>. Other metadata attributes are retained as named lists or multi-row data frames.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1"></a>two_suns.spct &lt;-<span class="st"> </span><span class="kw">rbindspct</span>(<span class="kw">list</span>(<span class="dt">a =</span> sun.spct, <span class="dt">b =</span> sun.spct <span class="op">/</span><span class="st"> </span><span class="dv">2</span>))</span>
<span id="cb113-2"><a href="#cb113-2"></a>two_suns.spct</span></code></pre></div>
<pre><code>## Object: source_spct [1,044 x 4]
## containing 2 spectra in long form
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## a label: sunlight, simulated
## b label: sunlight, simulated 
## a measured on 2010-06-22 09:51:00 UTC
## b measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 1,044 x 4
##   w.length s.e.irrad spct.idx s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;        &lt;dbl&gt;
## 1     280          0 a                0
## 2     281.         0 a                0
## 3     282.         0 a                0
## 4     283.         0 a                0
## # ... with 1,040 more rows</code></pre>
<p>The reverse operation, separating the individual spectra from a spectrum object containing multiple spectra in <em>long form</em> and storing them as a collection, is implemented in method <code>subset2mspct</code>. In this case, metadata is set for the individual spectra if it is available in the object being subset. What metadata is automatically stored depends on the version of this package used when creating the long form spectrum object by means of <code>rbindspct()</code>. Versions 0.9.14 and later preserve most of the metadata.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1"></a><span class="kw">subset2mspct</span>(two_suns.spct)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: a ---
## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows
## --- Member: b ---
## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
<p>If multiple spectra are stored in long form (as <em>tidy</em> data) in an ordinary <code>data.frame</code> or a <code>tibble</code> object with columns with suitable names, the same <code>subset2mspct</code> method can be used. In these case, arguments indicating the target class for conversion and supplying the name of the index variable encoding the grouping into multiple spectra need to be supplied. A call as in the example below, adds only default metadata to spectral objects.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb117-1"><a href="#cb117-1"></a>test1.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">w.length =</span> <span class="kw">rep</span>(<span class="dv">200</span><span class="op">:</span><span class="dv">210</span>, <span class="dv">2</span>),</span>
<span id="cb117-2"><a href="#cb117-2"></a>                       <span class="dt">s.e.irrad =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">11</span>, <span class="dv">11</span>)),</span>
<span id="cb117-3"><a href="#cb117-3"></a>                       <span class="dt">spectrum =</span> <span class="kw">factor</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="kw">c</span>(<span class="dv">11</span>,<span class="dv">11</span>))))</span>
<span id="cb117-4"><a href="#cb117-4"></a><span class="kw">subset2mspct</span>(test1.df, <span class="dt">member.class =</span> <span class="st">&quot;source_spct&quot;</span>, <span class="dt">idx.var =</span> <span class="st">&quot;spectrum&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 2]
## Wavelength range 200 to 210 nm, step 1 nm 
## Time unit 1s
## 
## # A tibble: 11 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         1
## 2      201         1
## 3      202         1
## 4      203         1
## # ... with 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 2]
## Wavelength range 200 to 210 nm, step 1 nm 
## Time unit 1s
## 
## # A tibble: 11 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         2
## 2      201         2
## 3      202         2
## 4      203         2
## # ... with 7 more rows
## 
## --- END ---</code></pre>
<p>If all member spectra share the same metadata, and the constructor has a parameter allowing it to be set, it can be passed as a named argument.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb119-1"><a href="#cb119-1"></a><span class="kw">subset2mspct</span>(test1.df, <span class="dt">member.class =</span> <span class="st">&quot;source_spct&quot;</span>, <span class="dt">idx.var =</span> <span class="st">&quot;spectrum&quot;</span>,</span>
<span id="cb119-2"><a href="#cb119-2"></a>             <span class="dt">time.unit =</span> <span class="st">&quot;day&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 2]
## Wavelength range 200 to 210 nm, step 1 nm 
## Time unit 86400s (~1 days)
## 
## # A tibble: 11 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         1
## 2      201         1
## 3      202         1
## 4      203         1
## # ... with 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 2]
## Wavelength range 200 to 210 nm, step 1 nm 
## Time unit 86400s (~1 days)
## 
## # A tibble: 11 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         2
## 2      201         2
## 3      202         2
## 4      203         2
## # ... with 7 more rows
## 
## --- END ---</code></pre>
<p>To directly convert a <em>tidy</em> data frame into a long form spectral object we need to pass the number of spectra through parameter <code>multiple.wl</code> to override the usual check for unique wavelength values (default is <code>multiple.wl = 1L</code>).</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1"></a>test2.df &lt;-<span class="st"> </span>test1.df</span>
<span id="cb121-2"><a href="#cb121-2"></a><span class="kw">setSourceSpct</span>(test2.df, <span class="dt">multiple.wl =</span> 2L)</span>
<span id="cb121-3"><a href="#cb121-3"></a><span class="kw">getMultipleWl</span>(test2.df)</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
<p>If <code>multiple.wl = NULL</code> a suitable value is guessed from the data frame passed as first argument. This should work in most cases, but is more time consuming. Using this approach in addition disables the check for a fixed number of spectra.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1"></a>test3.df &lt;-<span class="st"> </span>test1.df</span>
<span id="cb123-2"><a href="#cb123-2"></a><span class="kw">setSourceSpct</span>(test3.df, <span class="dt">multiple.wl =</span> <span class="ot">NULL</span>)</span>
<span id="cb123-3"><a href="#cb123-3"></a><span class="kw">getMultipleWl</span>(test3.df)</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
</div>
<div id="converting-untidy-data-frames" class="section level4">
<h4>Converting <em>untidy</em> data frames</h4>
<p>In a <em>broad form</em> (or <em>untidy</em>) data.frame the spectral values for different spectra are stored side-by-side as columns, and a single additional column used to store the shared wavelength values. To create a collection of spectral objects, with each member containing a single spectrum, we use function <code>split2source_mspct</code> and its equivalents for the remaining classes of spectral objects (class is determined by the function used, and columns which are not <code>numeric</code> are skipped). The column containing wavelength values in nanometres is recognized by means of its name. The names used for the spectra in the collection are derived from the names of the columns containing spectral values.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb125-1"><a href="#cb125-1"></a>test2.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">w.length =</span> <span class="dv">200</span><span class="op">:</span><span class="dv">210</span>, <span class="dt">A =</span> <span class="dv">1</span>, <span class="dt">B =</span> <span class="dv">2</span>, <span class="dt">z =</span> <span class="st">&quot;A&quot;</span>)</span>
<span id="cb125-2"><a href="#cb125-2"></a><span class="kw">split2source_mspct</span>(test2.df)</span></code></pre></div>
<pre><code>## Warning in split2mspct(x = x, member.class = &quot;source_spct&quot;, spct.data.var =
## spct.data.var, : Skipping non-numeric column in x: z</code></pre>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 2]
## Wavelength range 200 to 210 nm, step 1 nm 
## Time unit 1s
## 
## # A tibble: 11 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         1
## 2      201         1
## 3      202         1
## 4      203         1
## # ... with 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 2]
## Wavelength range 200 to 210 nm, step 1 nm 
## Time unit 1s
## 
## # A tibble: 11 x 2
##   w.length s.e.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         2
## 2      201         2
## 3      202         2
## 4      203         2
## # ... with 7 more rows
## 
## --- END ---</code></pre>
<div class="sourceCode" id="cb128"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1"></a><span class="kw">split2source_mspct</span>(test2.df, <span class="dt">spct.data.var =</span> <span class="st">&quot;s.q.irrad&quot;</span>)</span></code></pre></div>
<pre><code>## Warning in split2mspct(x = x, member.class = &quot;source_spct&quot;, spct.data.var =
## spct.data.var, : Skipping non-numeric column in x: z</code></pre>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 2]
## Wavelength range 200 to 210 nm, step 1 nm 
## Time unit 1s
## 
## # A tibble: 11 x 2
##   w.length s.q.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         1
## 2      201         1
## 3      202         1
## 4      203         1
## # ... with 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 2]
## Wavelength range 200 to 210 nm, step 1 nm 
## Time unit 1s
## 
## # A tibble: 11 x 2
##   w.length s.q.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         2
## 2      201         2
## 3      202         2
## 4      203         2
## # ... with 7 more rows
## 
## --- END ---</code></pre>
<p>Also in this case, it is possible to pass additional named arguments to the constructor of spectral objects.</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb131-1"><a href="#cb131-1"></a><span class="kw">split2source_mspct</span>(test2.df, <span class="dt">spct.data.var =</span> <span class="st">&quot;s.q.irrad&quot;</span>, <span class="dt">time.unit =</span> <span class="st">&quot;day&quot;</span>)</span></code></pre></div>
<pre><code>## Warning in split2mspct(x = x, member.class = &quot;source_spct&quot;, spct.data.var =
## spct.data.var, : Skipping non-numeric column in x: z</code></pre>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [11 x 2]
## Wavelength range 200 to 210 nm, step 1 nm 
## Time unit 86400s (~1 days)
## 
## # A tibble: 11 x 2
##   w.length s.q.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         1
## 2      201         1
## 3      202         1
## 4      203         1
## # ... with 7 more rows
## --- Member: B ---
## Object: source_spct [11 x 2]
## Wavelength range 200 to 210 nm, step 1 nm 
## Time unit 86400s (~1 days)
## 
## # A tibble: 11 x 2
##   w.length s.q.irrad
##      &lt;int&gt;     &lt;dbl&gt;
## 1      200         2
## 2      201         2
## 3      202         2
## 4      203         2
## # ... with 7 more rows
## 
## --- END ---</code></pre>
</div>
</div>
<div id="conversion-into-a-wide-data-frame" class="section level3">
<h3>Conversion into a “wide” data frame</h3>
<p>Sometimes, when exporting spectral data we may need to convert a collection of spectra into an <em>untidy</em> or <em>wide form</em> data frame. In the example below we use a collection with only two member spectra, but <code>join_mspct()</code> can handle collections of any length.</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1"></a>my.mspct &lt;-<span class="st"> </span><span class="kw">source_mspct</span>(<span class="kw">list</span>(<span class="dt">sun1 =</span> sun.spct, <span class="dt">sun2 =</span> sun.spct <span class="op">*</span><span class="st"> </span><span class="dv">2</span>))</span>
<span id="cb134-2"><a href="#cb134-2"></a>my.df &lt;-<span class="st"> </span><span class="kw">join_mspct</span>(my.mspct)</span>
<span id="cb134-3"><a href="#cb134-3"></a><span class="kw">head</span>(my.df)</span></code></pre></div>
<pre><code>##   w.length sun1 sun2
## 1 280.0000    0    0
## 2 280.9231    0    0
## 3 281.8462    0    0
## 4 282.7692    0    0
## 5 283.6923    0    0
## 6 284.6154    0    0</code></pre>
</div>
<div id="querying-the-class-1" class="section level3">
<h3>Querying the class</h3>
<p><code>is.</code> functions are defined for all the new classes. R’s <code>class</code> method can also be used.</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1"></a><span class="kw">is.source_mspct</span>(two_suns.mspct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb138"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb138-1"><a href="#cb138-1"></a><span class="kw">class</span>(two_suns.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;source_mspct&quot;  &quot;generic_mspct&quot; &quot;list&quot;</code></pre>
<p>In addition to using <code>class</code> to query the class of the collection, we can use base R’s <code>lapply</code> together with <code>class</code> or <code>class_spct</code> to query the class of each of the members of the collection.</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1"></a><span class="kw">is.filter_mspct</span>(mixed.mspct)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb142"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1"></a><span class="kw">is.any_mspct</span>(mixed.mspct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb144"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1"></a><span class="kw">class</span>(mixed.mspct)</span></code></pre></div>
<pre><code>## [1] &quot;generic_mspct&quot; &quot;list&quot;</code></pre>
<div class="sourceCode" id="cb146"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1"></a><span class="kw">lapply</span>(mixed.mspct, class_spct)</span></code></pre></div>
<pre><code>## $filter
## [1] &quot;filter_spct&quot;  &quot;generic_spct&quot;
## 
## $source
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot;</code></pre>
<div class="sourceCode" id="cb148"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb148-1"><a href="#cb148-1"></a><span class="kw">lapply</span>(mixed.mspct, class)</span></code></pre></div>
<pre><code>## $filter
## [1] &quot;filter_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;  
## 
## $source
## [1] &quot;source_spct&quot;  &quot;generic_spct&quot; &quot;tbl_df&quot;       &quot;tbl&quot;          &quot;data.frame&quot;</code></pre>
</div>
<div id="extract-replace-and-combine" class="section level3">
<h3>Extract, replace and combine</h3>
<p>R’s extraction and replacement methods have specializations for collections of spectra and can be used with the same syntax and functionality as for R lists. However they test the class and validity of the returned objects and replacement members.</p>
<hr>
Methods <code>[</code>, and <code>[&lt;-</code>, extract and replace <em>parts</em> of the collection, respectively. Even when only one member is extracted, the returned value is a collection of spectra. The expected replacement value is also, always a collection of spectra.
<hr>
<div class="sourceCode" id="cb150"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb150-1"><a href="#cb150-1"></a><span class="co"># not run as this triggers an error when building the vignette with &#39;devtools&#39;</span></span>
<span id="cb150-2"><a href="#cb150-2"></a>two_suns.mspct[<span class="dv">1</span>]</span>
<span id="cb150-3"><a href="#cb150-3"></a>two_suns.mspct[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>]</span></code></pre></div>
<p>Avoid code like that in the chunk bellow. Collections of spectra are named lists, consequently assigning by position as shown here swaps the values without swapping the names of the slots!</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb151-1"><a href="#cb151-1"></a><span class="co"># not run as this triggers an error when building the vignette with &#39;devtools&#39;</span></span>
<span id="cb151-2"><a href="#cb151-2"></a>two_suns.mspct[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>] &lt;-<span class="st"> </span>two_suns.mspct[<span class="dv">2</span><span class="op">:</span><span class="dv">1</span>]</span></code></pre></div>
<hr>
Methods <code>[[</code>, <code>$</code> and <code>[[&lt;-</code>, extract and replace individual members of the collection, respectively. They always return or expect objects of one of the spectral classes.
<hr>
<div class="sourceCode" id="cb152"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb152-1"><a href="#cb152-1"></a>two_suns.mspct[[<span class="dv">1</span>]]</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb154"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb154-1"><a href="#cb154-1"></a>two_suns.mspct<span class="op">$</span>sun1</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb156"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb156-1"><a href="#cb156-1"></a>two_suns.mspct[[<span class="st">&quot;sun1&quot;</span>]]</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb158"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb158-1"><a href="#cb158-1"></a>two_suns.mspct[[<span class="st">&quot;sun1&quot;</span>]] &lt;-<span class="st"> </span>sun.spct <span class="op">*</span><span class="st"> </span><span class="dv">2</span></span>
<span id="cb158-2"><a href="#cb158-2"></a>two_suns.mspct[[<span class="st">&quot;sun2&quot;</span>]] &lt;-<span class="st"> </span><span class="ot">NULL</span></span>
<span id="cb158-3"><a href="#cb158-3"></a>two_suns.mspct</span></code></pre></div>
<pre><code>## Object: source_mspct [1 x 1]
## --- Member: sun1 ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
<p>As with R’s <code>list</code> objects, can combine collections of spectra with method <code>c()</code> but we can not create new collections from individual spectra using this method.</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb160-1"><a href="#cb160-1"></a><span class="kw">c</span>(two_suns.mspct, mixed.mspct)</span></code></pre></div>
<pre><code>## Object: generic_mspct [3 x 1]
## --- Member: sun1 ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## --- Member: filter ---
## Object: filter_spct [611 x 2]
## Wavelength range 190 to 800 nm, step 1 nm 
## Label: clear polyester film 
## Transmittance of type &#39;total&#39;
## Rfr (/1): 0.07, thickness (mm): 0.125, attenuation mode: absorption.
## 
## # A tibble: 611 x 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      190 0.011
## 2      191 0.01 
## 3      192 0.011
## 4      193 0.015
## # ... with 607 more rows
## --- Member: source ---
## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
</div>
<div id="transform-or-apply-functions" class="section level3">
<h3>Transform or <em>apply</em> functions</h3>
<p>For our <em>apply</em> functions we follow the naming convention used in package <code>plyr</code>, but using <code>ms</code> as prefix for <code>_mspct</code> objects. The <em>apply</em> functions implemented in the ‘<strong>photobiology</strong>’ package are <code>msmsply</code>, <code>msdply</code>, <code>mslply</code> and <code>msaply</code> which both accept a collection of spectra as first argument and return a collection of spectra, a data frame, a list, or an array respectively (see Table 4).</p>
<hr>
<p><strong>Table 4. Apply functions for collections of spectra.</strong> Key: v., value returned by <em>apply</em> function; f.v., value returned by the applied function (argument <code>.fun</code>). In the table <code>generic_mspct</code> and <code>generic_spct</code> indicate objects of these classes or any class derived from them. The exact class of the collection of spectra object returned will be determined by the class(es) of the values returned by the applied function.</p>
<table>
<thead>
<tr class="header">
<th align="left"><em>apply</em> function</th>
<th align="left">first arg. class</th>
<th align="left">v. class</th>
<th align="left">f.v. class</th>
<th align="left">f.v. length</th>
<th align="left">f.v. dims</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>msmsply</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">1</td>
<td align="left">any</td>
</tr>
<tr class="even">
<td align="left"><code>msdply</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>data.frame</code></td>
<td align="left"><code>numeric</code></td>
<td align="left"><span class="math inline">\(1\ldots n\)</span></td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left"><code>mslply</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>list</code></td>
<td align="left">any</td>
<td align="left">any</td>
<td align="left">any</td>
</tr>
<tr class="even">
<td align="left"><code>msaply</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>vector</code></td>
<td align="left">any simple</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left"><code>msaply</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>matrix</code></td>
<td align="left">any simple</td>
<td align="left"><span class="math inline">\(2\ldots n\)</span></td>
<td align="left"><span class="math inline">\(2\ldots n\)</span></td>
</tr>
<tr class="even">
<td align="left"><code>concolve_each</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>generic_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">1</td>
<td align="left">any</td>
</tr>
</tbody>
</table>
<hr>
<p>Functions <code>msmsply()</code>, <code>msdply</code> and <code>mslply</code> can be used to apply a function to each member spectrum in a collection. The <em>apply</em> function to use depends on the return value of the applied function.</p>
<p>In the case of <code>msmsply()</code> the applied function is expected to return a <em>transformed</em> spectrum as another object of class <code>generic_spct</code> or a class derived from it. The value returned by <code>msmsply</code> is a collection of spectra, of a type determined by the class(es) of the member spectra in the new collection.</p>
<p>We start with a simple example in which we add a constant to each spectrum in the collection</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb162-1"><a href="#cb162-1"></a>two.mspct &lt;-<span class="st"> </span><span class="kw">source_mspct</span>(<span class="kw">list</span>(<span class="dt">A =</span> sun.spct <span class="op">*</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">B =</span> sun.spct <span class="op">*</span><span class="st"> </span><span class="dv">2</span>))</span>
<span id="cb162-2"><a href="#cb162-2"></a><span class="kw">msmsply</span>(two.mspct, <span class="st">`</span><span class="dt">+</span><span class="st">`</span>, <span class="fl">0.1</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280        0.1
## 2     281.       0.1
## 3     282.       0.1
## 4     283.       0.1
## # ... with 518 more rows
## --- Member: B ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280        0.1
## 2     281.       0.1
## 3     282.       0.1
## 4     283.       0.1
## # ... with 518 more rows
## 
## --- END ---</code></pre>
<p>and continue with a more complex example in which we trim each spectrum</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb164-1"><a href="#cb164-1"></a><span class="kw">msmsply</span>(two.mspct, trim_wl, <span class="dt">range =</span> <span class="kw">c</span>(<span class="dv">281</span>, <span class="dv">500</span>), <span class="dt">fill =</span> <span class="ot">NA</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [525 x 2]
## Wavelength range 280 to 800 nm, step 1.023182e-12 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 525 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280         NA
## 2     281.        NA
## 3     281.        NA
## 4     281          0
## # ... with 521 more rows
## --- Member: B ---
## Object: source_spct [525 x 2]
## Wavelength range 280 to 800 nm, step 1.023182e-12 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 525 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280         NA
## 2     281.        NA
## 3     281.        NA
## 4     281          0
## # ... with 521 more rows
## 
## --- END ---</code></pre>
<p>In the second example we pass two arguments by name to the applied function. The number of arguments is not fixed, but the spectrum will be always passed as the first argument to the function.</p>
<p>In the case of <code>msdply()</code> the applied function is expected to return an R object of the same length for each of the member spectra.</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb166-1"><a href="#cb166-1"></a><span class="kw">msdply</span>(two.mspct, max)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   spct.idx max.wl
##   &lt;fct&gt;     &lt;dbl&gt;
## 1 A           800
## 2 B           800</code></pre>
<div class="sourceCode" id="cb168"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb168-1"><a href="#cb168-1"></a>ranges.df &lt;-<span class="st"> </span><span class="kw">msdply</span>(two.mspct, range)</span>
<span id="cb168-2"><a href="#cb168-2"></a>ranges.df</span></code></pre></div>
<pre><code>## # A tibble: 2 x 3
##   spct.idx min.wl max.wl
##   &lt;fct&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1 A           280    800
## 2 B           280    800</code></pre>
<div class="sourceCode" id="cb170"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb170-1"><a href="#cb170-1"></a><span class="kw">cat</span>(<span class="kw">comment</span>(ranges.df))</span></code></pre></div>
<pre><code>## Applied function: &#39;range&#39;.</code></pre>
<div class="sourceCode" id="cb172"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb172-1"><a href="#cb172-1"></a><span class="kw">msdply</span>(two.mspct, range, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 3
##   spct.idx min.wl max.wl
##   &lt;fct&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1 A           280    800
## 2 B           280    800</code></pre>
<p>In the case of <code>mslply()</code> the applied function is expected to return an R object of any length, possibly variable among members.</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb174-1"><a href="#cb174-1"></a><span class="kw">str</span>(<span class="kw">mslply</span>(two.mspct, names))</span></code></pre></div>
<pre><code>## List of 2
##  $ A: chr [1:2] &quot;w.length&quot; &quot;s.e.irrad&quot;
##  $ B: chr [1:2] &quot;w.length&quot; &quot;s.e.irrad&quot;
##  - attr(*, &quot;comment&quot;)= chr &quot;Applied function: &#39;names&#39;.\n&quot;</code></pre>
<p>In the case of <code>msaply()</code> the applied function is expected to return an R object of length 1, although a list with dimensions will be returned for longer return values.</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb176-1"><a href="#cb176-1"></a><span class="kw">str</span>(<span class="kw">msaply</span>(two.mspct, max))</span></code></pre></div>
<pre><code>##  num [1:2] 800 800
##  - attr(*, &quot;comment&quot;)= chr &quot;Applied function: &#39;max&#39;.\n&quot;</code></pre>
<div class="sourceCode" id="cb178"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb178-1"><a href="#cb178-1"></a><span class="kw">str</span>(<span class="kw">msaply</span>(two.mspct, range))</span></code></pre></div>
<pre><code>##  num [1:2, 1:2] 280 280 800 800
##  - attr(*, &quot;dimnames&quot;)=List of 2
##   ..$ : NULL
##   ..$ : chr [1:2] &quot;1&quot; &quot;2&quot;
##  - attr(*, &quot;comment&quot;)= chr &quot;Applied function: &#39;range&#39;.\n&quot;</code></pre>
<p>For the most common cases for which one would use the <em>apply</em> functions described in the previous section methods and functions for operations on collections of spectra are defined in the package. These methods are described in a later section and listed in Table 9.</p>
</div>
<div id="summary-spectra" class="section level3">
<h3>Summary spectra</h3>
<p>Starting from a collection of spectra we may want to obtain a single spectrum containing a summary of them. The current implementation of the methods described in this section expects that all spectra in a collection are of the same class, and data is available for each of them at exactly the same set of wavelengths.</p>
<table>
<colgroup>
<col width="28%"></col>
<col width="15%"></col>
<col width="21%"></col>
<col width="34%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">functions</th>
<th align="left">class of argument</th>
<th align="left">class of returned spectrum</th>
<th align="left">variables in spectrum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>s_sum</code></td>
<td align="left"><code>source_mspct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="even">
<td align="left"><code>s_sum</code></td>
<td align="left"><code>response_mspct</code></td>
<td align="left"><code>response_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="odd">
<td align="left"><code>s_sum</code></td>
<td align="left"><code>filter_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.sum</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_sum</code></td>
<td align="left"><code>reflector_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.sum</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_sum</code></td>
<td align="left"><code>calibration_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.sum</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_prod</code></td>
<td align="left"><code>source_mspct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left">input tagged <code>.prod</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_prod</code></td>
<td align="left"><code>response_mspct</code></td>
<td align="left"><code>response_spct</code></td>
<td align="left">input tagged <code>.prod</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_prod</code></td>
<td align="left"><code>filter_mspct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="odd">
<td align="left"><code>s_prod</code></td>
<td align="left"><code>reflector_mspct</code></td>
<td align="left"><code>reflector_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="even">
<td align="left"><code>s_prod</code></td>
<td align="left"><code>calibration_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.prod</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean</code> or <code>s_median</code></td>
<td align="left"><code>source_mspct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="even">
<td align="left"><code>s_mean</code> or <code>s_median</code></td>
<td align="left"><code>response_mspct</code></td>
<td align="left"><code>response_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean</code> or <code>s_median</code></td>
<td align="left"><code>filter_mspct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="even">
<td align="left"><code>s_mean</code> or <code>s_median</code></td>
<td align="left"><code>reflector_mspct</code></td>
<td align="left"><code>reflector_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean</code> or <code>s_median</code></td>
<td align="left"><code>calibration_mspct</code></td>
<td align="left"><code>calibration_spct</code></td>
<td align="left">same as input</td>
</tr>
<tr class="even">
<td align="left"><code>s_var</code>, <code>s_se</code> or <code>s_sd</code></td>
<td align="left"><code>source_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.var</code>, <code>.se</code> or <code>.sd</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_var</code>, <code>s_se</code> or <code>s_sd</code></td>
<td align="left"><code>response_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.var</code>, <code>.se</code> or <code>.sd</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_var</code>, <code>s_se</code> or <code>s_sd</code></td>
<td align="left"><code>filter_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.var</code>, <code>.se</code> or <code>.sd</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_var</code>, <code>s_se</code> or <code>s_sd</code></td>
<td align="left"><code>reflector_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.var</code>, <code>.se</code> or <code>.sd</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_var</code>, <code>s_se</code> or <code>s_sd</code></td>
<td align="left"><code>calibration_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.var</code>, <code>.se</code> or <code>.sd</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean_se</code></td>
<td align="left"><code>source_mspct</code></td>
<td align="left"><code>source_spct</code></td>
<td align="left">same as input plus col. tagged <code>.se</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_mean_se</code></td>
<td align="left"><code>response_mspct</code></td>
<td align="left"><code>response_spct</code></td>
<td align="left">same as input plus col. tagged <code>.se</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean_se</code></td>
<td align="left"><code>filter_mspct</code></td>
<td align="left"><code>filter_spct</code></td>
<td align="left">same as input plus col. tagged <code>.se</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_mean_se</code></td>
<td align="left"><code>reflector_mspct</code></td>
<td align="left"><code>reflector_spct</code></td>
<td align="left">same as input plus col. tagged <code>.se</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_mean_se</code></td>
<td align="left"><code>calibration_mspct</code></td>
<td align="left"><code>calibration_spct</code></td>
<td align="left">same as input plus col. tagged <code>.se</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_range</code></td>
<td align="left"><code>source_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.min</code> and <code>.max</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_range</code></td>
<td align="left"><code>response_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.min</code> and <code>.max</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_range</code></td>
<td align="left"><code>filter_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.min</code> and <code>.max</code></td>
</tr>
<tr class="odd">
<td align="left"><code>s_range</code></td>
<td align="left"><code>reflector_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.min</code> and <code>.max</code></td>
</tr>
<tr class="even">
<td align="left"><code>s_range</code></td>
<td align="left"><code>calibration_mspct</code></td>
<td align="left"><code>generic_spct</code></td>
<td align="left">input tagged <code>.min</code> and <code>.max</code></td>
</tr>
</tbody>
</table>
<p>The calculations are done wavelength by wavelength yielding a spectrum at the same wavelengths than those in the input. Removal of <code>NA</code> values is done wavelength by wavelength. As shown in the table above, depending on the operation the returned quantity may be equivalent or not to the quantity in the input. When the quantity changes, even if units of expression remain the same, the name of the variable and class of the returned spectrum are different to those in the input.</p>
<p>Computing the mean returns values of the same quantity as in the input, and we obtain a <code>source_spct</code> object.</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb180-1"><a href="#cb180-1"></a><span class="kw">s_mean</span>(two.mspct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: Mean of 2 source_spct objects. 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<p>If we compute the standard error, the quantity returned is not the same. The object returned is in this case a <code>generic_spct</code> and the variable name has been tagged with <code>.se</code>.</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb182-1"><a href="#cb182-1"></a><span class="kw">s_se</span>(two.mspct)</span></code></pre></div>
<pre><code>## Object: generic_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: Standard error for 2 source_spct objects. 
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad.se
##      &lt;dbl&gt;        &lt;dbl&gt;
## 1     280             0
## 2     281.            0
## 3     282.            0
## 4     283.            0
## # ... with 518 more rows</code></pre>
<p>We can also compute both the mean and standard error simultaneously.</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb184-1"><a href="#cb184-1"></a><span class="kw">s_mean_se</span>(two.mspct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: Mean and SEM of 2 source_spct objects. 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.e.irrad.se
##      &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;
## 1     280          0            0
## 2     281.         0            0
## 3     282.         0            0
## 4     283.         0            0
## # ... with 518 more rows</code></pre>
<p>The other functions in these family function in a similar way to those described here.</p>
</div>
<div id="convolution" class="section level3">
<h3>Convolution</h3>
<p>By convolution we normally mean the multiplication value by value at matching wavelengths of two spectra. The function described in this section facilitates this and similar operations among collections of spectra. An example use case could be the convolution of spectral irradiance by spectral transmittance for all combinations of light sources and filters in a collection of source spectra and a collection of filter spectra.</p>
<p>Default operator (or function) is that for multiplication, either one or both of the two first arguments must be a collection of spectra. When only one argument is a collection of spectra, the other one can be a spectrum, or even a numeric vector. For multiplication the order of the operands does not affect the returned value. With operators or functions for non-transitive operations the order does matter.</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb186-1"><a href="#cb186-1"></a><span class="kw">convolve_each</span>(two.mspct, sun.spct)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## --- Member: B ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
<div class="sourceCode" id="cb188"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb188-1"><a href="#cb188-1"></a><span class="kw">convolve_each</span>(sun.spct, two.mspct)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## --- Member: B ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
<div class="sourceCode" id="cb190"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb190-1"><a href="#cb190-1"></a>another_two.mspct &lt;-<span class="st"> </span>two.mspct</span>
<span id="cb190-2"><a href="#cb190-2"></a><span class="kw">names</span>(another_two.mspct) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>)</span>
<span id="cb190-3"><a href="#cb190-3"></a><span class="kw">convolve_each</span>(another_two.mspct, two.mspct)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 2]
## --- Member: a_A ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## --- Member: a_B ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## --- Member: b_A ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## --- Member: b_B ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
<p>The function <code>convolve_each</code> will use other operators or functions and even pass additional named arguments when these are supplied as arguments.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb192-1"><a href="#cb192-1"></a><span class="kw">convolve_each</span>(two.mspct, sun.spct, <span class="dt">oper =</span> <span class="st">`</span><span class="dt">+</span><span class="st">`</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## --- Member: B ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
<hr>
There are cases where functions <code>convolve_each()</code> and <code>msmsply()</code> can be both used, but there are also cases where their differences matter. An example is convolving two collections of spectra, a case where only <code>convolve_each()</code> can be used. In contrast, when one of the arguments is not a spectrum or a collection of spectra, <code>msmsply()</code> should be used instead.
<hr>
</div>
<div id="metadata-attributes-1" class="section level3">
<h3>Metadata attributes</h3>
<p>Some of the <code>set</code> and <code>get</code> functions used with attributes have method definitions for collections of spectra. Some examples follow.</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb194-1"><a href="#cb194-1"></a><span class="kw">when_measured</span>(two.mspct)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   spct.idx when.measured      
##   &lt;fct&gt;    &lt;dttm&gt;             
## 1 A        2010-06-22 09:51:00
## 2 B        2010-06-22 09:51:00</code></pre>
<div class="sourceCode" id="cb196"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb196-1"><a href="#cb196-1"></a><span class="kw">when_measured</span>(two.mspct) &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&quot;2015-10-31&quot;</span>, <span class="dt">tz =</span> <span class="st">&quot;EET&quot;</span>)</span>
<span id="cb196-2"><a href="#cb196-2"></a><span class="kw">when_measured</span>(two.mspct)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   spct.idx when.measured      
##   &lt;fct&gt;    &lt;dttm&gt;             
## 1 A        2015-10-30 22:00:00
## 2 B        2015-10-30 22:00:00</code></pre>
<div class="sourceCode" id="cb198"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb198-1"><a href="#cb198-1"></a><span class="kw">when_measured</span>(two.mspct) &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">ymd_hm</span>(<span class="st">&quot;2015-10-31 10:00&quot;</span>, <span class="dt">tz =</span> <span class="st">&quot;EET&quot;</span>),</span>
<span id="cb198-2"><a href="#cb198-2"></a>                                 <span class="kw">ymd_hm</span>(<span class="st">&quot;2015-10-31 11:00&quot;</span>, <span class="dt">tz =</span> <span class="st">&quot;EET&quot;</span>))</span>
<span id="cb198-3"><a href="#cb198-3"></a><span class="kw">when_measured</span>(two.mspct)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   spct.idx when.measured      
##   &lt;fct&gt;    &lt;dttm&gt;             
## 1 A        2015-10-31 08:00:00
## 2 B        2015-10-31 09:00:00</code></pre>
<div class="sourceCode" id="cb200"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb200-1"><a href="#cb200-1"></a>two.mspct</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2015-10-31 08:00:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## --- Member: B ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2015-10-31 09:00:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
<p>Other methods available are <code>getWhereMeasured</code> and <code>setWhereMeasured</code>, and <code>getWhatMeasured</code> and <code>setWhatMeasured</code>.</p>
<p>Functions <code>when.measured2tb()</code>, <code>geocode2tb()</code>, <code>lon2tb()</code>, <code>lat2tb()</code> and <code>what.measured2tb()</code> extract these same attributes from collection members into a tibble or data frame. In contrast to the “get” methods described above, if an existing data frame or tibble with a matching number of rows is passed as second argument, the values for the attribute are saved into a new column appended at the right edge of the tibble or data frame.</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb202-1"><a href="#cb202-1"></a><span class="kw">when_measured2tb</span>(two.mspct)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   spct.idx when.measured      
##   &lt;fct&gt;    &lt;dttm&gt;             
## 1 A        2015-10-31 08:00:00
## 2 B        2015-10-31 09:00:00</code></pre>
<p>By default the new column is named after the name of the attribute, but this default can be overridden by the user.</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb204-1"><a href="#cb204-1"></a><span class="kw">when_measured2tb</span>(two.mspct, <span class="dt">col.names =</span> <span class="kw">c</span>(<span class="dt">when.measured =</span> <span class="st">&quot;time&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   spct.idx time               
##   &lt;fct&gt;    &lt;dttm&gt;             
## 1 A        2015-10-31 08:00:00
## 2 B        2015-10-31 09:00:00</code></pre>
<p>Function <code>add_attr2tb()</code> adds one or more columns with attributes to a tibble or data frame. We here also demonstrate that because the data frame object is passed to the first positional argument, we can use a <em>pipe</em>.</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb206-1"><a href="#cb206-1"></a><span class="kw">q_irrad</span>(two.mspct) <span class="op">%&gt;%</span></span>
<span id="cb206-2"><a href="#cb206-2"></a><span class="st">  </span><span class="kw">add_attr2tb</span>(two.mspct, </span>
<span id="cb206-3"><a href="#cb206-3"></a>              <span class="dt">col.names =</span> <span class="kw">c</span>(<span class="st">&quot;lon&quot;</span>, <span class="st">&quot;lat&quot;</span>, <span class="st">&quot;when.measured&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 2 x 5
##   spct.idx Q_Total   lon   lat when.measured      
##   &lt;fct&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt;             
## 1 A        0.00126  25.0  60.2 2015-10-31 08:00:00
## 2 B        0.00251  25.0  60.2 2015-10-31 09:00:00</code></pre>
<p>We can set the desired names for the columns if we wish them to be something else than the default.</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb208-1"><a href="#cb208-1"></a><span class="kw">q_irrad</span>(two.mspct) <span class="op">%&gt;%</span></span>
<span id="cb208-2"><a href="#cb208-2"></a><span class="st">  </span><span class="kw">add_attr2tb</span>(two.mspct, </span>
<span id="cb208-3"><a href="#cb208-3"></a>              <span class="dt">col.names =</span> <span class="kw">c</span>(<span class="dt">lon =</span> <span class="st">&quot;longitude&quot;</span>, </span>
<span id="cb208-4"><a href="#cb208-4"></a>                            <span class="dt">lat =</span> <span class="st">&quot;latitude&quot;</span>, </span>
<span id="cb208-5"><a href="#cb208-5"></a>                            <span class="dt">when.measured =</span> <span class="st">&quot;time&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 2 x 5
##   spct.idx Q_Total longitude latitude time               
##   &lt;fct&gt;      &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dttm&gt;             
## 1 A        0.00126      25.0     60.2 2015-10-31 08:00:00
## 2 B        0.00251      25.0     60.2 2015-10-31 09:00:00</code></pre>
</div>
</div>
<div id="wavebands" class="section level2">
<h2>Wavebands</h2>
<p>When a range of wavelengths or a range of wavelengths plus a spectral weighting function (SWF) is needed for radiation summaries or transformations, methods, operators and functions defined in package ‘<strong>photobiology</strong>’ use <code>waveband</code> objects to store these data. A few other bits of information can be included to fine-tune calculations. The waveband definitions do NOT describe whether input spectral irradiances are photon or energy based, nor whether the output irradiance will be based on photon or energy units. All waveband objects belong to the S3 class <code>waveband</code>.</p>
<div id="construction-2" class="section level3">
<h3>Construction</h3>
<p>When defining a waveband which uses a SWF, a function can be supplied either based on energy effectiveness, on photon effectiveness, or one function for each one. If only one function is supplied the other one is built automatically, but if performance is a concern it is better to provide two separate functions. Another case when you might want to enter the same function twice, is if you are using an absorptance spectrum as SWF, as the percent of radiation absorbed will be independent of whether photon or energy units are used for the spectral irradiance.</p>
<p>To create a waveband object we use constructor function <code>waveband</code>, and optionally giving a name to it. <strong>We will use these objects in many of the examples below, so you will need to run the code chunk bellow to be able to reproduce those examples.</strong> It should be noted that waveband constructors for the most frequently used wavelength-range definitions are provided by package ‘<strong>photobiologyWavebands</strong>’.</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb210-1"><a href="#cb210-1"></a>PAR.wb &lt;-<span class="st"> </span><span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">400</span>, <span class="dv">700</span>), <span class="dt">wb.name =</span> <span class="st">&quot;PAR&quot;</span>)</span>
<span id="cb210-2"><a href="#cb210-2"></a>UVA.wb &lt;-<span class="st"> </span><span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">315</span>, <span class="dv">400</span>), <span class="dt">wb.name =</span> <span class="st">&quot;UVA&quot;</span>)</span>
<span id="cb210-3"><a href="#cb210-3"></a>UVB.wb &lt;-<span class="st"> </span><span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">280</span>, <span class="dv">315</span>), <span class="dt">wb.name =</span> <span class="st">&quot;UVB&quot;</span>)</span>
<span id="cb210-4"><a href="#cb210-4"></a>UVC.wb &lt;-<span class="st"> </span><span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">280</span>), <span class="dt">wb.name =</span> <span class="st">&quot;UVC&quot;</span>)</span>
<span id="cb210-5"><a href="#cb210-5"></a>UV.wb  &lt;-<span class="st"> </span><span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">400</span>), <span class="dt">wb.name =</span>  <span class="st">&quot;UV&quot;</span>)</span>
<span id="cb210-6"><a href="#cb210-6"></a>UV_bands.lst &lt;-<span class="st"> </span><span class="kw">list</span>(UVC.wb, UVB.wb, UVA.wb)</span></code></pre></div>
<p>When including a BSWF, we can supply, one or two versions of functions returning the weights as a function of wavelength. Several such functions are defined in package ‘<strong>photobiologyWavebands</strong>’ as well as waveband constructors using them. Here we show how a waveband can be defined based on a SWF, using the CIE definition for the erythemal spectral weighting function. Although the constructor is smart enough to derive the missing function when only one function is supplied, performance may suffer unless two performance-optimized function are provided, one for energy-based effect and a second one for photon-based effect.</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb211-1"><a href="#cb211-1"></a>CIE_e_fun &lt;-</span>
<span id="cb211-2"><a href="#cb211-2"></a><span class="cf">function</span>(w.length){</span>
<span id="cb211-3"><a href="#cb211-3"></a>    CIE.energy &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(w.length))</span>
<span id="cb211-4"><a href="#cb211-4"></a>    CIE.energy[w.length <span class="op">&lt;=</span><span class="st"> </span><span class="dv">298</span>] &lt;-<span class="st"> </span><span class="dv">1</span></span>
<span id="cb211-5"><a href="#cb211-5"></a>    CIE.energy[(w.length <span class="op">&gt;</span><span class="st"> </span><span class="dv">298</span>) <span class="op">&amp;</span><span class="st"> </span>(w.length <span class="op">&lt;=</span><span class="st"> </span><span class="dv">328</span>)] &lt;-</span>
<span id="cb211-6"><a href="#cb211-6"></a><span class="st">      </span><span class="dv">10</span><span class="op">^</span>(<span class="fl">0.094</span><span class="op">*</span>(<span class="dv">298</span><span class="op">-</span>w.length[(w.length <span class="op">&gt;</span><span class="st"> </span><span class="dv">298</span>) <span class="op">&amp;</span><span class="st"> </span>(w.length <span class="op">&lt;=</span><span class="st"> </span><span class="dv">328</span>)]))</span>
<span id="cb211-7"><a href="#cb211-7"></a>    CIE.energy[(w.length <span class="op">&gt;</span><span class="st"> </span><span class="dv">328</span>) <span class="op">&amp;</span><span class="st"> </span>(w.length <span class="op">&lt;=</span><span class="st"> </span><span class="dv">400</span>)] &lt;-</span>
<span id="cb211-8"><a href="#cb211-8"></a><span class="st">      </span><span class="dv">10</span><span class="op">^</span>(<span class="fl">0.015</span><span class="op">*</span>(<span class="dv">139</span><span class="op">-</span>w.length[(w.length <span class="op">&gt;</span><span class="st"> </span><span class="dv">328</span>) <span class="op">&amp;</span><span class="st"> </span>(w.length <span class="op">&lt;=</span><span class="st"> </span><span class="dv">400</span>)]))</span>
<span id="cb211-9"><a href="#cb211-9"></a>    CIE.energy[w.length <span class="op">&gt;</span><span class="st"> </span><span class="dv">400</span>] &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb211-10"><a href="#cb211-10"></a>    <span class="kw">return</span>(CIE.energy)</span>
<span id="cb211-11"><a href="#cb211-11"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb212"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb212-1"><a href="#cb212-1"></a>CIE.wb &lt;-<span class="st"> </span><span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">250</span>, <span class="dv">400</span>), <span class="dt">weight =</span> <span class="st">&quot;SWF&quot;</span>,</span>
<span id="cb212-2"><a href="#cb212-2"></a>                   <span class="dt">SWF.e.fun =</span> CIE_e_fun, <span class="dt">SWF.norm =</span> <span class="dv">298</span>)</span></code></pre></div>
<p>The first argument to <code>waveband()</code> does not need to be a numeric vector of length two. Any R object of a class that supplies a <code>range()</code> method definition that can be interpreted as a range of wavelengths in nanometres can be used. As a consequence, when wanting to construct a waveband covering the whole range of a spectrum one can simply supply the spectrum as argument, or to construct an non-weighed waveband which covers exactly the same range of wavelengths as an existing effective (weighted) waveband, one can supply a waveband object as an argument.</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb213-1"><a href="#cb213-1"></a><span class="kw">waveband</span>(sun.spct)</span></code></pre></div>
<pre><code>## Total 
## low (nm) 280 
## high (nm) 800 
## weighted none</code></pre>
<p>An “empty” waveband is returned by some functions as a “null” value.</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb215-1"><a href="#cb215-1"></a><span class="kw">waveband</span>()</span></code></pre></div>
<pre><code>## range.NA.NA 
## low (nm) NA 
## high (nm) NA 
## weighted none</code></pre>
</div>
<div id="querying-the-class-2" class="section level3">
<h3>Querying the class</h3>
<p>The function <code>is.waveband</code> can the used to query any R object. This function returns a logical value.</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb217-1"><a href="#cb217-1"></a><span class="kw">is.waveband</span>(PAR.wb)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Above, we demonstrate that <code>PAR.wb</code> is a waveband object, the function <code>photobiologyWavebands::PAR()</code> is a waveband constructor returning a waveband object. See package ‘<strong>photobiologyWavebands</strong>’ for details on pre-defined waveband constructors for frequently used wavelength ranges and biological spectral weighting functions (BSWFs).</p>
</div>
<div id="retrieving-properties" class="section level3">
<h3>Retrieving properties</h3>
<p>The function <code>is_effective</code> can the used to query any R object.</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb219-1"><a href="#cb219-1"></a><span class="kw">is_effective</span>(<span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">400</span>,<span class="dv">500</span>)))</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
</div>
</div>
<div id="collections-of-wavebands" class="section level2">
<h2>Collections of wavebands</h2>
<p>In the current implementation there is no special class used for storing collections of <code>waveband</code> objects. We simply use base R’s <code>list</code> class.</p>
<div id="construction-3" class="section level3">
<h3>Construction</h3>
<div id="list-constructor" class="section level4">
<h4>List constructor</h4>
<p>Just base R’s functions used to create a list object.</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb221-1"><a href="#cb221-1"></a>wavebands &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">300</span>,<span class="dv">400</span>)), <span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">400</span>,<span class="dv">500</span>)))</span>
<span id="cb221-2"><a href="#cb221-2"></a>wavebands</span></code></pre></div>
<pre><code>## [[1]]
## range.300.400 
## low (nm) 300 
## high (nm) 400 
## weighted none 
## 
## [[2]]
## range.400.500 
## low (nm) 400 
## high (nm) 500 
## weighted none</code></pre>
</div>
<div id="special-constructor" class="section level4">
<h4>Special constructor</h4>
<p>The function <code>split_bands</code> can be used to generate lists of non-weighed wavebands in two different ways: a) it can be used to split a range of wavelengths given by an R object into a series of adjacent wavebands, or b) with a list of objects returning ranges, it can be used to create non-adjacent and even overlapping wavebands.</p>
<p>The code chunk bellow shows an example of two variations of case a). With the default value for <code>length.out</code> of <code>NULL</code> each numerical value in the input is taken as a wavelength (nm) at the boundary between adjacent wavebands. If a numerical value is supplied to <code>length.out</code>, then the whole wavelength range of the input is split into this number of equally spaced adjacent wavebands.</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb223-1"><a href="#cb223-1"></a><span class="kw">split_bands</span>(<span class="kw">c</span>(<span class="dv">200</span>, <span class="dv">225</span>, <span class="dv">300</span>))</span></code></pre></div>
<pre><code>## $wb1
## range.200.225 
## low (nm) 200 
## high (nm) 225 
## weighted none 
## 
## $wb2
## range.225.300 
## low (nm) 225 
## high (nm) 300 
## weighted none</code></pre>
<div class="sourceCode" id="cb225"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb225-1"><a href="#cb225-1"></a><span class="kw">split_bands</span>(<span class="kw">c</span>(<span class="dv">200</span>, <span class="dv">225</span>, <span class="dv">300</span>), <span class="dt">length.out =</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## $wb1
## range.200.250 
## low (nm) 200 
## high (nm) 250 
## weighted none 
## 
## $wb2
## range.250.300 
## low (nm) 250 
## high (nm) 300 
## weighted none</code></pre>
<p>In both examples above, the output is a list of two wavebands, but the <em>split</em> boundaries are at a different wavelength. The chunk bellow gives a few more examples of the use of case a).</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb227-1"><a href="#cb227-1"></a><span class="kw">split_bands</span>(sun.spct, <span class="dt">length.out =</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## $wb1
## range.280.540 
## low (nm) 280 
## high (nm) 540 
## weighted none 
## 
## $wb2
## range.540.800 
## low (nm) 540 
## high (nm) 800 
## weighted none</code></pre>
<div class="sourceCode" id="cb229"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb229-1"><a href="#cb229-1"></a><span class="kw">split_bands</span>(PAR.wb, <span class="dt">length.out =</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## $wb1
## range.400.550 
## low (nm) 400 
## high (nm) 550 
## weighted none 
## 
## $wb2
## range.550.700 
## low (nm) 550 
## high (nm) 700 
## weighted none</code></pre>
<div class="sourceCode" id="cb231"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb231-1"><a href="#cb231-1"></a><span class="kw">split_bands</span>(<span class="kw">c</span>(<span class="dv">200</span>, <span class="dv">800</span>), <span class="dt">length.out =</span> <span class="dv">3</span>)</span></code></pre></div>
<pre><code>## $wb1
## range.200.400 
## low (nm) 200 
## high (nm) 400 
## weighted none 
## 
## $wb2
## range.400.600 
## low (nm) 400 
## high (nm) 600 
## weighted none 
## 
## $wb3
## range.600.800 
## low (nm) 600 
## high (nm) 800 
## weighted none</code></pre>
<p>Now we demonstrate case b). This case is handled by recursion, so each list element can be anything that is a valid input to the function, including a nested list. However, the returned value is always a flat list of wavebands.</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb233-1"><a href="#cb233-1"></a><span class="kw">split_bands</span>(<span class="kw">list</span>(<span class="dt">A =</span> <span class="kw">c</span>(<span class="dv">200</span>, <span class="dv">300</span>), <span class="dt">B =</span> <span class="kw">c</span>(<span class="dv">400</span>, <span class="dv">500</span>), <span class="dt">C =</span> <span class="kw">c</span>(<span class="dv">250</span>, <span class="dv">350</span>)))</span></code></pre></div>
<pre><code>## $A
## range.200.300 
## low (nm) 200 
## high (nm) 300 
## weighted none 
## 
## $B
## range.400.500 
## low (nm) 400 
## high (nm) 500 
## weighted none 
## 
## $C
## range.250.350 
## low (nm) 250 
## high (nm) 350 
## weighted none</code></pre>
<div class="sourceCode" id="cb235"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb235-1"><a href="#cb235-1"></a><span class="kw">split_bands</span>(<span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">150</span>, <span class="dv">200</span>), <span class="kw">c</span>(<span class="dv">800</span>, <span class="dv">825</span>)))</span></code></pre></div>
<pre><code>## $wb.a
## range.100.150 
## low (nm) 100 
## high (nm) 150 
## weighted none 
## 
## $&lt;NA&gt;
## range.150.200 
## low (nm) 150 
## high (nm) 200 
## weighted none 
## 
## $wb.b
## range.800.825 
## low (nm) 800 
## high (nm) 825 
## weighted none</code></pre>
<p>In case b) if we supply a numeric value to <code>length.out</code>, this value is used recursively for each element of the list.</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb237-1"><a href="#cb237-1"></a><span class="kw">split_bands</span>(UV_bands.lst, <span class="dt">length.out  =</span>  <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## $wb.a
## range.100.190 
## low (nm) 100 
## high (nm) 190 
## weighted none 
## 
## $&lt;NA&gt;
## range.190.280 
## low (nm) 190 
## high (nm) 280 
## weighted none 
## 
## $wb.b
## range.280.297.5 
## low (nm) 280 
## high (nm) 298 
## weighted none 
## 
## $&lt;NA&gt;
## range.297.5.315 
## low (nm) 298 
## high (nm) 315 
## weighted none 
## 
## $wb.c
## range.315.357.5 
## low (nm) 315 
## high (nm) 358 
## weighted none 
## 
## $&lt;NA&gt;
## range.357.5.400 
## low (nm) 358 
## high (nm) 400 
## weighted none</code></pre>
<div class="sourceCode" id="cb239"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb239-1"><a href="#cb239-1"></a><span class="kw">split_bands</span>(<span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">150</span>, <span class="dv">200</span>), <span class="kw">c</span>(<span class="dv">800</span>, <span class="dv">825</span>)), <span class="dt">length.out =</span> <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## $wb.a
## range.100.200 
## low (nm) 100 
## high (nm) 200 
## weighted none 
## 
## $wb.b
## range.800.825 
## low (nm) 800 
## high (nm) 825 
## weighted none</code></pre>
</div>
</div>
</div>
<div id="object-inspection-methods" class="section level2">
<h2>Object <em>inspection</em> methods</h2>
<div id="printing" class="section level3">
<h3>Printing</h3>
<p>The <code>print()</code> method for spectra is based on the method defined in package ‘<strong>tibble</strong>’, consequently, it is possible to use the options from this package to control printing. In the code chunk below, <code>tibble.print_max</code>, the number of rows in the spectral object above which only <code>tibble.print_min</code> rows are printed, are both set to 5, instead of the default 20 and 10, to avoid excessive clutter in our examples.</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb241-1"><a href="#cb241-1"></a><span class="kw">options</span>(<span class="dt">tibble.print_max =</span> <span class="dv">4</span>)</span>
<span id="cb241-2"><a href="#cb241-2"></a><span class="kw">options</span>(<span class="dt">tibble.print_min =</span> <span class="dv">4</span>)</span></code></pre></div>
<p>For explicit calls to <code>print()</code> its argument <code>n</code> can be used to control the number of lines printed. If <code>n</code> is set to <code>Inf</code> the whole spectrum is always printed. The output differs from that of the <code>print()</code> method from package ‘dplyr’ in that additional metadata specific to spectra are shown.</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb242-1"><a href="#cb242-1"></a><span class="kw">print</span>(sun.spct, <span class="dt">n =</span> <span class="dv">3</span>)</span></code></pre></div>
<p>Specialized <code>print()</code> methods for collections of spectra and for <code>waveband</code> objects are also defined.</p>
</div>
<div id="summary" class="section level3">
<h3>Summary</h3>
<p>The <code>summary()</code> method for spectra is based on base R’s <code>summary()</code> method for data frames, and accepts the same arguments. The main difference is that the attributes containing metadata and dimensions of the original spectrum object are copied to the summary object.</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb243-1"><a href="#cb243-1"></a><span class="kw">summary</span>(sun.spct)</span></code></pre></div>
<p>Specialized <code>print()</code> methods for summaries of spectra are defined. The output differs from that of the <code>print()</code> method from base R in that additional metadata specific to spectra are shown.</p>
</div>
<div id="handling-nas" class="section level3">
<h3>Handling <code>NA</code>s</h3>
<p>Functions <code>na.omit()</code> and <code>na.exclude</code> are implemented for all spectral classes. These methods test for <code>NA</code>s only the spectral data, not wavelength. They set the <code>&quot;na.action&quot;</code> attribute in the same way as the corresponding methods for data frames. In the case of <code>na.fail()</code>, <code>na.pass()</code> and <code>na.action()</code>, the methods from base R, can be used with spectra.</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb244-1"><a href="#cb244-1"></a><span class="kw">na.omit</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb246"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb246-1"><a href="#cb246-1"></a><span class="kw">na.exclude</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
</div>
</div>
<div id="transformations-using-operators" class="section level2">
<h2>Transformations: using operators</h2>
<div id="binary-operators" class="section level3">
<h3>Binary operators</h3>
<p>All of R’s built-in maths operators have definitions for spectra. It is possible to sum, subtract, multiply and divide spectra. These operators can be used even if the spectral data is on different arbitrary sets of wavelengths. Operators by default return values expressed in energy units. Only certain operations are meaningful for a given combination of objects belonging to different classes, and meaningless combinations return <code>NA</code> also issuing a warning (see Table 5). By default operations are carried out on spectral energy irradiance for <code>source_spct</code> objects and transmittance for <code>filter_spct</code> objects.</p>
<hr>
<p><strong>Table 5. Binary operators and their operands.</strong> Validity and class of result. All operations marked <code>\Y&#39; are allowed, those marked</code>’ are forbidden and return <code>NA</code> and issue a warning. Operators <code>%/%</code> and <code>%%</code> follow <code>/</code>.</p>
<table>
<thead>
<tr class="header">
<th align="left">e1</th>
<th align="center"><code>+</code></th>
<th align="center"><code>-</code></th>
<th align="center"><code>*</code></th>
<th align="center"><code>/</code></th>
<th align="center"><code>^</code></th>
<th align="left">e2</th>
<th align="left">value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>raw_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>raw_spct</code></td>
<td align="left"><code>raw_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>cps_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>cps_spct</code></td>
<td align="left"><code>cps_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>source_spct</code></td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>filter_spct</code> (T)</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>filter_spct</code></td>
<td align="left"><code>filter_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>filter_spct</code> (A)</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>filter_spct</code></td>
<td align="left"><code>filter_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>reflector_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>reflector_spct</code></td>
<td align="left"><code>reflector_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>object_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>object_spct</code></td>
<td align="left">–</td>
</tr>
<tr class="even">
<td align="left"><code>response_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>response_spct</code></td>
<td align="left"><code>response_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>chroma_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>chroma_spct</code></td>
<td align="left"><code>chroma_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>raw_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>raw_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>cps_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>cps_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>calibration_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>calibration_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>filter_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>filter_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>reflector_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>reflector_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>object_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>numeric</code></td>
<td align="left">–</td>
</tr>
<tr class="odd">
<td align="left"><code>response_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>response_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>chroma_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>numeric</code></td>
<td align="left"><code>chroma_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>cps_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>calibration_spct</code></td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>response_spct</code></td>
<td align="left"><code>response_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>filter_spct</code> (T)</td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>filter_spct</code> (A)</td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="left"><code>reflector_spct</code></td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>object_spct</code></td>
<td align="left">–</td>
</tr>
<tr class="odd">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>waveband</code> (no BSWF)</td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>source_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left"><code>waveband</code> (BSWF)</td>
<td align="left"><code>source_spct</code> (effective)</td>
</tr>
</tbody>
</table>
<hr>
<div class="sourceCode" id="cb248"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb248-1"><a href="#cb248-1"></a>sun.spct <span class="op">*</span><span class="st"> </span>sun.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<p>When meaningful, operations between different spectra are also allowed. For example, it is possible to simulate the effect of a filter on a light source by multiplying (or convolving) the two spectra.</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb250-1"><a href="#cb250-1"></a>sun.spct <span class="op">*</span><span class="st"> </span>polyester.spct</span></code></pre></div>
<pre><code>## Object: source_spct [533 x 2]
## Wavelength range 280 to 800 nm, step 0.07692308 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 533 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     281          0
## 4     282.         0
## # ... with 529 more rows</code></pre>
<p>If we have two layers of the filter, this can be approximated using either of these two statements.</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb252-1"><a href="#cb252-1"></a>sun.spct <span class="op">*</span><span class="st"> </span>polyester.spct <span class="op">*</span><span class="st"> </span>polyester.spct</span></code></pre></div>
<pre><code>## Object: source_spct [533 x 2]
## Wavelength range 280 to 800 nm, step 0.07692308 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 533 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     281          0
## 4     282.         0
## # ... with 529 more rows</code></pre>
<div class="sourceCode" id="cb254"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb254-1"><a href="#cb254-1"></a>sun.spct <span class="op">*</span><span class="st"> </span>polyester.spct<span class="op">^</span><span class="dv">2</span></span></code></pre></div>
<pre><code>## Object: source_spct [533 x 2]
## Wavelength range 280 to 800 nm, step 0.07692308 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 533 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     281          0
## 4     282.         0
## # ... with 529 more rows</code></pre>
<p>Operators are also defined for operations between a spectrum and a numeric vector (with normal recycling).</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb256-1"><a href="#cb256-1"></a>sun.spct <span class="op">*</span><span class="st"> </span><span class="dv">2</span></span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb258"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb258-1"><a href="#cb258-1"></a><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>sun.spct</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb260"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb260-1"><a href="#cb260-1"></a>sun.spct <span class="op">*</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<p>There is one special case, for <code>chroma_spct</code>: if the numeric operand has length three, containing three <em>named</em> values <em>x</em>, <em>y</em> and <em>z</em>, the corresponding value is used for each of the chromaticity <em>columns</em> in the <code>chroma_spct</code>. Un-named values or differently named values are not treated specially.</p>
<p>Operators are also defined for operations between an spectrum and a <code>waveband</code> object. The next to code chunks demonstrate how the class of the result depends on whether the <code>waveband</code> object describes a range of wavelengths or a range of wavelengths plus a BSWF.</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb262-1"><a href="#cb262-1"></a>sun.spct <span class="op">*</span><span class="st"> </span>UVB.wb</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280 to 315 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 37 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 33 more rows</code></pre>
<div class="sourceCode" id="cb264"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb264-1"><a href="#cb264-1"></a>sun.spct <span class="op">*</span><span class="st"> </span>CIE.wb</span></code></pre></div>
<p>And of course these operations can be combined into more complex statements, including parentheses, when needed. The example below estimates the difference in effective spectral irradiance according to the CIE98 definition, between sunlight and sunlight filtered with a polyester film. Of course, the result is valid only for the solar spectral data used, which corresponds to Southern Finland.</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb265-1"><a href="#cb265-1"></a>sun.spct <span class="op">*</span><span class="st"> </span>CIE.wb <span class="op">-</span><span class="st"> </span>sun.spct <span class="op">*</span><span class="st"> </span>polyester.spct <span class="op">*</span><span class="st"> </span>CIE.wb</span></code></pre></div>
<pre><code>## Object: source_spct [133 x 2]
## Wavelength range 280 to 400 nm, step 0.07692308 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## Data weighted using &#39;range.250.400.wtd&#39; BSWF
## 
## # A tibble: 133 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     281          0
## 4     282.         0
## # ... with 129 more rows</code></pre>
</div>
<div id="unary-operators-and-maths-functions" class="section level3">
<h3>Unary operators and maths functions</h3>
<p>Many common maths functions, as well as unary minus and plus, are implemented for spectral objects (see Table 6).</p>
<hr>
<p><strong>Table 6. Unary operators and maths functions for spectra.</strong> Classes for which they are implemented and class of the result. All operations marked Y are allowed, those marked N are not implemented and return <code>NA</code> and issue a warning. Additional supported functions: <code>log2, log10, sin, cos, tan, asin, acos, atan, sinpi, cospi, tanpi, signif, floor, ceiling, trunc, sign, abs</code>.</p>
<table>
<thead>
<tr class="header">
<th align="left">e1</th>
<th align="center"><code>+, -</code></th>
<th align="center"><code>log, exp</code></th>
<th align="center">trig.</th>
<th align="center"><code>round</code></th>
<th align="center"><code>sqrt</code></th>
<th align="left">value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>raw_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>raw_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>cps_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>cps_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>calibration_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>calibration_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>source_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>source_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>filter_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>filter_spct</code></td>
</tr>
<tr class="even">
<td align="left"><code>reflector_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>reflector_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>object_spct</code></td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="left">–</td>
</tr>
<tr class="even">
<td align="left"><code>response_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>response_spct</code></td>
</tr>
<tr class="odd">
<td align="left"><code>chroma_spct</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="left"><code>chroma_spct</code></td>
</tr>
</tbody>
</table>
<hr>
<div class="sourceCode" id="cb267"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb267-1"><a href="#cb267-1"></a><span class="op">-</span>sun.spct</span></code></pre></div>
<pre><code>## Warning in range_check(x, strict.range = strict.range): Negative spectral energy
## irradiance values; minimum s.e.irrad = -0.82</code></pre>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb270"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb270-1"><a href="#cb270-1"></a><span class="kw">sqrt</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
</div>
<div id="options" class="section level3">
<h3>Options</h3>
<p>Table 7 lists all the recognized options affecting maths operators and functions, and their default values. Within the suite all functions have a default value which is used when the options are undefined. Options are set using base R’s function <code>options</code>, and queried with functions <code>options</code> and <code>getOption</code>.</p>
<hr>
<p><strong>Table 7. Options used in the ‘r4photobiology suite’ and recognized by methods, operators and functions in the ‘photobiology’ package.</strong> Option names, accepted and default values, and the purpose of the options are given. Option <code>photobiology.verbose</code> is set to the value of R’s own <code>verbose</code> option at the time the ‘photobiology’ package is attached to the session.</p>
<table>
<colgroup>
<col width="8%"></col>
<col width="26%"></col>
<col width="44%"></col>
<col width="21%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Option</th>
<th align="left"><code>values</code>, <strong>default</strong></th>
<th align="left">purpose, <em>unit</em></th>
<th><em>convenience function</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>Base R</strong></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr class="even">
<td align="left"><code>digits</code></td>
<td align="left">7</td>
<td align="left"><span class="math inline">\(d - 3\)</span> used by <code>summary</code></td>
<td></td>
</tr>
<tr class="odd">
<td align="left"><strong>tibble</strong></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr class="even">
<td align="left">tibble.print_max</td>
<td align="left"><strong>20</strong></td>
<td align="left">Maximum number of rows printed</td>
<td></td>
</tr>
<tr class="odd">
<td align="left">tibble.print_min</td>
<td align="left"><strong>10</strong></td>
<td align="left">Number of rows printed if row number threshold is exceeded</td>
<td></td>
</tr>
<tr class="even">
<td align="left">tibble.width</td>
<td align="left"><strong>NULL</strong></td>
<td align="left">Output width</td>
<td></td>
</tr>
<tr class="odd">
<td align="left"><strong>r4photobiology</strong></td>
<td align="left"></td>
<td align="left"></td>
<td></td>
</tr>
<tr class="even">
<td align="left">photobiology.radiation.unit</td>
<td align="left"><strong>“energy”</strong></td>
<td align="left"><span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span></td>
<td><code>using_energy()</code>, <code>energy_as_default()</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>&quot;photon&quot;</code></td>
<td align="left"><span class="math inline">\(\mu mol\,m^{-2}\,nm^{-1}\)</span></td>
<td><code>using_photon()</code>, <code>photon_as_default()</code></td>
</tr>
<tr class="even">
<td align="left">photobiology.filter.qty</td>
<td align="left"><strong>“transmittance”</strong></td>
<td align="left"><span class="math inline">\(/1\)</span></td>
<td><code>using_Tfr()</code>, <code>Tfr_as_default()</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>&quot;absorptance&quot;</code></td>
<td align="left"><span class="math inline">\(/1\)</span></td>
<td><code>using_Afr()</code>, <code>Afr_as_default()</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>&quot;absorbance&quot;</code></td>
<td align="left">a.u. <span class="math inline">\(\log_{10}\)</span> base</td>
<td><code>using_A()</code>, <code>A_as_default()</code></td>
</tr>
<tr class="odd">
<td align="left">photobiology.strict.range</td>
<td align="left"><code>NA</code></td>
<td align="left">skip range test</td>
<td><code>strict_range_as_default(NA)</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>TRUE</code></td>
<td align="left">trigger an error</td>
<td><code>strict_range_as_default(TRUE)</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><strong>FALSE</strong></td>
<td align="left">trigger a warning</td>
<td><code>strict_range_as_default(FALSE)</code></td>
</tr>
<tr class="even">
<td align="left">photobiology.check.spct</td>
<td align="left"><strong>TRUE</strong></td>
<td align="left">enable <code>check_spct()</code></td>
<td><code>enable_check_spct()</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>FALSE</code></td>
<td align="left">disable <code>check_spct()</code></td>
<td><code>disable_check_spct()</code></td>
</tr>
<tr class="even">
<td align="left">photobiology.waveband.trim</td>
<td align="left"><code>FALSE</code></td>
<td align="left">exclude</td>
<td><code>wb_trim_as_default(FALSE)</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><strong>TRUE</strong></td>
<td align="left">trim or exclude</td>
<td><code>wb_trim_as_default(TRUE)</code></td>
</tr>
<tr class="even">
<td align="left">photobiology.use.cached.mult</td>
<td align="left"><strong>FALSE</strong></td>
<td align="left">do not cache intermediate results</td>
<td><code>use_cached_mult_as_default(FALSE)</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>TRUE</code></td>
<td align="left">cache intermediate results</td>
<td><code>use_cached_mult_as_default(TRUE)</code></td>
</tr>
<tr class="even">
<td align="left">photobiology.verbose</td>
<td align="left"><code>FALSE</code></td>
<td align="left">minimal warnings and messages</td>
<td><code>verbose_as_default(FALSE)</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>TRUE</code></td>
<td align="left">all warnings and messages</td>
<td><code>verbose_as_default(TRUE)</code></td>
</tr>
</tbody>
</table>
<p>The behavior of the operators defined in this package depends on the value of two global options. For example, if we would like the operators to operate on spectral photon irradiance and return spectral photon irradiance instead of spectral energy irradiance, this behavior can be set, and will remain active until unset or reset. It is possible to change options using base R’s function <code>options()</code> as shown in the next code chunk. The other options listed in the Table above can be set similarly, while to unset any option, they can be given a <code>NULL</code> value.</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb272-1"><a href="#cb272-1"></a><span class="kw">options</span>(<span class="dt">photobiology.radiation.unit =</span> <span class="st">&quot;photon&quot;</span>)</span>
<span id="cb272-2"><a href="#cb272-2"></a>sun.spct <span class="op">*</span><span class="st"> </span>UVB.wb</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280 to 315 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 37 x 2
##   w.length s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 33 more rows</code></pre>
<div class="sourceCode" id="cb274"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb274-1"><a href="#cb274-1"></a><span class="kw">options</span>(<span class="dt">photobiology.radiation.unit =</span> <span class="st">&quot;energy&quot;</span>)</span>
<span id="cb274-2"><a href="#cb274-2"></a>sun.spct <span class="op">*</span><span class="st"> </span>UVB.wb</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280 to 315 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 37 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 33 more rows</code></pre>
<p>However using convenience functions is easier. The chunk above can be rewritten as below.</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb276-1"><a href="#cb276-1"></a><span class="kw">photon_as_default</span>()</span>
<span id="cb276-2"><a href="#cb276-2"></a>sun.spct <span class="op">*</span><span class="st"> </span>UVB.wb</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280 to 315 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 37 x 2
##   w.length s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 33 more rows</code></pre>
<div class="sourceCode" id="cb278"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb278-1"><a href="#cb278-1"></a><span class="kw">energy_as_default</span>()</span>
<span id="cb278-2"><a href="#cb278-2"></a>sun.spct <span class="op">*</span><span class="st"> </span>UVB.wb</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280 to 315 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 37 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 33 more rows</code></pre>
<div class="sourceCode" id="cb280"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb280-1"><a href="#cb280-1"></a><span class="kw">unset_radiation_unit_default</span>()</span></code></pre></div>
<p>Furthermore, it is possible to temporarily change the options for the evaluation of a single, possibly compound, R expression using a different syntax, reminiscent of that of R’s <code>with()</code>.</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb281-1"><a href="#cb281-1"></a><span class="kw">using_photon</span>(sun.spct <span class="op">*</span><span class="st"> </span>UVB.wb)</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280 to 315 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 37 x 2
##   w.length s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 33 more rows</code></pre>
<div class="sourceCode" id="cb283"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb283-1"><a href="#cb283-1"></a><span class="kw">using_energy</span>(sun.spct <span class="op">*</span><span class="st"> </span>UVB.wb)</span></code></pre></div>
<pre><code>## Object: source_spct [37 x 2]
## Wavelength range 280 to 315 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 37 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 33 more rows</code></pre>
</div>
</div>
<div id="transformations-methods-and-functions" class="section level2">
<h2>Transformations: methods and functions</h2>
<p>In this section we describe methods and functions that take one or more spectral objects, and in some cases also waveband objects, as arguments and return another spectral object (see Tables 8 and 9) or that take a collection of spectral objects, and in some cases also waveband objects, as arguments and return a collection of spectral objects.</p>
<hr>
<p><strong>Table 8. Transformation methods for spectra.</strong> Key: + available, – not available.</p>
<table>
<thead>
<tr class="header">
<th align="left">methods</th>
<th align="center">raw/cps</th>
<th align="center">source</th>
<th align="center">response</th>
<th align="center">filter</th>
<th align="center">reflector</th>
<th align="center">object</th>
<th align="center">chroma</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">merge</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">rbindspct</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">e2q, q2e</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">A2T, T2A</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">Afr2T, T2Afr</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">any2T, any2A, any2Afr</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">convertTfrType</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">convertThickness</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">subset</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">clip_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">trim_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">(trim_spct)</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">thin_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">interpolate_wl</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">(interpolate_spct)</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">fscale</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">fshift</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">normalize</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">clean</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">despike</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left"><em>maths operators</em></td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left"><em>maths functions</em></td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">tag</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">untag</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
</tbody>
</table>
<hr>
<hr>
<p><strong>Table 9. Transformation methods for collections of spectra.</strong> Key: + available, – not available, <strong>ms</strong> use <code>msmsply()</code> or <code>convolve_each()</code> to apply function or operator to collection members.</p>
<table>
<thead>
<tr class="header">
<th align="left">methods</th>
<th align="center">raw/cps</th>
<th align="center">source</th>
<th align="center">response</th>
<th align="center">filter</th>
<th align="center">reflector</th>
<th align="center">object</th>
<th align="center">chroma</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">convolve_each</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">msmsply</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">msdply</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">mslply</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">msaply</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">rbindspct</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">c</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left"><em>maths operators</em></td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
</tr>
<tr class="odd">
<td align="left"><em>maths functions</em></td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
<td align="center">ms</td>
</tr>
<tr class="even">
<td align="left">e2q, q2e</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">A2T, T2A</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">Afr2T, T2Afr</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">any2T, any2A, any2Afr</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">convertTfrType</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">convertThickness</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">clip_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">trim_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">trim2overlap</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">extend2extremes</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">(trim_mspct)</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">thin_wl</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">interpolate_wl</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">(interpolate_mspct)</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">fscale</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">fshift</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">normalize</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">clean</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">despike</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">tag</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">untag</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
</tbody>
</table>
<hr>
<div id="manipulating-spectra" class="section level3">
<h3>Manipulating spectra</h3>
<p>Sometimes, especially for plotting, we may want to row-bind spectra. When the aim is that the returned object retains its class and other attributes like the time unit. Package ‘<strong>photobiology</strong>’ provides function <code>rbinspct</code> for row-binding spectra, with the necessary checks for consistency of the bound spectra.</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb285-1"><a href="#cb285-1"></a><span class="co"># STOPGAP</span></span>
<span id="cb285-2"><a href="#cb285-2"></a>shade.spct &lt;-<span class="st"> </span>sun.spct</span></code></pre></div>
<p>By default an ID factor named <code>spct.idx</code> is added allow to identify the source of the observations after the binding. If the supplied list has named members, then these names are used as factor levels. If a character value is supplied to as <code>idfactor</code> argument, this is used as name for the factor.</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb286-1"><a href="#cb286-1"></a><span class="kw">rbindspct</span>(<span class="kw">list</span>(sun.spct, shade.spct))</span></code></pre></div>
<pre><code>## Object: source_spct [1,044 x 4]
## containing 2 spectra in long form
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## spct_1 label: sunlight, simulated
## spct_2 label: sunlight, simulated 
## spct_1 measured on 2010-06-22 09:51:00 UTC
## spct_2 measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 1,044 x 4
##   w.length s.e.irrad s.q.irrad spct.idx
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;   
## 1     280          0         0 spct_1  
## 2     281.         0         0 spct_1  
## 3     282.         0         0 spct_1  
## 4     283.         0         0 spct_1  
## # ... with 1,040 more rows</code></pre>
<div class="sourceCode" id="cb288"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb288-1"><a href="#cb288-1"></a><span class="kw">rbindspct</span>(<span class="kw">list</span>(<span class="dt">A =</span> sun.spct, <span class="dt">B =</span> shade.spct), <span class="dt">idfactor =</span> <span class="st">&quot;site&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1,044 x 4]
## containing 2 spectra in long form
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## A label: sunlight, simulated
## B label: sunlight, simulated 
## A measured on 2010-06-22 09:51:00 UTC
## B measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 1,044 x 4
##   w.length s.e.irrad s.q.irrad site 
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;
## 1     280          0         0 A    
## 2     281.         0         0 A    
## 3     282.         0         0 A    
## 4     283.         0         0 A    
## # ... with 1,040 more rows</code></pre>
<p>The name of the ID factor is stored as metadata in attribute <code>&quot;idfactor&quot;</code> of the spectral data object.</p>
<p>Special <em>Extract</em> methods for spectral objects have been implemented. These are used by default and preserve the attributes used by this package, except when the returned value is a single column from the spectral object.</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb290-1"><a href="#cb290-1"></a>sun.spct[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, ]</span></code></pre></div>
<pre><code>## Object: source_spct [10 x 3]
## Wavelength range 280 to 288.30769 nm, step 0.9230769 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 10 x 3
##   w.length s.e.irrad s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 6 more rows</code></pre>
<div class="sourceCode" id="cb292"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb292-1"><a href="#cb292-1"></a>sun.spct[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dv">1</span>]</span></code></pre></div>
<pre><code>##  [1] 280.0000 280.9231 281.8462 282.7692 283.6923 284.6154 285.5385 286.4615
##  [9] 287.3846 288.3077</code></pre>
<div class="sourceCode" id="cb294"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb294-1"><a href="#cb294-1"></a>sun.spct[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dv">1</span>, drop =<span class="st"> </span><span class="ot">TRUE</span>]</span></code></pre></div>
<pre><code>##  [1] 280.0000 280.9231 281.8462 282.7692 283.6923 284.6154 285.5385 286.4615
##  [9] 287.3846 288.3077</code></pre>
<div class="sourceCode" id="cb296"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb296-1"><a href="#cb296-1"></a>sun.spct[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="st">&quot;w.length&quot;</span>, drop =<span class="st"> </span><span class="ot">TRUE</span>]</span></code></pre></div>
<pre><code>##  [1] 280.0000 280.9231 281.8462 282.7692 283.6923 284.6154 285.5385 286.4615
##  [9] 287.3846 288.3077</code></pre>
<p>In contrast to <code>trim_spct</code>, <code>subset</code> never interpolates or inserts <em>hinges</em>. On the other hand, the <code>subset</code> argument accepts any logical expression and can be consequently used to do subsetting, for example, based on factors. Both <code>subset()</code> and <code>trim()</code> methods preserve attributes.</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb298-1"><a href="#cb298-1"></a><span class="kw">subset</span>(sun.spct, s.e.irrad <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.2</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [475 x 3]
## Wavelength range 324 to 800 nm, step 1 to 3 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 475 x 3
##   w.length s.e.irrad   s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1      324     0.208 0.000000562
## 2      325     0.217 0.000000589
## 3      326     0.277 0.000000756
## 4      327     0.285 0.000000779
## # ... with 471 more rows</code></pre>
<div class="sourceCode" id="cb300"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb300-1"><a href="#cb300-1"></a><span class="kw">subset</span>(sun.spct, w.length <span class="op">&gt;</span><span class="st"> </span><span class="dv">600</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [200 x 3]
## Wavelength range 601 to 800 nm, step 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 200 x 3
##   w.length s.e.irrad  s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1      601     0.630 0.00000316
## 2      602     0.631 0.00000317
## 3      603     0.636 0.00000321
## 4      604     0.658 0.00000332
## # ... with 196 more rows</code></pre>
<div class="sourceCode" id="cb302"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb302-1"><a href="#cb302-1"></a><span class="kw">subset</span>(sun.spct, <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="kw">rep</span>(<span class="ot">FALSE</span>, <span class="dv">99</span>)))</span></code></pre></div>
<pre><code>## Object: source_spct [6 x 3]
## Wavelength range 280 to 779 nm, step 99 to 100 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 6 x 3
##   w.length s.e.irrad  s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1      280     0     0         
## 2      379     0.413 0.00000131
## 3      479     0.754 0.00000302
## 4      579     0.647 0.00000313
## 5      679     0.580 0.00000329
## 6      779     0.471 0.00000307</code></pre>
<p>R’s Extract methods <code>$</code> and <code>[[</code> can be used to extract whole columns. Replace methods <code>$&lt;-</code> and <code>[&lt;-</code> have definitions for spectral objects, which allow their safe use. They work identically to those for data frames but check the validity of the spectra after the replacement.</p>
</div>
<div id="conversions-between-radiation-units" class="section level3">
<h3>Conversions between radiation units</h3>
<p>The functions <code>e2q</code> and <code>q2e</code> can be used on source spectra to convert spectral energy irradiance into spectral photon irradiance and vice versa. A second optional argument sets the action with <code>&quot;add&quot;</code> and <code>&quot;replace&quot;</code> as possible values. By default these functions use normal reference semantics.</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb304-1"><a href="#cb304-1"></a><span class="kw">e2q</span>(sun.spct, <span class="st">&quot;add&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb306"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb306-1"><a href="#cb306-1"></a><span class="kw">e2q</span>(sun.spct, <span class="st">&quot;replace&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
</div>
<div id="conversions-among-transmission-quantities" class="section level3">
<h3>Conversions among transmission quantities</h3>
<p>For <code>filter_spct</code> objects functions <code>any2T()</code>, <code>any2A()</code>, and <code>any2Afr()</code> allow conversion among spectral transmittance, spectral absorptance and spectral absorbance. Although some conversions require a known reflectance, either as an <code>Rfr</code> column in the data or an <code>Rfr.constant</code> in the attribute <code>filter.properties</code>.</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb308-1"><a href="#cb308-1"></a><span class="kw">any2Afr</span>(polyester.spct, <span class="st">&quot;add&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_spct [611 x 3]
## Wavelength range 190 to 800 nm, step 1 nm 
## Label: clear polyester film 
## Transmittance of type &#39;total&#39;
## Rfr (/1): 0.07, thickness (mm): 0.125, attenuation mode: absorption.
## 
## # A tibble: 611 x 3
##   w.length   Tfr   Afr
##      &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1      190 0.011 0.988
## 2      191 0.01  0.989
## 3      192 0.011 0.988
## 4      193 0.015 0.984
## # ... with 607 more rows</code></pre>
<div class="sourceCode" id="cb310"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb310-1"><a href="#cb310-1"></a><span class="kw">any2Afr</span>(polyester.spct, <span class="st">&quot;replace&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_spct [611 x 2]
## Wavelength range 190 to 800 nm, step 1 nm 
## Label: clear polyester film 
## Rfr (/1): 0.07, thickness (mm): 0.125, attenuation mode: absorption.
## 
## # A tibble: 611 x 2
##   w.length   Afr
##      &lt;int&gt; &lt;dbl&gt;
## 1      190 0.988
## 2      191 0.989
## 3      192 0.988
## 4      193 0.984
## # ... with 607 more rows</code></pre>
</div>
<div id="normalizing-a-spectrum" class="section level3">
<h3>Normalizing a spectrum</h3>
<p>Function <code>normalize</code> permits normalizing a spectrum to a value of one at an arbitrary wavelength (nm) or to the wavelength of either the maximum or the minimum spectral value. It supports the different spectral classes, we use a <code>source_spct</code> object as an example. (Equivalent functions with names spelled with “s” instead of “z” are also available.)</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb312-1"><a href="#cb312-1"></a><span class="kw">normalize</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## Spectral data normalized to 1 at 451 nm 
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<p>Which is equivalent to supplying <code>&quot;max&quot;</code> as argument to <code>norm</code>, it is also possible to give a range within which the maximum should be searched.</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb314-1"><a href="#cb314-1"></a><span class="kw">normalize</span>(sun.spct, <span class="dt">range =</span> PAR.wb, <span class="dt">norm =</span> <span class="st">&quot;max&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## Spectral data normalized to 1 at 451 nm 
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<p>It is also possible to normalize to an arbitrary wavelength within the range of the data, even if it is not one of the wavelength values present in the spectral object, as interpolation is used when needed.</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb316-1"><a href="#cb316-1"></a><span class="kw">normalize</span>(sun.spct, <span class="dt">norm =</span> <span class="fl">600.3</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## Spectral data normalized to 1 at 600.3 nm 
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<p>The normalization status of a spectral object can be tested with method <code>is_normalized()</code> and the normalization used can be recalled with method <code>getNormalized()</code>.</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb318-1"><a href="#cb318-1"></a>my.spct &lt;-<span class="st"> </span><span class="kw">normalize</span>(sun.spct)</span>
<span id="cb318-2"><a href="#cb318-2"></a><span class="kw">is_normalized</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb320"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb320-1"><a href="#cb320-1"></a><span class="kw">getNormalized</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] 451</code></pre>
<p>Once a spectrum is normalized, summary methods that return values in absolute units such as <code>irrad()</code>, will trigger an error if applied. Ratios and similar summaries that are invariant with respect to normalization can be calculated.</p>
<p>Applying method <code>fscale()</code> removes the normalization and clears the corresponding attribute where the normalization information is stored. This attribute also can be cleared with method <code>setNormalized()</code>, but this is rarely valid or of any use.</p>
</div>
<div id="rescaling-a-spectrum" class="section level3">
<h3>Rescaling a spectrum</h3>
<p>Function <code>fscale()</code> rescales a spectrum by dividing each spectral data value by a value calculated with a function (f) selected by a character string (“total” or “mean”), or an actual R function which can accept the spectrum object supplied as its first argument. Additional named arguments can be also passed.</p>
<p>How metadata is set in the returned object is controlled by a logical argument to parameter <code>set.scaled</code>. If <code>TRUE</code>, the data are labeled as being expressed in relative units and if <code>FALSE</code> this attribute is not set. The default argument depends on the value passed as argument to <code>target</code>. If this value is one, then the data are marked as no longer being expressed in absolute units. If the <code>target</code> is any other numeric value then it is assumed that the intention is to re-scale the data and that absolute physical units remain meaningful. It is important that the metadata matches the actual use as printing of summaries and plot labeling depends on them.</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb322-1"><a href="#cb322-1"></a><span class="kw">fscale</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## Rescaled to &#39;mean&#39; = 1
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb324"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb324-1"><a href="#cb324-1"></a><span class="kw">fscale</span>(sun.spct, <span class="dt">set.scaled =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb326"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb326-1"><a href="#cb326-1"></a><span class="kw">fscale</span>(sun.spct, <span class="dt">target =</span> <span class="dv">100</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb328"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb328-1"><a href="#cb328-1"></a><span class="kw">fscale</span>(sun.spct, <span class="dt">target =</span> <span class="dv">100</span>, <span class="dt">set.scaled =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## Rescaled to &#39;mean&#39; = 100
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<p>The default for <code>f</code> can be overridden. R functions passed as argument should be suitable for summarizing spectral objects as they will receive as first argument a spectrum rather than a numeric vector. Behind this requirement is the need to take into account wavelength steps for integration to be meaningful. In the example below we compute energy and photon irradiances. (The character arguments <code>&quot;mean&quot;</code> and <code>&quot;total&quot;</code> call functions specific to spectral data.)</p>
<div class="sourceCode" id="cb330"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb330-1"><a href="#cb330-1"></a><span class="kw">fscale</span>(sun.spct, <span class="dt">f =</span> <span class="st">&quot;integral&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## Rescaled to &#39;integral&#39; = 1
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb332"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb332-1"><a href="#cb332-1"></a><span class="kw">fscale</span>(sun.spct, <span class="dt">range =</span> PAR.wb, <span class="dt">f =</span> e_irrad)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## Rescaled to &#39;a user supplied R function&#39; = 1
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb334"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb334-1"><a href="#cb334-1"></a><span class="kw">fscale</span>(sun.spct, <span class="dt">range =</span> PAR.wb, <span class="dt">f =</span> q_irrad, <span class="dt">target =</span> <span class="fl">800e-6</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<p>In the third example, the spectral data is rescaled so that the corresponding photosynthetically-active irradiance is equal to one.</p>
<p>The normalization status of a spectral object can be tested with method <code>is_normalized()</code> and the normalization used can be recalled with method <code>getNormalized()</code>.</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb336-1"><a href="#cb336-1"></a>my.spct &lt;-<span class="st"> </span><span class="kw">fscale</span>(sun.spct)</span>
<span id="cb336-2"><a href="#cb336-2"></a><span class="kw">is_scaled</span>(my.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb338"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb338-1"><a href="#cb338-1"></a><span class="kw">getScaled</span>(my.spct)</span></code></pre></div>
<pre><code>## $multiplier
## [1] 1.932188
## 
## $f
## [1] &quot;mean&quot;
## 
## $range
## [1] 280 800
## 
## $target
## [1] 1</code></pre>
<p>Once a spectrum is scaled, summary methods that return values in absolute units such as <code>irrad()</code>, will trigger a warning if applied. Ratios and similar summaries that are invariant with respect to normalization do not trigger warnings.</p>
<p>Applying method <code>normalize()</code> removes the scaling and clears the corresponding attribute where the scaling information is stored. This attribute also can be cleared with method <code>setScaled()</code>, and this can be useful is some cases such as when irradiance has been measured separately from the emission spectrum.</p>
</div>
<div id="shifting-the-zero-of-the-spectral-data-scale" class="section level3">
<h3>Shifting the zero of the spectral data scale</h3>
<p>Function <code>fshift()</code> shifts the zero of the scale of a spectrum by subtracting from each spectral data value a value calculated with a function (f) selected by a character string (“mean”, “min” or “max”), or an actual R function which can accept the spectrum object supplied as its first argument. The range argument selects a region of the spectrum to be used as <em>reference</em> in the calculation of the summary.</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb340-1"><a href="#cb340-1"></a><span class="kw">fshift</span>(white_led.source_spct, <span class="dt">range =</span> UVB.wb, <span class="dt">f =</span> <span class="st">&quot;mean&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1,421 x 2]
## Wavelength range 251.16 to 898.81 nm, step 0.43 to 0.48 nm 
## Label: led_desk201 
## Measured on 2016-12-19 16:19:57 UTC 
## Time unit 1s
## 
## # A tibble: 1,421 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     251.         0
## 2     252.         0
## 3     252.         0
## 4     253.         0
## # ... with 1,417 more rows</code></pre>
<div class="sourceCode" id="cb342"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb342-1"><a href="#cb342-1"></a><span class="kw">fshift</span>(sun.spct, <span class="dt">range =</span> <span class="kw">c</span>(<span class="dv">280</span>,<span class="dv">290</span>), <span class="dt">f =</span> <span class="st">&quot;min&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows</code></pre>
<p>In the first example, the spectral data shifted so that the mean spectral irradiance becomes zero for the UV-B region. In the second example the minimum value in the range of wavelengths between 280~nm and 290~nm is used as zero reference for the scale.</p>
</div>
<div id="replacing-off-range-spectral-data-values" class="section level3">
<h3>Replacing off-range spectral data values</h3>
<p>Method <code>clean()</code> should be used with care as off-range values stem almost always from calibration errors or measuring noise. This function allows one to replace such values, but in many cases a zero shift or rescaling could be a better option. Even when the off-range values are the result of random noise, replacing them with the boundary values can cause bias, by censoring the data. In such cases smoothing may be applied first to reduce the possible bias caused by <code>clean()</code>. Here we create <em>artificial</em> off-range values by subtracting a constant from each spectrum.</p>
<div class="sourceCode" id="cb344"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb344-1"><a href="#cb344-1"></a><span class="kw">clean</span>(polyester.spct <span class="op">-</span><span class="st"> </span><span class="fl">0.053</span>)</span></code></pre></div>
<pre><code>## Warning in range_check_Tfr(x, strict.range = strict.range): Off-range
## transmittance values [-0.050..0.873] instead of [0..1]</code></pre>
<pre><code>## Object: filter_spct [611 x 2]
## Wavelength range 190 to 800 nm, step 1 nm 
## Label: clear polyester film 
## Transmittance of type &#39;total&#39;
## Rfr (/1): 0.07, thickness (mm): 0.125, attenuation mode: absorption.
## 
## # A tibble: 611 x 2
##   w.length   Tfr
##      &lt;int&gt; &lt;dbl&gt;
## 1      190     0
## 2      191     0
## 3      192     0
## 4      193     0
## # ... with 607 more rows</code></pre>
<p>It is possible to restrict the <em>cleaning</em> to a range of wavelengths and to provide a value to be used as replacement for the off-range data.</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb347-1"><a href="#cb347-1"></a><span class="kw">clean</span>(sun.spct <span class="op">-</span><span class="st"> </span><span class="fl">0.01</span>, <span class="dt">range =</span> <span class="kw">c</span>(<span class="fl">280.5</span>, <span class="dv">282</span>), <span class="dt">fill =</span> <span class="ot">NA</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s</code></pre>
<pre><code>## Warning in range_check(x, strict.range = strict.range): Negative spectral energy
## irradiance values; minimum s.e.irrad = -0.01</code></pre>
<pre><code>## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280      -0.01
## 2     281.     NA   
## 3     282.     NA   
## 4     283.     -0.01
## # ... with 518 more rows</code></pre>
</div>
<div id="removing-spikes" class="section level3">
<h3>Removing spikes</h3>
<p>Method <code>despike()</code> replaces spikes (very narrow peaks, or valleys) by values estimated from neighboring pixels. This method should be also used carefully and the results inspected as it can remove features of interest from the data. Usually one knows from theory or experience if spikes can be real features or not.</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb351-1"><a href="#cb351-1"></a><span class="kw">spikes</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [2 x 2]
## Wavelength range 398 to 432 nm, step 34 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 2 x 2
##   w.length s.e.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;
## 1      398     0.504
## 2      432     0.646</code></pre>
<div class="sourceCode" id="cb353"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb353-1"><a href="#cb353-1"></a>my_sun.spct &lt;-<span class="st"> </span><span class="kw">despike</span>(sun.spct)</span>
<span id="cb353-2"><a href="#cb353-2"></a><span class="kw">spikes</span>(my_sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [0 x 2]
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 0 x 2
## # ... with 2 variables: w.length &lt;dbl&gt;, s.e.irrad &lt;dbl&gt;</code></pre>
</div>
<div id="smoothing-of-spectra" class="section level3">
<h3>Smoothing of spectra</h3>
<p>We can use smoothing both to average out random variation among nearby pixels caused by measuring noise, or to filter out the real fine structure of a spectrum to better assess the larger features. The methods described here work by averaging the spectral data from neighboring wavelengths. The simplest methods are running medians and running means (or “boxcar smoothing” in the terminology used in some software). There are several methods for smoothing available in R based on different algorithms. Some of these methods also automatically set the degree of smoothing based on the data being smoothed. Package ‘photobiology’ defines function <code>smooth_spct</code>, which at the moment supports three different methods. Two are wrappers on R’s own methods and a third one, <code>&quot;custom&quot;</code>, is designed to use stronger smoothing of values close to zero, where noise in spectral irradiance measurements is proportionally more.</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb355-1"><a href="#cb355-1"></a><span class="kw">smooth_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>## 24 possibly &#39;bad&#39; values in smoothed spectral irradiance</code></pre>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<div class="sourceCode" id="cb358"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb358-1"><a href="#cb358-1"></a><span class="kw">smooth_spct</span>(polyester.spct, <span class="dt">method =</span> <span class="st">&quot;supsmu&quot;</span>, <span class="dt">strength =</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## Object: filter_spct [611 x 2]
## Wavelength range 190 to 800 nm, step 1 nm 
## Label: clear polyester film 
## Transmittance of type &#39;total&#39;
## Rfr (/1): 0.07, thickness (mm): 0.125, attenuation mode: absorption.
## 
## # A tibble: 611 x 2
##   w.length    Tfr
##      &lt;int&gt;  &lt;dbl&gt;
## 1      190 0.0124
## 2      191 0.0122
## 3      192 0.0121
## 4      193 0.0119
## # ... with 607 more rows</code></pre>
</div>
<div id="wavelength-interpolation" class="section level3">
<h3>Wavelength interpolation</h3>
<p>Converting spectra available at a given set of wavelengths values to a different one, is frequently needed when operating with several spectra of different origin. One can increase the <em>apparent</em> resolution by interpolation, and reduce it by local averaging or smoothing and resampling. The same function works on all <code>spct</code> objects, interpolating every numeric column except <code>w.length</code> which is set to the new wavelength values supplied as argument. The optional argument <code>fill.value</code> controls what value is assigned to the “interpolated” data columns at wavelengths in the new data that are outside the range of wavelengths in the original spectrum being interpolated.</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb360-1"><a href="#cb360-1"></a><span class="kw">interpolate_wl</span>(sun.spct, <span class="kw">seq</span>(<span class="dv">400</span>, <span class="dv">500</span>, <span class="dt">by =</span> <span class="fl">0.1</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [1,001 x 3]
## Wavelength range 400 to 500 nm, step 0.1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 1,001 x 3
##   w.length s.e.irrad  s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1     400      0.608 0.00000203
## 2     400.     0.610 0.00000204
## 3     400.     0.612 0.00000205
## 4     400.     0.614 0.00000205
## # ... with 997 more rows</code></pre>
</div>
<div id="trimming-clipping-and-thining" class="section level3">
<h3>Trimming, clipping and thining</h3>
<div id="method-clip_wl" class="section level4">
<h4>Method <code>clip_wl()</code></h4>
<p>Sometimes it is desirable to change the range of wavelengths included in a spectrum. If we are interested in a given part of the spectrum, there is no need to do calculations or plotting the whole spectrum. To select part of a spectrum based on a range of wavelengths we may use the <code>clip_wl()</code> method. Method <code>clip_wl()</code> simply selects a range from the existing spectrum, and unless the range exactly matches the wavelength values present in the spectrum, the range of wavelengths in the returned clipped spectrum will be slightly narrower than the requested by <code>range</code>.</p>
<p>The range of wavelengths expressed in nanometres can be given as numeric vector of length two.</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb362-1"><a href="#cb362-1"></a><span class="kw">clip_wl</span>(sun.spct, <span class="dt">range =</span> <span class="kw">c</span>(<span class="dv">400</span>, <span class="dv">402</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [3 x 3]
## Wavelength range 400 to 402 nm, step 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 3 x 3
##   w.length s.e.irrad  s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1      400     0.608 0.00000203
## 2      401     0.626 0.00000210
## 3      402     0.650 0.00000218</code></pre>
<div class="sourceCode" id="cb364"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb364-1"><a href="#cb364-1"></a><span class="kw">clip_wl</span>(sun.spct, <span class="dt">range =</span> <span class="kw">c</span>(<span class="dv">400</span>, <span class="ot">NA</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [401 x 3]
## Wavelength range 400 to 800 nm, step 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 401 x 3
##   w.length s.e.irrad  s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1      400     0.608 0.00000203
## 2      401     0.626 0.00000210
## 3      402     0.650 0.00000218
## 4      403     0.621 0.00000209
## # ... with 397 more rows</code></pre>
<p>As for other methods in the package, the range can be also supplied as a <code>waveband</code> object, or any other object for which <code>range()</code> returns a numeric range. Even a different spectrum object is acceptable, and in many cases useful.</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb366-1"><a href="#cb366-1"></a><span class="kw">clip_wl</span>(sun.spct, <span class="dt">range =</span> UVA.wb)</span></code></pre></div>
<pre><code>## Object: source_spct [86 x 3]
## Wavelength range 315 to 400 nm, step 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 86 x 3
##   w.length s.e.irrad   s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1      315     0.113 0.000000297
## 2      316     0.102 0.000000270
## 3      317     0.149 0.000000394
## 4      318     0.141 0.000000376
## # ... with 82 more rows</code></pre>
<p>The result can be a spectrum of length zero.</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb368-1"><a href="#cb368-1"></a><span class="kw">clip_wl</span>(sun.spct, <span class="dt">range =</span> <span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">200</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [0 x 3]
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 0 x 3
## # ... with 3 variables: w.length &lt;dbl&gt;, s.e.irrad &lt;dbl&gt;, s.q.irrad &lt;dbl&gt;</code></pre>
</div>
<div id="method-trim_wl" class="section level4">
<h4>Method <code>trim_wl()</code></h4>
<p>Sometimes, we need more flexibility. We may want to replace the observed values outside a certain range or expand the range of wavelengths, filling the expansion of all other variables with a certain value (i.e. a number, or NA.). In contrast to <em>clipping</em> (or functionally equivalent, indexing, or subsetting), <em>trimming</em> ensures that there will be spectral data returned at the boundaries of the trimmed region. These values are obtained by interpolation when they are not already present in the data.</p>
<p>More flexibility is available in method <code>trim_wl()</code>, to which we can supply arguments <code>range</code>, <code>use.hinges</code>, and <code>fill</code>. By default interpolation is used at the boundaries of the <code>range</code>, in which case the range of wavelengths in the returned spectrum is that passed as argument to <code>range</code>.</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb370-1"><a href="#cb370-1"></a><span class="kw">trim_wl</span>(sun.spct, <span class="kw">c</span>(<span class="fl">282.5</span>, <span class="ot">NA</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [520 x 3]
## Wavelength range 282.5 to 800 nm, step 0.2692308 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 520 x 3
##   w.length s.e.irrad s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     282.         0         0
## 2     283.         0         0
## 3     284.         0         0
## 4     285.         0         0
## # ... with 516 more rows</code></pre>
<div class="sourceCode" id="cb372"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb372-1"><a href="#cb372-1"></a><span class="kw">clip_wl</span>(sun.spct, <span class="kw">c</span>(<span class="fl">282.5</span>, <span class="ot">NA</span>))</span></code></pre></div>
<pre><code>## Object: source_spct [519 x 3]
## Wavelength range 282.76923 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 519 x 3
##   w.length s.e.irrad s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     283.         0         0
## 2     284.         0         0
## 3     285.         0         0
## 4     286.         0         0
## # ... with 515 more rows</code></pre>
<p>As for <code>clip_wl()</code> the range can be also supplied as a <code>waveband</code> object, or any other object for which <code>range()</code> returns a numeric range. Even a different spectrum object is acceptable.</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb374-1"><a href="#cb374-1"></a><span class="kw">trim_wl</span>(sun.spct, PAR.wb)</span></code></pre></div>
<pre><code>## Object: source_spct [301 x 3]
## Wavelength range 400 to 700 nm, step 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 301 x 3
##   w.length s.e.irrad  s.q.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1      400     0.608 0.00000203
## 2      401     0.626 0.00000210
## 3      402     0.650 0.00000218
## 4      403     0.621 0.00000209
## # ... with 297 more rows</code></pre>
<p>The default for <code>fill</code> is <code>NULL</code> which results in deletion values outside the trimmed region. However, it is possible to supply a different argument, to be used to replace the off-range data values.</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb376-1"><a href="#cb376-1"></a><span class="kw">trim_wl</span>(sun.spct, <span class="kw">c</span>(<span class="fl">281.5</span>, <span class="ot">NA</span>), <span class="dt">fill =</span> <span class="ot">NA</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 3]
## Wavelength range 280 to 800 nm, step 1.023182e-12 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 524 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280         NA        NA
## 2     281.        NA        NA
## 3     281.        NA        NA
## 4     282.         0         0
## # ... with 520 more rows</code></pre>
<p>Furthermore, when fill is not <code>NULL</code>, expansion is possible.</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb378-1"><a href="#cb378-1"></a><span class="kw">trim_wl</span>(sun.spct, <span class="kw">c</span>(<span class="dv">275</span>, <span class="ot">NA</span>), <span class="dt">fill =</span> <span class="dv">0</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [529 x 3]
## Wavelength range 275 to 800 nm, step 1.023182e-12 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 529 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     275          0         0
## 2     276.         0         0
## 3     277.         0         0
## 4     277.         0         0
## # ... with 525 more rows</code></pre>
<p>By default interpolation at the boundaries is used, but setting <code>use.hinges</code> to <code>FALSE</code> results in clipping, a behavior similar to that of <code>clip_wl</code> only if <code>fill == NULL</code>.</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb380-1"><a href="#cb380-1"></a><span class="kw">trim_wl</span>(sun.spct, <span class="kw">c</span>(<span class="fl">281.5</span>, <span class="ot">NA</span>), <span class="dt">fill =</span> <span class="ot">NA</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 3]
## Wavelength range 280 to 800 nm, step 1.023182e-12 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 524 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280         NA        NA
## 2     281.        NA        NA
## 3     281.        NA        NA
## 4     282.         0         0
## # ... with 520 more rows</code></pre>
<div class="sourceCode" id="cb382"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb382-1"><a href="#cb382-1"></a><span class="kw">trim_wl</span>(sun.spct, <span class="kw">c</span>(<span class="fl">281.5</span>, <span class="ot">NA</span>), <span class="dt">fill =</span> <span class="ot">NA</span>, <span class="dt">use.hinges =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [522 x 3]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280         NA        NA
## 2     281.        NA        NA
## 3     282.         0         0
## 4     283.         0         0
## # ... with 518 more rows</code></pre>
<p>When <code>use.hinges == TRUE</code> and expansion or replacement is done, two observations are inserted at each boundary, differing in wavelength by <span class="math inline">\(1 \times 10^{-12}\)</span>,nm to prevent rounding errors in later calculations.</p>
</div>
<div id="functions-trim2ovelap-and-extend2extremes" class="section level4">
<h4>Functions <code>trim2ovelap()</code> and <code>extend2extremes()</code></h4>
<p>Functions <code>trim2ovelap()</code> and <code>extend2extremes()</code> are defined only for collections of spectra. They are convenience functions, as they handle special use cases of <code>trim_wl()</code> with a simplified syntax. They can be used to make the wavelength range of the different members of a collection of spectra consistent, either by trimming all spectra to the range of overlapping wavelengths, or by extending the wavelength ranges as needed and filling the added spectral values with a constant value.</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb384-1"><a href="#cb384-1"></a><span class="kw">trim2overlap</span>(two.mspct)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2015-10-31 08:00:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## --- Member: B ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2015-10-31 09:00:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
<div class="sourceCode" id="cb386"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb386-1"><a href="#cb386-1"></a><span class="kw">extend2extremes</span>(two.mspct, <span class="dt">fill =</span> <span class="dv">0</span>)</span></code></pre></div>
<pre><code>## Object: source_mspct [2 x 1]
## --- Member: A ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2015-10-31 08:00:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## --- Member: B ---
## Object: source_spct [522 x 2]
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2015-10-31 09:00:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 522 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 518 more rows
## 
## --- END ---</code></pre>
</div>
<div id="method-thin_wl" class="section level4">
<h4>Method <code>thin_wl()</code></h4>
<p>One possible way of decreasing the storage space occupied by spectral data is to vary the density of wavelength values stored based on the local change in slope (second derivative) of the plot a spectrum. Method <code>thin_wl()</code> can be used to remove or “thin” down the wavelength values stored in those regions of the spectrum where this would result in minimal loss of information. The algorithm currently in use is suboptimal in the removal of wavelength values but fast and easy to implement. <strong>Which wavelength values are retained or not could change with future implementations.</strong></p>
<div class="sourceCode" id="cb388"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb388-1"><a href="#cb388-1"></a><span class="kw">nrow</span>(yellow_gel.spct)</span></code></pre></div>
<pre><code>## [1] 611</code></pre>
<div class="sourceCode" id="cb390"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb390-1"><a href="#cb390-1"></a><span class="kw">wl_stepsize</span>(yellow_gel.spct)</span></code></pre></div>
<pre><code>## [1] 1 1</code></pre>
<div class="sourceCode" id="cb392"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb392-1"><a href="#cb392-1"></a>thinned.spct &lt;-<span class="st"> </span><span class="kw">thin_wl</span>(yellow_gel.spct)</span>
<span id="cb392-2"><a href="#cb392-2"></a><span class="kw">nrow</span>(thinned.spct)</span></code></pre></div>
<pre><code>## [1] 383</code></pre>
<div class="sourceCode" id="cb394"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb394-1"><a href="#cb394-1"></a><span class="kw">wl_stepsize</span>(thinned.spct)</span></code></pre></div>
<pre><code>## [1] 1 8</code></pre>
<p>The strength of the thinning can be adjusted by passing arguments to parameters <code>max.wl.step</code> and <code>max.slope.delta</code>. This method is implemented for objects of all spectral classes that a single default data column in addition to wavelengths and also for collections of those objects.</p>
</div>
</div>
<div id="convolving-weights" class="section level3">
<h3>Convolving weights</h3>
<p>It is very instructive to look at weighted spectral data to understand how effective irradiances are calculated. Plotting effective spectral irradiance data can be very informative when analyzing interactions among photoreceptors and ambient radiation. It can also illustrate the large effect that small measuring errors can have on the estimated effective irradiances or exposures when SWFs have a steep slope.</p>
<div id="individual-spectra" class="section level4">
<h4>Individual spectra</h4>
<p>The multiplication operator is defined for operations between a <code>source_spct</code> and a <code>waveband</code>, so this is the easiest way of doing the calculations.</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb396-1"><a href="#cb396-1"></a>sun.spct <span class="op">*</span><span class="st"> </span>CIE.wb</span></code></pre></div>
<pre><code>## Object: source_spct [122 x 2]
## Wavelength range 280 to 400 nm, step 0.9230769 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## Data weighted using &#39;range.250.400.wtd&#39; BSWF
## 
## # A tibble: 122 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0
## 2     281.         0
## 3     282.         0
## 4     283.         0
## # ... with 118 more rows</code></pre>
<!-- #### Vectors -->
<!-- It is also possible to use vectors. -->
<!-- ```{r, vectors-1, tidy=FALSE} -->
<!-- weighted.s.e.irrad <- -->
<!--   with(sun.spct, -->
<!--        s.e.irrad * calc_multipliers(w.length, CIE.wb) -->
<!--   ) -->
<!-- ``` -->
</div>
</div>
<div id="tagging-with-bands-and-colours" class="section level3">
<h3>Tagging with bands and colours</h3>
<p>We call tagging, to the process of adding reference information to spectral data. For example we can add a factor indicating regions or bands in the spectrum. We can add also information on the color, as seen by humans, for each observed value, or for individual regions or bands of the spectrum. In most cases this additional information is used for annotations when plotting the spectral data.</p>
<div id="individual-spectra-1" class="section level4">
<h4>Individual spectra</h4>
<p>The function <code>tag</code> can be used to tag different parts of a spectrum according to wavebands.</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb398-1"><a href="#cb398-1"></a><span class="kw">tag</span>(sun.spct, PAR.wb)</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 6]
## Wavelength range 280 to 800 nm, step 1.023182e-12 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 524 x 6
##   w.length s.e.irrad s.q.irrad wl.color wb.color wb.f 
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;fct&gt;
## 1     280          0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 2     281.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 3     282.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 4     283.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## # ... with 520 more rows</code></pre>
<div class="sourceCode" id="cb400"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb400-1"><a href="#cb400-1"></a><span class="kw">tag</span>(sun.spct, UV_bands.lst)</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 6]
## Wavelength range 280 to 800 nm, step 1.023182e-12 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 524 x 6
##   w.length s.e.irrad s.q.irrad wl.color wb.color wb.f 
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;fct&gt;
## 1     280          0         0 #000000  black    UVB  
## 2     281.         0         0 #000000  black    UVB  
## 3     282.         0         0 #000000  black    UVB  
## 4     283.         0         0 #000000  black    UVB  
## # ... with 520 more rows</code></pre>
<p>The added factor and color data can be used for further processing or for plotting. Information about the tagging and wavebands is stored in an attribute <code>tag.attr</code> in every tagged spectrum, this yields a more compact output and keeps a <em>trace</em> of the tagging.</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb402-1"><a href="#cb402-1"></a>tg.sun.spct &lt;-<span class="st"> </span><span class="kw">tag</span>(sun.spct, PAR.wb)</span>
<span id="cb402-2"><a href="#cb402-2"></a><span class="kw">attr</span>(tg.sun.spct, <span class="st">&quot;spct.tags&quot;</span>)</span></code></pre></div>
<pre><code>## $valid
## [1] TRUE
## 
## $time.unit
## [1] &quot;second&quot;
## 
## $wb.key.name
## [1] &quot;Bands&quot;
## 
## $wl.color
## [1] TRUE
## 
## $wb.color
## [1] TRUE
## 
## $wb.num
## [1] 1
## 
## $wb.colors
## [1] &quot;#735B57&quot;
## 
## $wb.names
## [1] &quot;PAR&quot;
## 
## $wb.list
## $wb.list[[1]]
## PAR 
## low (nm) 400 
## high (nm) 700 
## weighted none</code></pre>
<p>Additional functions are available which return a tagged spectrum and take as input a list of wavebands, but no spectral data. They <em>build</em> a spectrum from the data in the wavebands, and are useful for plotting the boundaries of wavebands.</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb404-1"><a href="#cb404-1"></a><span class="kw">wb2tagged_spct</span>(UV_bands.lst)</span></code></pre></div>
<pre><code>## Object: generic_spct [8 x 12]
## Wavelength range 100 to 400 nm, step 9.947598e-13 to 180 nm 
## 
## # A tibble: 8 x 12
##   w.length counts   cps s.e.irrad s.q.irrad   Tfr   Rfl s.e.response wl.color
##      &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;   
## 1     100.      0     0         0         0     0     0            0 #000000 
## 2     100       0     0         0         0     0     0            0 #000000 
## 3     280.      0     0         0         0     0     0            0 #000000 
## 4     280       0     0         0         0     0     0            0 #000000 
## # ... with 4 more rows, and 3 more variables: wb.color &lt;chr&gt;, wb.f &lt;fct&gt;,
## #   y &lt;dbl&gt;</code></pre>
<div class="sourceCode" id="cb406"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb406-1"><a href="#cb406-1"></a><span class="kw">wb2rect_spct</span>(UV_bands.lst)</span></code></pre></div>
<pre><code>## Object: generic_spct [3 x 15]
## Wavelength range 190 to 357.5 nm, step 60 to 107.5 nm 
## 
## # A tibble: 3 x 15
##   w.length counts   cps s.e.irrad s.q.irrad   Tfr   Rfl s.e.response wl.color
##      &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;   
## 1     190       0     0         0         0     0     0            0 #000000 
## 2     298.      0     0         0         0     0     0            0 #000000 
## 3     358.      0     0         0         0     0     0            0 #000000 
## # ... with 6 more variables: wb.color &lt;chr&gt;, wb.name &lt;chr&gt;, wb.f &lt;fct&gt;,
## #   wl.high &lt;dbl&gt;, wl.low &lt;dbl&gt;, y &lt;dbl&gt;</code></pre>
<p>Function <code>wb2tagged_spct</code> returns a tagged spectrum, with two rows for each waveband, corresponding to the low and high wavelength boundaries, while function <code>wb2rect_spct</code> returns a spectrum with only one row per waveband, with <code>w.length</code> set to its midpoint but with additional columns <code>xmin</code> and <code>xmax</code> corresponding to the low and high wavelength boundaries of the wavebands.</p>
<p>Function <code>is_tagged</code> can be used to query if an spectrum is tagged or not, and function <code>untag</code> removes the tags.</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb408-1"><a href="#cb408-1"></a>tg.sun.spct</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 6]
## Wavelength range 280 to 800 nm, step 1.023182e-12 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 524 x 6
##   w.length s.e.irrad s.q.irrad wl.color wb.color wb.f 
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;    &lt;fct&gt;
## 1     280          0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 2     281.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 3     282.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## 4     283.         0         0 #000000  &lt;NA&gt;     &lt;NA&gt; 
## # ... with 520 more rows</code></pre>
<div class="sourceCode" id="cb410"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb410-1"><a href="#cb410-1"></a><span class="kw">is_tagged</span>(tg.sun.spct)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb412"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb412-1"><a href="#cb412-1"></a>untg.sun.spct &lt;-<span class="st"> </span><span class="kw">untag</span>(tg.sun.spct)</span>
<span id="cb412-2"><a href="#cb412-2"></a><span class="kw">is_tagged</span>(untg.sun.spct)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>In the chuck above, we can see how this works, using in this case the default <code>byref = FALSE</code> which adds the tags to a copy of the spectrum object. In contrast, setting <code>byref = TRUE</code> adds the tags in place, or “by reference”&quot;, to the spct object supplied as argument. Passing arguments by reference is unusual for R and is best avoided.</p>
<div class="sourceCode" id="cb414"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb414-1"><a href="#cb414-1"></a><span class="kw">is_tagged</span>(untg.sun.spct)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb416"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb416-1"><a href="#cb416-1"></a><span class="kw">untag</span>(tg.sun.spct, <span class="dt">byref =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [524 x 3]
## Wavelength range 280 to 800 nm, step 1.023182e-12 to 1 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 524 x 3
##   w.length s.e.irrad s.q.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1     280          0         0
## 2     281.         0         0
## 3     282.         0         0
## 4     283.         0         0
## # ... with 520 more rows</code></pre>
<div class="sourceCode" id="cb418"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb418-1"><a href="#cb418-1"></a><span class="kw">is_tagged</span>(untg.sun.spct)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
</div>
</div>
</div>
<div id="summaries" class="section level2">
<h2>Summaries</h2>
<p>Summaries can be calculated both from individual spectral objects (Table 10) and from collections of spectral objects (Table 11). They return a <em>simpler</em> object than the spectral data in their arguments. For example a vector of numeric values, possibly of length one, in the case of individual spectra, or a data frame containing one row of summary data for each spectrum in a collection of spectra.</p>
<hr>
<p><strong>Table 10. Summary methods for spectra.</strong> Key: + available, - not available, (+) object_spct objects can be converted into filter_spct or reflector_spct objects before applying these methods.</p>
<table>
<thead>
<tr class="header">
<th align="left">methods</th>
<th align="center">raw/cps</th>
<th align="center">source</th>
<th align="center">response</th>
<th align="center">filter</th>
<th align="center">reflector</th>
<th align="center">object</th>
<th align="center">chroma</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">irrad</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">e_irrad</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">q_irrad</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">fluence</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">e_fluence</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">q_fluence</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">ratio</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">e_ratio</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">q_ratio</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">qe_ratio</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">eq_ratio</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">e_response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">q_response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">transmittance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">absorptance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">absorbance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">reflectance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">wl_range</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">wl_min</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">wl_max</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">wl_stepsize</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">wl_expanse</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">wl_midpoint</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">labels</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">summary</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">peaks</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="left">spikes</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="odd">
<td align="left">valleys</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="left">wls_at_target</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="odd">
<td align="left">integrate_spct</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">average_spct</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">color_of</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
</tbody>
</table>
<hr>
<p>As mentioned above, summary methods for collections of spectra return data frame objects. In many cases preserving the attributes from the different members of the collection in the returned value is important, and can be achieved easily by passing a suitable character vector as argument to parameter <code>attr2tb</code>, using the same syntax as described for function <code>add_attr2tb</code>.</p>
<hr>
<p><strong>Table 11. Summary methods for collections of spectra.</strong> Key: + available, * <code>attr2tb</code> supported, – not available, <strong>ms</strong> use <code>msmsply()</code> to apply function to collection members, <strong>d</strong> use <code>msdply()</code>, <strong>l</strong> use <code>mslply</code> to apply function to collection members, <strong>a</strong> use <code>msaply</code> to apply function to collection members.</p>
<table>
<thead>
<tr class="header">
<th align="left">methods</th>
<th align="center">raw/cps</th>
<th align="center">source</th>
<th align="center">response</th>
<th align="center">filter</th>
<th align="center">reflector</th>
<th align="center">object</th>
<th align="center">chroma</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">irrad</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">e_irrad</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">q_irrad</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">fluence</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">e_fluence</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">q_fluence</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">ratio</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">e_ratio</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">q_ratio</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">qe_ratio</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">eq_ratio</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">e_response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">q_response</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">transmittance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">absorptance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">absorbance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">reflectance</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">–</td>
</tr>
<tr class="odd">
<td align="left">color_of</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="left">wl_range</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">wl_min</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">wl_max</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">wl_stepsize</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">wl_spread</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="odd">
<td align="left">wl_midpoint</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr class="even">
<td align="left">labels</td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
</tr>
<tr class="odd">
<td align="left">summary</td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
<td align="center"><strong>l</strong></td>
</tr>
<tr class="even">
<td align="left">peaks</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="odd">
<td align="left">valleys</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="left">spikes</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="odd">
<td align="left">wls_at_target</td>
<td align="center">–</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">(+)</td>
<td align="center">-</td>
</tr>
<tr class="even">
<td align="left">integrate_spct</td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
</tr>
<tr class="odd">
<td align="left">average_spct</td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
<td align="center"><strong>a, d, l</strong></td>
</tr>
</tbody>
</table>
<hr>
<div id="summary-1" class="section level3">
<h3>Summary</h3>
<p>Specialized definitions of <code>summary</code> and the corresponding <code>print</code> methods are available for spectral objects. Attributes <code>&quot;what.measured&quot;</code>, <code>&quot;when.measured&quot;</code> and <code>&quot;where.measured&quot;</code> are included in the summary print out only if set in the spectral object summarized.</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb420-1"><a href="#cb420-1"></a><span class="kw">summary</span>(sun.spct)</span></code></pre></div>
<pre><code>## Summary of source_spct [522 x 3] object: sun.spct
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
##     w.length       s.e.irrad        s.q.irrad        
##  Min.   :280.0   Min.   :0.0000   Min.   :0.000e+00  
##  1st Qu.:409.2   1st Qu.:0.4115   1st Qu.:1.980e-06  
##  Median :539.5   Median :0.5799   Median :2.929e-06  
##  Mean   :539.5   Mean   :0.5160   Mean   :2.407e-06  
##  3rd Qu.:669.8   3rd Qu.:0.6664   3rd Qu.:3.154e-06  
##  Max.   :800.0   Max.   :0.8205   Max.   :3.375e-06</code></pre>
<div class="sourceCode" id="cb422"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb422-1"><a href="#cb422-1"></a><span class="kw">summary</span>(two_suns.spct)</span></code></pre></div>
<pre><code>## Warning in setWhenMeasured.summary_generic_spct(z, getWhenMeasured(object)):
## Length of &#39;when.measured&#39; does not match spectrum object</code></pre>
<pre><code>## Summary of source_spct [1,044 x 4] object: two_suns.spct
## containing  2  spectra in long form
## Wavelength range 280 to 800 nm, step 0.9230769 to 1 nm
## a label: sunlight, simulated
## b label: sunlight, simulated 
## a measured on 2010-06-22 09:51:00 UTC
## b measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
##     w.length       s.e.irrad      spct.idx   s.q.irrad        
##  Min.   :280.0   Min.   :0.0000   a:522    Min.   :0.000e+00  
##  1st Qu.:409.0   1st Qu.:0.2471   b:522    1st Qu.:1.159e-06  
##  Median :539.5   Median :0.3494            Median :1.580e-06  
##  Mean   :539.5   Mean   :0.3870            Mean   :1.806e-06  
##  3rd Qu.:670.0   3rd Qu.:0.5799            3rd Qu.:2.928e-06  
##  Max.   :800.0   Max.   :0.8205            Max.   :3.375e-06</code></pre>
</div>
<div id="wavelength" class="section level3">
<h3>Wavelength</h3>
<div id="individual-spectra-2" class="section level4">
<h4>Individual spectra</h4>
<p>The <em>usual</em> and three new summary methods are available for spectra, but redefined to return wavelength-based summaries in nanometres (nm). For clarity synonyms with clearer names are provided. The three new generic methods <code>midpoint()</code>, <code>expanse()</code> and <code>stepsize()</code> are also defined for <code>numeric</code>.</p>
<div class="sourceCode" id="cb425"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb425-1"><a href="#cb425-1"></a><span class="kw">wl_range</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 280 800</code></pre>
<div class="sourceCode" id="cb427"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb427-1"><a href="#cb427-1"></a><span class="kw">wl_min</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 280</code></pre>
<div class="sourceCode" id="cb429"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb429-1"><a href="#cb429-1"></a><span class="kw">wl_max</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 800</code></pre>
<div class="sourceCode" id="cb431"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb431-1"><a href="#cb431-1"></a><span class="kw">wl_midpoint</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 540</code></pre>
<div class="sourceCode" id="cb433"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb433-1"><a href="#cb433-1"></a><span class="kw">wl_expanse</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 520</code></pre>
<div class="sourceCode" id="cb435"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb435-1"><a href="#cb435-1"></a><span class="kw">wl_stepsize</span>(sun.spct)</span></code></pre></div>
<pre><code>## [1] 0.9230769 1.0000000</code></pre>
</div>
<div id="collections-of-spectra-1" class="section level4">
<h4>Collections of spectra</h4>
<hr>
Most frequently used summary methods are implemented for collections of spectra. See the Table 11 for those methods that need to be applied with functions <code>msaply</code>, <code>msdply</code> or <code>mslply</code> to members in a collection returning the results in an array (vector, or matrix), a data frame or a list object. In many cases depending of the class desired for the result, one can chose a suitable <em>apply</em> function, and sometimes it is best to use such a function, even when the corresponding method is implemented for collections of spectra.
<hr>
<p>Collections of spectra can be useful not only for time-series of spectra or spectral images, but also when dealing with a small group of related spectra. In the example below we show how to use a collection of spectra for calculating summaries. The spectra in a collection do <strong>not</strong> need to have been measured at the same wavelength values, or have the same number of rows or even of columns. Consequently, in many cases applying the wavelength summary functions described above to collections of spectra can be useful. The value returned is a data frame, with a number of data columns equal to the length of the returned value by the corresponding method for individual spectra.</p>
<div class="sourceCode" id="cb437"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb437-1"><a href="#cb437-1"></a>filters.mspct &lt;-<span class="st"> </span><span class="kw">filter_mspct</span>(<span class="kw">list</span>(<span class="dt">none =</span> clear.spct,</span>
<span id="cb437-2"><a href="#cb437-2"></a>                                   <span class="dt">pet =</span> polyester.spct,</span>
<span id="cb437-3"><a href="#cb437-3"></a>                                   <span class="dt">yellow =</span> yellow_gel.spct))</span>
<span id="cb437-4"><a href="#cb437-4"></a><span class="kw">wl_range</span>(filters.mspct)</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   spct.idx min.wl max.wl
##   &lt;fct&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1 none        100   5000
## 2 pet         190    800
## 3 yellow      190    800</code></pre>
</div>
</div>
<div id="peaks-valleys-and-spikes" class="section level3">
<h3>Peaks, valleys and spikes</h3>
<div id="individual-spectra-3" class="section level4">
<h4>Individual spectra</h4>
<p>Methods <code>peaks</code> and <code>valleys</code> take spectra as first argument and return a subset of the spectral object data corresponding to local maxima and local minima of the measured variable. <code>span</code> defines the width of the <em>window</em> used as a number of observations.</p>
<div class="sourceCode" id="cb439"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb439-1"><a href="#cb439-1"></a><span class="kw">peaks</span>(sun.spct, <span class="dt">span =</span> <span class="dv">51</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [3 x 2]
## Wavelength range 451 to 747 nm, step 44 to 252 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 3 x 2
##   w.length s.e.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;
## 1      451     0.820
## 2      495     0.790
## 3      747     0.503</code></pre>
<div class="sourceCode" id="cb441"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb441-1"><a href="#cb441-1"></a><span class="kw">valleys</span>(sun.spct, <span class="dt">span =</span> <span class="dv">51</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [9 x 2]
## Wavelength range 358 to 761 nm, step 30 to 72 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 9 x 2
##   w.length s.e.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;
## 1      358     0.254
## 2      393     0.242
## 3      431     0.414
## 4      487     0.651
## # ... with 5 more rows</code></pre>
<p>In the case of <code>source_spct</code> and <code>response_spct</code> methods <code>unit.out</code> can be used to force peaks to be searched using either energy or photon based spectral irradiance. The default is energy, or the option <code>&quot;photobiology.radiation.unit&quot;</code> if set.</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb443-1"><a href="#cb443-1"></a><span class="kw">peaks</span>(sun.spct, <span class="dt">span =</span> <span class="dv">51</span>, <span class="dt">unit.out =</span> <span class="st">&quot;photon&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [7 x 2]
## Wavelength range 451 to 754 nm, step 36 to 90 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 7 x 2
##   w.length  s.q.irrad
## *    &lt;dbl&gt;      &lt;dbl&gt;
## 1      451 0.00000309
## 2      495 0.00000327
## 3      531 0.00000337
## 4      621 0.00000336
## # ... with 3 more rows</code></pre>
<p>It is possible to approximately set the width in nanometres of the moving window within which a maximum is searched by passing an odd number as argument to <code>span</code>. However, even numbers if passed are increased with a warning.</p>
<div class="sourceCode" id="cb445"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb445-1"><a href="#cb445-1"></a><span class="kw">peaks</span>(sun.spct, <span class="dt">span =</span> <span class="dv">21</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [18 x 2]
## Wavelength range 354 to 774 nm, step 11 to 51 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 18 x 2
##   w.length s.e.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;
## 1      354     0.376
## 2      366     0.449
## 3      378     0.497
## 4      416     0.676
## # ... with 14 more rows</code></pre>
<p>A value of <code>NULL</code> as argument to <code>span</code> searches for a single maximum for the whole spectrum.</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb447-1"><a href="#cb447-1"></a><span class="kw">peaks</span>(sun.spct, <span class="dt">span =</span> <span class="ot">NULL</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1 x 2]
## Wavelength range 451 to 451 nm, step NA nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 1 x 2
##   w.length s.e.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;
## 1      451     0.820</code></pre>
<p>The position of peaks can be refined by spline interpolation. This is still an experimental feature, that may fail, especially in the estimate of the value of the spectral quantity at the peak.</p>
<div class="sourceCode" id="cb449"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb449-1"><a href="#cb449-1"></a><span class="kw">peaks</span>(sun.spct, <span class="dt">span =</span> <span class="ot">NULL</span>, <span class="dt">refine.wl =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [1 x 2]
## Wavelength range 451.02685 to 451.02685 nm, step NA nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 1 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     451.     0.821</code></pre>
<p>Method <code>spikes</code> differs from <code>peaks</code> in that it uses a different algorithm that detects only narrow peaks or spikes. The value returned is as in the case of <code>peaks</code> a subset of the original spectrum. The parameters controlling the sensitivity also differ.</p>
<div class="sourceCode" id="cb451"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb451-1"><a href="#cb451-1"></a><span class="kw">spikes</span>(sun.spct)</span></code></pre></div>
<pre><code>## Object: source_spct [2 x 2]
## Wavelength range 398 to 432 nm, step 34 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 2 x 2
##   w.length s.e.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;
## 1      398     0.504
## 2      432     0.646</code></pre>
<p>Low level functions <code>find_peaks</code>, <code>get_peaks</code>, <code>get_valleys</code>, <code>fit_peaks</code>, <code>fit_valleys</code>, and <code>find_spikes</code> take numeric vectors as first argument.</p>
</div>
<div id="collections-of-spectra-2" class="section level4">
<h4>Collections of spectra</h4>
<p>The methods are also implemented for collections of spectra.</p>
<div class="sourceCode" id="cb453"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb453-1"><a href="#cb453-1"></a><span class="kw">msmsply</span>(filters.mspct, peaks, <span class="dt">span =</span> <span class="dv">21</span>)</span></code></pre></div>
<pre><code>## Object: filter_mspct [3 x 1]
## --- Member: none ---
## Object: filter_spct [0 x 5]
## Label: theoretical fully transparent object 
## Transmittance of type &#39;internal&#39;
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## 
## # A tibble: 0 x 5
## # ... with 5 variables: w.length &lt;dbl&gt;, Tfr &lt;dbl&gt;, Rfr.constant &lt;dbl&gt;,
## #   thickness &lt;dbl&gt;, attenuation.mode &lt;chr&gt;
## --- Member: pet ---
## Object: filter_spct [2 x 2]
## Wavelength range 503 to 648 nm, step 145 nm 
## Label: clear polyester film 
## Transmittance of type &#39;total&#39;
## Rfr (/1): 0.07, thickness (mm): 0.125, attenuation mode: absorption.
## 
## # A tibble: 2 x 2
##   w.length   Tfr
## *    &lt;int&gt; &lt;dbl&gt;
## 1      503 0.926
## 2      648 0.918
## --- Member: yellow ---
## Object: filter_spct [1 x 2]
## Wavelength range 755 to 755 nm, step NA nm 
## Label: yellow theatrical &#39;gel&#39;, Rosco supergel no. 312, &#39;canary yellow&#39; 
## Transmittance of type &#39;total&#39;
## Rfr (/1): 0.07, thickness (mm): 0.085, attenuation mode: absorption.
## 
## # A tibble: 1 x 2
##   w.length   Tfr
## *    &lt;int&gt; &lt;dbl&gt;
## 1      755 0.902
## 
## --- END ---</code></pre>
<p>Two of the filters in the collection do not have peaks, and a spectrum object of length zero is returned for them.</p>
</div>
</div>
<div id="wavelengths-at-target-value" class="section level3">
<h3>Wavelengths at target value</h3>
<p>Method <code>wls_at_target</code> takes a spectrum as first argument and return a subset of the spectral object data or a new object corresponding to wavelengths at which the spectrum is at the target value.</p>
<div class="sourceCode" id="cb455"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb455-1"><a href="#cb455-1"></a><span class="kw">wls_at_target</span>(sun.spct, <span class="dt">target =</span> <span class="st">&quot;half.maximum&quot;</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [21 x 2]
## Wavelength range 366 to 800 nm, step 1 to 319 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 21 x 2
##   w.length s.e.irrad
## *    &lt;dbl&gt;     &lt;dbl&gt;
## 1      366     0.449
## 2      368     0.398
## 3      369     0.417
## 4      371     0.409
## # ... with 17 more rows</code></pre>
<div class="sourceCode" id="cb457"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb457-1"><a href="#cb457-1"></a><span class="kw">wls_at_target</span>(sun.spct, <span class="dt">target =</span> <span class="st">&quot;half.maximum&quot;</span>, <span class="dt">interpolate =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## Object: source_spct [22 x 2]
## Wavelength range 365.53069 to 799.71521 nm, step 0.6852733 to 319.3893 nm 
## Label: sunlight, simulated 
## Measured on 2010-06-22 09:51:00 UTC 
## Measured at 60.20911 N, 24.96474 E; Kumpula, Helsinki, FI 
## Time unit 1s
## 
## # A tibble: 22 x 2
##   w.length s.e.irrad
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1     366.     0.410
## 2     368.     0.410
## 3     369.     0.410
## 4     371.     0.410
## # ... with 18 more rows</code></pre>
<p>As in the case of <code>source_spct</code> and <code>response_spct</code> methods parameters <code>unit.out</code> and <code>filter.qty</code> allow to change the returned value.</p>
<div id="collections-of-spectra-3" class="section level4">
<h4>Collections of spectra</h4>
<p>The method is also implemented for collections of spectra.</p>
<div class="sourceCode" id="cb459"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb459-1"><a href="#cb459-1"></a><span class="kw">wls_at_target</span>(filters.mspct, <span class="dt">target =</span> <span class="st">&quot;half.maximum&quot;</span>)</span></code></pre></div>
<pre><code>## Object: filter_mspct [3 x 1]
## --- Member: none ---
## Object: filter_spct [0 x 5]
## Label: theoretical fully transparent object 
## Transmittance of type &#39;internal&#39;
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## 
## # A tibble: 0 x 5
## # ... with 5 variables: w.length &lt;dbl&gt;, Tfr &lt;dbl&gt;, Rfr.constant &lt;dbl&gt;,
## #   thickness &lt;dbl&gt;, attenuation.mode &lt;chr&gt;
## --- Member: pet ---
## Object: filter_spct [1 x 2]
## Wavelength range 322 to 322 nm, step NA nm 
## Label: clear polyester film 
## Transmittance of type &#39;total&#39;
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## 
## # A tibble: 1 x 2
##   w.length   Tfr
## *    &lt;int&gt; &lt;dbl&gt;
## 1      322 0.472
## --- Member: yellow ---
## Object: filter_spct [1 x 2]
## Wavelength range 509 to 509 nm, step NA nm 
## Label: yellow theatrical &#39;gel&#39;, Rosco supergel no. 312, &#39;canary yellow&#39; 
## Transmittance of type &#39;total&#39;
## Rfr (/1): NA, thickness (mm): NA, attenuation mode: NA.
## 
## # A tibble: 1 x 2
##   w.length   Tfr
## *    &lt;int&gt; &lt;dbl&gt;
## 1      509 0.458
## 
## --- END ---</code></pre>
</div>
</div>
<div id="irradiance" class="section level3">
<h3>Irradiance</h3>
<div id="individual-spectra-4" class="section level4">
<h4>Individual spectra</h4>
<p>The code using <code>spct</code> objects is simple; to integrate the whole spectrum we can use <code>irrad()</code> that returns by default energy irradiance, unless an R option is set to make photon-based units the default. When this flexibility is not needed, <code>e_irrad()</code> and <code>q_irrad()</code> should be preferred. For most examples we use energy-based units and <code>e_irrad()</code>, but they also apply unchanged to <code>q_irrad()</code> and photon-based units, and <em>vice-versa</em> for those examples using <code>q_irrad()</code>.</p>
<p>The abbreviations <em>E</em> and <em>Q</em> are used to denote these two quantities, usually with the waveband as a subscript. In what follows “Total” as subscript denotes the whole range of wavelengths in the spectrum. This is the default.</p>
<div class="sourceCode" id="cb461"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb461-1"><a href="#cb461-1"></a><span class="kw">e_irrad</span>(sun.spct)</span></code></pre></div>
<pre><code>##  E_Total 
## 269.1249 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<p>To integrate one restricted range of wavelengths from a spectrum, we can provide a wavelength definition. In this example, waveband <code>PAR.wb</code> giving the definition of <em>photosynthetically active radiation</em>. (<code>PAR.wb</code> was defined above.)</p>
<div class="sourceCode" id="cb463"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb463-1"><a href="#cb463-1"></a><span class="kw">e_irrad</span>(sun.spct, PAR.wb)</span></code></pre></div>
<pre><code>##    E_PAR 
## 196.6343 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<p>It is also valid to pass as argument for <code>w.band</code> a numeric range representing wavelengths in manometers (nm), which is converted into a waveband definition on-the-fly. Note, however, that the automatically assigned name gives only the range.</p>
<div class="sourceCode" id="cb465"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb465-1"><a href="#cb465-1"></a><span class="kw">e_irrad</span>(sun.spct, <span class="kw">c</span>(<span class="dv">400</span>, <span class="dv">700</span>))</span></code></pre></div>
<pre><code>## E_range.400.700 
##        196.6343 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<p>The ‘photobiology’ package uses base SI units, so by default photon irradiance (= quantum irradiance) is expressed in <span class="math inline">\(mol\,s^{-1}\,m^{-2}\)</span>. We can pass a scaling factor as shown below if needed.</p>
<div class="sourceCode" id="cb467"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb467-1"><a href="#cb467-1"></a><span class="kw">q_irrad</span>(sun.spct, PAR.wb, <span class="dt">scale.factor =</span> <span class="fl">1e6</span>) <span class="co"># umol s-1 m-2</span></span></code></pre></div>
<pre><code>##    Q_PAR 
## 894.1352 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<p>It is possible to supply a time unit to use, instead of the default of seconds, as basis of expression for the returned value. However, be aware that conversion into a different time unit than that used during measurement, is only valid for sources like lamps, which have an output the remains constant in time.</p>
<div class="sourceCode" id="cb469"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb469-1"><a href="#cb469-1"></a><span class="kw">q_irrad</span>(white_led.source_spct, PAR.wb, <span class="dt">time.unit =</span> <span class="st">&quot;hour&quot;</span>)</span></code></pre></div>
<pre><code>##    Q_PAR 
## 1.584957 
## attr(,&quot;time.unit&quot;)
## [1] &quot;hour&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<p>Using a shorter time unit than the original, yields an average value re-expressed on a new time unit base.</p>
<div class="sourceCode" id="cb471"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb471-1"><a href="#cb471-1"></a><span class="kw">e_irrad</span>(sun.daily.spct, PAR.wb, <span class="dt">time.unit =</span> <span class="st">&quot;second&quot;</span>)</span></code></pre></div>
<pre><code>##    E_PAR 
## 92.16251 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<p>Lists of wavebands are also accepted as argument for parameter <code>w.band</code> in which case a named numeric vector of summary values is returned by default.</p>
<div class="sourceCode" id="cb473"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb473-1"><a href="#cb473-1"></a><span class="kw">e_irrad</span>(sun.spct, UV_bands.lst) <span class="co"># W m-2</span></span></code></pre></div>
<pre><code>##      E_UVB      E_UVA 
##  0.6445105 27.9842061 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<div class="sourceCode" id="cb475"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb475-1"><a href="#cb475-1"></a><span class="kw">q_irrad</span>(sun.spct, UV_bands.lst) <span class="co"># mol s-1 m-2</span></span></code></pre></div>
<pre><code>##        Q_UVB        Q_UVA 
## 1.675362e-06 8.481970e-05 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<div class="sourceCode" id="cb477"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb477-1"><a href="#cb477-1"></a><span class="kw">q_irrad</span>(sun.spct, UV_bands.lst, <span class="dt">scale.factor =</span> <span class="fl">1e6</span>) <span class="co"># umol s-1 m-2</span></span></code></pre></div>
<pre><code>##     Q_UVB     Q_UVA 
##  1.675362 84.819697 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<p>These functions have an additional argument <code>quantity</code>, with default <code>&quot;total&quot;</code>, which can take values controlling the output. The value “total” yields <strong>irradiance</strong> in <span class="math inline">\(W\,m^{-2}\)</span>, integrated over wavelengths for each waveband, while “average” yields the mean <strong>spectral irradiance</strong> within each waveband in <span class="math inline">\(W\,m^{-2}\,nm^{-1}\)</span>.</p>
<div class="sourceCode" id="cb479"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb479-1"><a href="#cb479-1"></a><span class="kw">e_irrad</span>(sun.spct, UV_bands.lst, <span class="dt">quantity =</span> <span class="st">&quot;total&quot;</span>) <span class="co"># watt m-2</span></span></code></pre></div>
<pre><code>##      E_UVB      E_UVA 
##  0.6445105 27.9842061 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<div class="sourceCode" id="cb481"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb481-1"><a href="#cb481-1"></a><span class="kw">e_irrad</span>(sun.spct, UV_bands.lst, <span class="dt">quantity =</span> <span class="st">&quot;average&quot;</span>) <span class="co"># watt m-2 nm-1</span></span></code></pre></div>
<pre><code>##  E(wl)_UVB  E(wl)_UVA 
## 0.01841458 0.32922595 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;average energy irradiance&quot;</code></pre>
<p>When <code>quantity = &quot;contribution&quot;</code> irradiances for individual wavebands are expressed relative to the irradiance computed for the whole spectrum, while for <code>quantity = &quot;relative&quot;</code> they are expressed relative to the sum of the irradiances for all the wavebands. In both cases values are expressed as fractions of one.</p>
<div class="sourceCode" id="cb483"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb483-1"><a href="#cb483-1"></a><span class="kw">e_irrad</span>(sun.spct, UV_bands.lst, <span class="dt">quantity =</span> <span class="st">&quot;contribution&quot;</span>)</span></code></pre></div>
<pre><code>##  E/Etot_UVB  E/Etot_UVA 
## 0.002394838 0.103982226 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;contribution energy irradiance&quot;</code></pre>
<div class="sourceCode" id="cb485"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb485-1"><a href="#cb485-1"></a><span class="kw">e_irrad</span>(sun.spct, UV_bands.lst, <span class="dt">quantity =</span> <span class="st">&quot;relative&quot;</span>)</span></code></pre></div>
<pre><code>## E/Esum_UVB E/Esum_UVA 
## 0.02251273 0.97748727 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;relative energy irradiance&quot;</code></pre>
<p>When setting <code>&quot;contribution.pc&quot;</code> or <code>&quot;relative.pc&quot;</code> as <code>quantity</code> the same values as in the examples above, are expressed as percentages instead of fractions.</p>
<div class="sourceCode" id="cb487"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb487-1"><a href="#cb487-1"></a><span class="kw">e_irrad</span>(sun.spct, UV_bands.lst, <span class="dt">quantity =</span> <span class="st">&quot;contribution.pc&quot;</span>)</span></code></pre></div>
<pre><code>## E/Etot_UVB E/Etot_UVA 
##  0.2394838 10.3982226 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;contribution.pc energy irradiance&quot;</code></pre>
<div class="sourceCode" id="cb489"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb489-1"><a href="#cb489-1"></a><span class="kw">e_irrad</span>(sun.spct, UV_bands.lst, <span class="dt">quantity =</span> <span class="st">&quot;relative.pc&quot;</span>)</span></code></pre></div>
<pre><code>## E/Esum_UVB E/Esum_UVA 
##   2.251273  97.748727 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;relative.pc energy irradiance&quot;</code></pre>
<p>The total radiation received on a surface during an exposure event can be also calculated with methods <code>irrad()</code>, <code>e_irrad()</code> and <code>q_irrad()</code>, but the values returned are irradiances expressed on a very unusual time basis. These are no longer W m-2 (J s-1 m-2), but instead J per 8 hours per square meter.</p>
<div class="sourceCode" id="cb491"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb491-1"><a href="#cb491-1"></a><span class="kw">e_irrad</span>(sun.spct, PAR.wb, <span class="dt">time.unit =</span> <span class="kw">duration</span>(<span class="dv">8</span>, <span class="st">&quot;hours&quot;</span>))</span></code></pre></div>
<pre><code>##   E_PAR 
## 5663067 
## attr(,&quot;time.unit&quot;)
## [1] &quot;28800s (~8 hours)&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy irradiance&quot;</code></pre>
<p>When the intention is to calculate a total fluence or exposure for an event, function <code>fluence()</code>, <code>e_fluence()</code> or <code>q_fluence()</code> should be used as this will add the correct metadata attributes to the returned value: expressed as energy or photons per unit area per event. See later sections for details.</p>
<div class="sourceCode" id="cb493"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb493-1"><a href="#cb493-1"></a><span class="kw">e_fluence</span>(sun.spct, PAR.wb, <span class="dt">exposure.time =</span> <span class="kw">duration</span>(<span class="dv">8</span>, <span class="st">&quot;hours&quot;</span>))</span></code></pre></div>
<pre><code>##   E_PAR 
## 5663067 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;energy fluence (J m-2)&quot;
## attr(,&quot;exposure.duration&quot;)
## [1] &quot;28800s (~8 hours)&quot;</code></pre>
<p>In all earlier examples in this section, the default naming of returned values was active. The default naming of the values is an abbreviation of the physical quantity plus the name of the wavelength. Alternatively <code>&quot;short&quot;</code> naming uses only the name of the wavebands as shown below, obtained from the label stored in the waveband definitions.</p>
<div class="sourceCode" id="cb495"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb495-1"><a href="#cb495-1"></a><span class="kw">q_irrad</span>(sun.spct, UV_bands.lst, <span class="dt">naming =</span> <span class="st">&quot;short&quot;</span>)</span></code></pre></div>
<pre><code>##          UVB          UVA 
## 1.675362e-06 8.481970e-05 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<p>Naming can also be completely suppressed.</p>
<div class="sourceCode" id="cb497"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb497-1"><a href="#cb497-1"></a><span class="kw">q_irrad</span>(sun.spct, UV_bands.lst, <span class="dt">naming =</span> <span class="st">&quot;none&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 1.675362e-06 8.481970e-05
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
<p>Names of members of a list of wavebands, override the labels in waveband definitions.</p>
<div class="sourceCode" id="cb499"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb499-1"><a href="#cb499-1"></a><span class="kw">names</span>(UV_bands.lst) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;UV-C&quot;</span>, <span class="st">&quot;UV-B&quot;</span>, <span class="st">&quot;UV-A&quot;</span>)</span>
<span id="cb499-2"><a href="#cb499-2"></a><span class="kw">q_irrad</span>(sun.spct, UV_bands.lst, <span class="dt">naming =</span> <span class="st">&quot;short&quot;</span>, <span class="dt">scale.factor =</span> <span class="fl">1e6</span>)</span></code></pre></div>
<pre><code>##      UV-B      UV-A 
##  1.675362 84.819697 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
</div>
<div id="collections-of-spectra-4" class="section level4">
<h4>Collections of spectra</h4>
<p>Collections of spectra can be useful not only for time-series of spectra or spectral images, but also when dealing with a small group of related spectra. In the example below we show how to use a collection of spectra to estimate irradiances under different filters set up in sunlight.</p>
<p>We create a collection of two spectra, for use in our examples.</p>
<div class="sourceCode" id="cb501"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb501-1"><a href="#cb501-1"></a>two_suns.mspct &lt;-<span class="st"> </span><span class="kw">source_mspct</span>(<span class="kw">list</span>(<span class="dt">sun1 =</span> sun.spct, <span class="dt">sun2 =</span> sun.spct <span class="op">*</span><span class="st"> </span><span class="dv">2</span>))</span></code></pre></div>
<p>Methods <code>irrad()</code>, <code>e_irrad()</code> and <code>q_irrad()</code> can be used for collections of spectra exactly as for a single spectrum (as described above). We here only show the additional features that apply to collections. In this first example, we can see that the returned object is a data frame instead of a named numeric vector.</p>
<div class="sourceCode" id="cb502"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb502-1"><a href="#cb502-1"></a><span class="kw">e_irrad</span>(two_suns.mspct, <span class="dt">w.band =</span> PAR.wb)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   spct.idx E_PAR
##   &lt;fct&gt;    &lt;dbl&gt;
## 1 sun1      197.
## 2 sun2      393.</code></pre>
<p>Spectral objects can contain metadata as attributes. When summarizing a collection of spectra it is frequently very useful to copy some of these metadata, extracted from each member of the collection, to columns in the returned data frame. This can be done as follows.</p>
<div class="sourceCode" id="cb504"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb504-1"><a href="#cb504-1"></a><span class="kw">q_irrad</span>(two_suns.mspct, </span>
<span id="cb504-2"><a href="#cb504-2"></a>        <span class="dt">w.band =</span> PAR.wb,</span>
<span id="cb504-3"><a href="#cb504-3"></a>        <span class="dt">scale.factor =</span> <span class="fl">1e6</span>, <span class="co"># umol m-2 s-1</span></span>
<span id="cb504-4"><a href="#cb504-4"></a>        <span class="dt">attr2tb =</span> <span class="kw">c</span>(<span class="dt">when.measured =</span> <span class="st">&quot;time&quot;</span>, <span class="dt">lon =</span> <span class="st">&quot;lon&quot;</span>, <span class="dt">lat =</span> <span class="st">&quot;lat&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 2 x 5
##   spct.idx Q_PAR time                  lon   lat
##   &lt;fct&gt;    &lt;dbl&gt; &lt;dttm&gt;              &lt;dbl&gt; &lt;dbl&gt;
## 1 sun1      894. 2010-06-22 09:51:00  25.0  60.2
## 2 sun2     1788. 2010-06-22 09:51:00  25.0  60.2</code></pre>
<p>For a more advanced example, we reuse the collection of filter spectra <code>filters.mspct</code> from an earlier section. We convolve each filter’s spectral transmittance by the spectral irradiance of the light source so as to predict the irradiances under the filters. We specify the name of the column where the names of the spectra (their index) is stored.</p>
<div class="sourceCode" id="cb506"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb506-1"><a href="#cb506-1"></a>filtered_sun &lt;-<span class="st"> </span><span class="kw">convolve_each</span>(filters.mspct, sun.spct)</span>
<span id="cb506-2"><a href="#cb506-2"></a><span class="kw">q_irrad</span>(filtered_sun,</span>
<span id="cb506-3"><a href="#cb506-3"></a>        <span class="kw">list</span>(UVA.wb, PAR.wb),</span>
<span id="cb506-4"><a href="#cb506-4"></a>        <span class="dt">scale.factor =</span> <span class="fl">1e6</span>,</span>
<span id="cb506-5"><a href="#cb506-5"></a>        <span class="dt">idx =</span> <span class="st">&quot;Filter&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   Filter  Q_UVA Q_PAR
##   &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 none   84.8    894.
## 2 pet    70.2    823.
## 3 yellow  0.105  536.</code></pre>
<p>The code above example can also be written as a single statement. Here we also tweak column names, delete one column, and swap the position of the remaining columns.</p>
<div class="sourceCode" id="cb508"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb508-1"><a href="#cb508-1"></a><span class="kw">q_irrad</span>(<span class="kw">convolve_each</span>(filters.mspct, sun.spct), </span>
<span id="cb508-2"><a href="#cb508-2"></a>        <span class="kw">list</span>(<span class="st">&quot;UV-A&quot;</span> =<span class="st"> </span>UVA.wb, PAR.wb),</span>
<span id="cb508-3"><a href="#cb508-3"></a>        <span class="dt">scale.factor =</span> <span class="fl">1e6</span>,  <span class="co"># umol m-2 s-1</span></span>
<span id="cb508-4"><a href="#cb508-4"></a>        <span class="dt">naming =</span> <span class="st">&quot;short&quot;</span>,</span>
<span id="cb508-5"><a href="#cb508-5"></a>        <span class="dt">attr2tb =</span> <span class="kw">c</span>(<span class="dt">what.measured =</span> <span class="st">&quot;Filter type&quot;</span>))[ , <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">3</span>)]</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   `Filter type`                                                    `UV-A`   PAR
##   &lt;chr&gt;                                                             &lt;dbl&gt; &lt;dbl&gt;
## 1 theoretical fully transparent object                             84.8    894.
## 2 clear polyester film                                             70.2    823.
## 3 yellow theatrical &#39;gel&#39;, Rosco supergel no. 312, &#39;canary yellow&#39;  0.105  536.</code></pre>
<p>It is also possible to use an <em>apply</em> function. See sections <em>apply</em> functions and <code>convolve</code> for more details, as in certain cases only one or the other can be used.</p>
</div>
</div>
<div id="fluence" class="section level3">
<h3>Fluence</h3>
<div id="individual-spectra-5" class="section level4">
<h4>Individual spectra</h4>
<p>The calculation of fluence values (time-integrated irradiance) is identical to that for irradiance, except that a <code>exposure.time</code> argument needs to be supplied. The exposure time must be a <code>lubridate::duration</code>, but any argument accepted by <code>as.duration</code> can also be used. Functions <code>fluence</code>, <code>e_fluence</code> and <code>q_fluence</code> correspond to <code>irrad</code>, <code>e_irrad</code> and <code>q_irrad</code>,</p>
<div class="sourceCode" id="cb510"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb510-1"><a href="#cb510-1"></a><span class="kw">fluence</span>(sun.spct, <span class="dt">exposure.time =</span> <span class="kw">duration</span>(<span class="dv">1</span>, <span class="st">&quot;hours&quot;</span>))</span></code></pre></div>
<pre><code>##  E_Total 
## 968849.6 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;energy fluence (J m-2)&quot;
## attr(,&quot;exposure.duration&quot;)
## [1] &quot;3600s (~1 hours)&quot;</code></pre>
<p>or</p>
<div class="sourceCode" id="cb512"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb512-1"><a href="#cb512-1"></a><span class="kw">fluence</span>(sun.spct, <span class="dt">exposure.time =</span> <span class="dv">3600</span>) <span class="co"># seconds</span></span></code></pre></div>
<pre><code>## converting &#39;time.unit&#39; 3600 into a lubridate::duration</code></pre>
<pre><code>##  E_Total 
## 968849.6 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;energy fluence (J m-2)&quot;
## attr(,&quot;exposure.duration&quot;)
## [1] 3600</code></pre>
<p>and, to obtain the photon fluence for a range of wavelengths, in the example, photosynthetically active radiation, we use the <code>PAR.wb</code> waveband object earlier defined, and integrate for 25 minutes of exposure.</p>
<div class="sourceCode" id="cb515"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb515-1"><a href="#cb515-1"></a><span class="kw">q_fluence</span>(sun.spct, PAR.wb, <span class="dt">exposure.time =</span> <span class="kw">duration</span>(<span class="dv">25</span>, <span class="st">&quot;minutes&quot;</span>))</span></code></pre></div>
<pre><code>##    Q_PAR 
## 1.341203 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;photon fluence (mol m-2)&quot;
## attr(,&quot;exposure.duration&quot;)
## [1] &quot;1500s (~25 minutes)&quot;</code></pre>
</div>
</div>
<div id="photon-and-energy-ratios" class="section level3">
<h3>Photon and energy ratios</h3>
<div id="individual-spectra-6" class="section level4">
<h4>Individual spectra</h4>
<p>The functions described here, in there simplest use, calculate a ratio between two wavebands. The function <code>q_ratio</code> returning photon ratios. However both waveband parameters can take lists of wavebands as arguments, with normal recycling rules in effect. The corresponding function <code>e_ratio</code> returns energy ratios.</p>
<p>A single ratio.</p>
<div class="sourceCode" id="cb517"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb517-1"><a href="#cb517-1"></a><span class="kw">q_ratio</span>(sun.spct, UVB.wb, PAR.wb)</span></code></pre></div>
<pre><code>## UVB:PAR[q:q] 
##  0.001873724 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;q:q ratio&quot;</code></pre>
<p>If no waveband is passed as numerator, the whole spectrum is used. The waveband fully outside the wavelength range of the spectrum is dropped silently.</p>
<div class="sourceCode" id="cb519"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb519-1"><a href="#cb519-1"></a><span class="kw">q_ratio</span>(sun.spct, <span class="kw">list</span>(UVC.wb, UVB.wb, UVA.wb))</span></code></pre></div>
<pre><code>## UVB:Total[q:q] UVA:Total[q:q] 
##    0.001334593    0.067567343 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;q:q ratio&quot;</code></pre>
<p>Three denominators (one skipped) and a single denominator.</p>
<div class="sourceCode" id="cb521"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb521-1"><a href="#cb521-1"></a><span class="kw">q_ratio</span>(sun.spct, <span class="kw">list</span>(UVC.wb, UVB.wb, UVA.wb), PAR.wb)</span></code></pre></div>
<pre><code>## UVB:PAR[q:q] UVA:PAR[q:q] 
##  0.001873724  0.094862270 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;q:q ratio&quot;</code></pre>
<p>Function <code>qe_ratio</code>, has only one waveband parameter, and returns the <em>photon</em> to <em>energy</em> ratio, while its complement <code>eq_ratio</code> returns the <em>energy</em> to <em>photon</em> ratio. Here we show how parameters <code>scale.factor</code> and <code>name.tag</code> make scaling the returned value easy.</p>
<div class="sourceCode" id="cb523"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb523-1"><a href="#cb523-1"></a><span class="kw">qe_ratio</span>(sun.spct,</span>
<span id="cb523-2"><a href="#cb523-2"></a>         <span class="kw">list</span>(<span class="st">&quot;UV-B&quot;</span> =<span class="st"> </span>UVB.wb, PAR.wb), </span>
<span id="cb523-3"><a href="#cb523-3"></a>         <span class="dt">scale.factor =</span> <span class="fl">1e6</span>,</span>
<span id="cb523-4"><a href="#cb523-4"></a>         <span class="dt">name.tag =</span> <span class="st">&quot; (umol/J)&quot;</span>)</span></code></pre></div>
<pre><code>## UV-B (umol/J)  PAR (umol/J) 
##      2.599434      4.547199 
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;q:e ratio&quot;</code></pre>
</div>
<div id="collections-of-spectra-5" class="section level4">
<h4>Collections of spectra</h4>
<p>As other summary methods, <code>q_ratio()</code>, <code>e_ratio()</code>, <code>qe_ratio()</code> and <code>eq_ratio()</code> when applied to a collection of spectra, they return a data frame.</p>
<div class="sourceCode" id="cb525"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb525-1"><a href="#cb525-1"></a><span class="kw">q_ratio</span>(filtered_sun, </span>
<span id="cb525-2"><a href="#cb525-2"></a>        <span class="kw">list</span>(UVB.wb, UVA.wb),</span>
<span id="cb525-3"><a href="#cb525-3"></a>        PAR.wb)</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   spct.idx `UVB:PAR[q:q]` `UVA:PAR[q:q]`
##   &lt;fct&gt;             &lt;dbl&gt;          &lt;dbl&gt;
## 1 none         0.00187          0.0949  
## 2 pet          0.0000514        0.0854  
## 3 yellow       0.00000371       0.000196</code></pre>
<p>Additional parameters allow the scaling and customized column names possible.</p>
<div class="sourceCode" id="cb527"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb527-1"><a href="#cb527-1"></a><span class="kw">q_ratio</span>(filtered_sun, </span>
<span id="cb527-2"><a href="#cb527-2"></a>        <span class="kw">list</span>(UVB.wb, UVA.wb),</span>
<span id="cb527-3"><a href="#cb527-3"></a>        PAR.wb, </span>
<span id="cb527-4"><a href="#cb527-4"></a>        <span class="dt">scale.factor =</span> <span class="dv">100</span>, </span>
<span id="cb527-5"><a href="#cb527-5"></a>        <span class="dt">name.tag =</span> <span class="st">&quot; (% photons)&quot;</span>, </span>
<span id="cb527-6"><a href="#cb527-6"></a>        <span class="dt">idx =</span> <span class="st">&quot;Filter&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   Filter `UVB:PAR (% photons)` `UVA:PAR (% photons)`
##   &lt;fct&gt;                  &lt;dbl&gt;                 &lt;dbl&gt;
## 1 none                0.187                   9.49  
## 2 pet                 0.00514                 8.54  
## 3 yellow              0.000371                0.0196</code></pre>
</div>
</div>
<div id="normalized-difference-indexes" class="section level3">
<h3>Normalized difference indexes</h3>
</div>
<div id="individual-spectra-7" class="section level3">
<h3>Individual spectra</h3>
<p>These indexes are frequently used to summarize reflectance data, for example in remote sensing the NDVI (normalized difference vegetation index). Here we give an <em>unusual</em> example to demonstrate that function <code>normalized_diff_ind()</code> can be used to calculate, or define any similar index.</p>
<div class="sourceCode" id="cb529"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb529-1"><a href="#cb529-1"></a><span class="kw">normalized_diff_ind</span>(sun.spct,</span>
<span id="cb529-2"><a href="#cb529-2"></a>                    <span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">400</span>, <span class="dv">500</span>)), <span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">600</span>, <span class="dv">700</span>)),</span>
<span id="cb529-3"><a href="#cb529-3"></a>                    q_irrad)</span></code></pre></div>
<pre><code>## NDI q_irrad [400.500] - [600.700] 
##                       -0.09188363</code></pre>
</div>
<div id="transmittance-reflectance-absorptance-and-absorbance" class="section level3">
<h3>Transmittance, reflectance, absorptance and absorbance</h3>
<div id="individual-spectra-8" class="section level4">
<h4>Individual spectra</h4>
<p>The functions <code>transmittance</code>, <code>absorptance</code> and <code>absorbance</code> take <code>filter_spct</code> as argument, while function <code>reflectance</code> takes <code>reflector_spct</code> objects as argument. Functions <code>transmittance</code>, <code>reflectance</code> and <code>absorptance</code> are also implemented for <code>object_spct</code>. These functions return as default an average value for these quantities <strong>assuming</strong> a light source with a flat spectral energy output, but this can be changed as described above for <code>irrad()</code>.</p>
<div class="sourceCode" id="cb531"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb531-1"><a href="#cb531-1"></a><span class="kw">transmittance</span>(polyester.spct, <span class="kw">list</span>(UVB.wb, UVA.wb, PAR.wb))</span></code></pre></div>
<pre><code>## Tfr(wl)_UVB Tfr(wl)_UVA Tfr(wl)_PAR 
## 0.007671429 0.782682353 0.920245000 
## attr(,&quot;Tfr.type&quot;)
## [1] &quot;unknown&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;transmittance average&quot;</code></pre>
<p>We can obtain numerical values without names if needed,</p>
<div class="sourceCode" id="cb533"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb533-1"><a href="#cb533-1"></a><span class="kw">transmittance</span>(polyester.spct, </span>
<span id="cb533-2"><a href="#cb533-2"></a>              <span class="kw">list</span>(UVB.wb, UVA.wb, PAR.wb),</span>
<span id="cb533-3"><a href="#cb533-3"></a>              <span class="dt">naming =</span> <span class="st">&quot;none&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 0.007671429 0.782682353 0.920245000
## attr(,&quot;Tfr.type&quot;)
## [1] &quot;unknown&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;transmittance average&quot;</code></pre>
<p>or named only according to the wavebands.</p>
<div class="sourceCode" id="cb535"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb535-1"><a href="#cb535-1"></a><span class="kw">transmittance</span>(polyester.spct, </span>
<span id="cb535-2"><a href="#cb535-2"></a>              <span class="kw">list</span>(UVB.wb, UVA.wb, PAR.wb),</span>
<span id="cb535-3"><a href="#cb535-3"></a>              <span class="dt">naming =</span> <span class="st">&quot;short&quot;</span>)</span></code></pre></div>
<pre><code>##         UVB         UVA         PAR 
## 0.007671429 0.782682353 0.920245000 
## attr(,&quot;Tfr.type&quot;)
## [1] &quot;unknown&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;transmittance average&quot;</code></pre>
<div class="sourceCode" id="cb537"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb537-1"><a href="#cb537-1"></a><span class="kw">reflectance</span>(green_leaf.spct, <span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">600</span>, <span class="dv">700</span>)))</span></code></pre></div>
<pre><code>## Rfr(wl)_range.600.700 
##              0.089647 
## attr(,&quot;Rfr.type&quot;)
## [1] &quot;unknown&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;reflectance average&quot;</code></pre>
<p>It is more likely that we would like to calculate these values with reference to light of a certain spectral quality. This needs to be calculated by hand, which is not difficult.</p>
<div class="sourceCode" id="cb539"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb539-1"><a href="#cb539-1"></a><span class="kw">q_irrad</span>(sun.spct <span class="op">*</span><span class="st"> </span>polyester.spct, <span class="kw">list</span>(UVB.wb, UVA.wb, PAR.wb), <span class="dt">wb.trim =</span> <span class="ot">TRUE</span>) <span class="op">/</span></span>
<span id="cb539-2"><a href="#cb539-2"></a><span class="st">  </span><span class="kw">q_irrad</span>(sun.spct, <span class="kw">list</span>(UVB.wb, UVA.wb, PAR.wb), <span class="dt">wb.trim =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>##     Q_UVB     Q_UVA     Q_PAR 
## 0.0252541 0.8279389 0.9201843 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total photon irradiance&quot;</code></pre>
</div>
<div id="collections-of-spectra-6" class="section level4">
<h4>Collections of spectra</h4>
<p>Here we calculate the transmittance of a collection of spectra for three filters in two wavebands, obtaining the results as a data frame, with one row per filter, and one column per waveband. We reuse once more <code>filters.mspct</code> from an earlier section.</p>
<p>Column names formed from quantity abbreviation and label in waveband definitions.</p>
<div class="sourceCode" id="cb541"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb541-1"><a href="#cb541-1"></a><span class="kw">transmittance</span>(filters.mspct, </span>
<span id="cb541-2"><a href="#cb541-2"></a>              <span class="dt">w.band =</span> <span class="kw">list</span>(UVA.wb, PAR.wb))</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   spct.idx `Tfr(wl)_UVA` `Tfr(wl)_PAR`
##   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;
## 1 none           1.00            1.00 
## 2 pet            0.783           0.920
## 3 yellow         0.00160         0.566</code></pre>
<p>With <code>naming = &quot;short&quot;</code> column names are the labels of waveband definitions.</p>
<div class="sourceCode" id="cb543"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb543-1"><a href="#cb543-1"></a><span class="kw">transmittance</span>(filters.mspct, </span>
<span id="cb543-2"><a href="#cb543-2"></a>              <span class="dt">w.band =</span> <span class="kw">list</span>(UVA.wb, PAR.wb),</span>
<span id="cb543-3"><a href="#cb543-3"></a>              <span class="dt">naming =</span> <span class="st">&quot;short&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   spct.idx     UVA   PAR
##   &lt;fct&gt;      &lt;dbl&gt; &lt;dbl&gt;
## 1 none     1.00    1.00 
## 2 pet      0.783   0.920
## 3 yellow   0.00160 0.566</code></pre>
<p>If list members are named, column names are formed from quantity abbreviation and name of list members, overriding the labels in the waveband definitions.</p>
<div class="sourceCode" id="cb545"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb545-1"><a href="#cb545-1"></a><span class="kw">transmittance</span>(filters.mspct, </span>
<span id="cb545-2"><a href="#cb545-2"></a>              <span class="dt">w.band =</span> <span class="kw">list</span>(<span class="st">&quot;UV-A&quot;</span> =<span class="st"> </span>UVA.wb, <span class="dt">PAR =</span> PAR.wb))</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   spct.idx `Tfr(wl)_UV-A` `Tfr(wl)_PAR`
##   &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;
## 1 none            1.00            1.00 
## 2 pet             0.783           0.920
## 3 yellow          0.00160         0.566</code></pre>
<p>If list members are named, with <code>naming = &quot;short&quot;</code> column names are the names of list members.</p>
<div class="sourceCode" id="cb547"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb547-1"><a href="#cb547-1"></a><span class="kw">transmittance</span>(filters.mspct, </span>
<span id="cb547-2"><a href="#cb547-2"></a>              <span class="dt">w.band =</span> <span class="kw">list</span>(<span class="dt">UVA =</span> UVA.wb, <span class="dt">PAR =</span> PAR.wb),</span>
<span id="cb547-3"><a href="#cb547-3"></a>              <span class="dt">naming =</span> <span class="st">&quot;short&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   spct.idx     UVA   PAR
##   &lt;fct&gt;      &lt;dbl&gt; &lt;dbl&gt;
## 1 none     1.00    1.00 
## 2 pet      0.783   0.920
## 3 yellow   0.00160 0.566</code></pre>
<p>We can add metadata attributes as columns, changing the name if desired.</p>
<div class="sourceCode" id="cb549"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb549-1"><a href="#cb549-1"></a><span class="kw">transmittance</span>(filters.mspct, </span>
<span id="cb549-2"><a href="#cb549-2"></a>              <span class="dt">w.band =</span> UVA.wb,</span>
<span id="cb549-3"><a href="#cb549-3"></a>              <span class="dt">naming =</span> <span class="st">&quot;short&quot;</span>,</span>
<span id="cb549-4"><a href="#cb549-4"></a>              <span class="dt">attr2tb =</span> <span class="kw">c</span>(<span class="st">&quot;what.measured&quot;</span> =<span class="st"> &quot;Filter type&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   spct.idx     UVA `Filter type`                                                
##   &lt;fct&gt;      &lt;dbl&gt; &lt;chr&gt;                                                        
## 1 none     1.00    theoretical fully transparent object                         
## 2 pet      0.783   clear polyester film                                         
## 3 yellow   0.00160 yellow theatrical &#39;gel&#39;, Rosco supergel no. 312, &#39;canary yel~</code></pre>
<p>We can add metadata attributes as a column, and select and rearrange the columns.</p>
<div class="sourceCode" id="cb551"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb551-1"><a href="#cb551-1"></a><span class="kw">transmittance</span>(filters.mspct,</span>
<span id="cb551-2"><a href="#cb551-2"></a>              <span class="dt">w.band =</span> UVA.wb,</span>
<span id="cb551-3"><a href="#cb551-3"></a>              <span class="dt">attr2tb =</span> <span class="st">&quot;what.measured&quot;</span>)[ , <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>)]</span></code></pre></div>
<pre><code>## # A tibble: 3 x 2
##   what.measured                                                    `Tfr(wl)_UVA`
##   &lt;chr&gt;                                                                    &lt;dbl&gt;
## 1 theoretical fully transparent object                                   1.00   
## 2 clear polyester film                                                   0.783  
## 3 yellow theatrical &#39;gel&#39;, Rosco supergel no. 312, &#39;canary yellow&#39;       0.00160</code></pre>
</div>
</div>
<div id="integrated-response" class="section level3">
<h3>Integrated response</h3>
<div id="individual-spectra-9" class="section level4">
<h4>Individual spectra</h4>
<p>The functions <code>response</code>, <code>e_response</code> and <code>q_response</code> take <code>response_spct</code> objects as arguments, and return the integrated value for each waveband (integrated over wavelength) <strong>assuming</strong> a light source with a flat spectral energy or photon output respectively. If no waveband is supplied as argument, the whole spectrum is integrated.</p>
<div class="sourceCode" id="cb553"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb553-1"><a href="#cb553-1"></a><span class="kw">response</span>(photodiode.spct)</span></code></pre></div>
<pre><code>## R[/e]_Total 
##    24.40478 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy response&quot;</code></pre>
<p>When a waveband, or list of wavebands, is supplied the response is calculated for the wavebands.</p>
<div class="sourceCode" id="cb555"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb555-1"><a href="#cb555-1"></a><span class="kw">e_response</span>(photodiode.spct, <span class="kw">list</span>(UVB.wb, UVA.wb))</span></code></pre></div>
<pre><code>## R[/e]_]UVB  R[/e]_UVA 
##   0.346462   5.981818 
## attr(,&quot;time.unit&quot;)
## [1] &quot;second&quot;
## attr(,&quot;radiation.unit&quot;)
## [1] &quot;total energy response&quot;</code></pre>
<p>This function has an additional argument <code>quantity</code>, with default <code>&quot;total&quot;</code>, as described for <code>irrad()</code>.</p>
</div>
<div id="collections-of-spectra-7" class="section level4">
<h4>Collections of spectra</h4>
<div class="sourceCode" id="cb557"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb557-1"><a href="#cb557-1"></a>sensors &lt;-<span class="st"> </span><span class="kw">response_mspct</span>(<span class="kw">list</span>(<span class="dt">GaAsP =</span> photodiode.spct,</span>
<span id="cb557-2"><a href="#cb557-2"></a>                               <span class="dt">CCD =</span> ccd.spct))</span>
<span id="cb557-3"><a href="#cb557-3"></a><span class="kw">response</span>(sensors, <span class="kw">list</span>(UVB.wb, UVA.wb, PAR.wb), <span class="dt">quantity =</span> <span class="st">&quot;contribution&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 2 x 4
##   spct.idx `R/Rtot[/e]_]UVB` `R/Rtot[/e]_UVA` `R/Rtot[/e]_PAR[`
##   &lt;fct&gt;                &lt;dbl&gt;            &lt;dbl&gt;             &lt;dbl&gt;
## 1 GaAsP               0.0142           0.245              0.741
## 2 CCD                 0.0215           0.0634             0.411</code></pre>
</div>
</div>
<div id="integration-over-wavelengths" class="section level3">
<h3>Integration over wavelengths</h3>
<p>When we need to integrate some  <code>numeric</code> variable stored in a spectral object we can use functions <code>integrate_spct</code> or <code>average_spct</code>.</p>
<div id="calculation-from-individual-spectra" class="section level4">
<h4>Calculation from individual spectra</h4>
<p>We can integrate the values of arbitrary <code>numeric</code> columns other than <code>w.length</code> in an spectral object. All spectral classes are derived from <code>generic_spct</code>, so the examples in this section apply to objects of any of the derived spectral classes as well.</p>
<div class="sourceCode" id="cb559"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb559-1"><a href="#cb559-1"></a><span class="kw">integrate_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>##      e.irrad      q.irrad 
## 2.691249e+02 1.255336e-03</code></pre>
<p>The function <code>average_spct</code> integrates every column holding numeric values from a spectrum object, except for <code>w.length</code>, and divides the result by the <em>spread</em> or width of the wavelength range integrated, returning a value expressed in the same units as the spectral data.</p>
<div class="sourceCode" id="cb561"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb561-1"><a href="#cb561-1"></a><span class="kw">average_spct</span>(sun.spct)</span></code></pre></div>
<pre><code>##      e.irrad      q.irrad 
## 5.175479e-01 2.414107e-06</code></pre>
</div>
</div>
</div>
<div id="comparison-of-spectra" class="section level2">
<h2>Comparison of spectra</h2>
<p>Comparison of spectra for which data is expressed at different discrete wavelength values can be easily affected by bias if interpolation is used. Function <code>compare_spct()</code> does a coarse grained comparison by first summarizing each spectrum over consecutive ranges of wavelengths, and then applying a comparison function to these summary values.</p>
<p>The function can be used to compare pairs of spectra, stored as a collection. In the next example we compare two <code>source_spct</code> objects using defaults for most arguments.</p>
<div class="sourceCode" id="cb563"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb563-1"><a href="#cb563-1"></a><span class="kw">compare_spct</span>(<span class="kw">source_mspct</span>(<span class="kw">list</span>(<span class="dt">sun1 =</span> sun.spct, <span class="dt">sun2 =</span> sun.spct <span class="op">*</span><span class="st"> </span><span class="dv">2</span>)))</span></code></pre></div>
<pre><code>## Object: generic_spct [52 x 6]
## Wavelength range 285 to 795 nm, step 10 nm 
## 
## # A tibble: 52 x 6
##   w.length wl.min wl.max sun1.irrad sun2.irrad comparison.result
##      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;             &lt;dbl&gt;
## 1      285    280    290    0          0                     NaN
## 2      295    290    300    0.00204    0.00407                 2
## 3      305    300    310    0.203      0.406                   2
## 4      315    310    320    1.13       2.26                    2
## # ... with 48 more rows</code></pre>
<p>The value returned by default is a <code>generic_spct</code> object containing the computed summaries for each waveband plus the result of the comparison between the summaries. The first three columns contain the wavelength at the midpoint of the wavelength range of waveband plus its extremes.</p>
<p>In this example we compare two <code>filter_spct</code> objects, using summaries over 50-nm-wide bands, and using an operator returning a logical value for the comparison instead of the default division operator.</p>
<div class="sourceCode" id="cb565"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb565-1"><a href="#cb565-1"></a><span class="kw">compare_spct</span>(<span class="kw">filter_mspct</span>(<span class="kw">list</span>(<span class="dt">pet =</span> polyester.spct,</span>
<span id="cb565-2"><a href="#cb565-2"></a>                              <span class="dt">yllw =</span> yellow_gel.spct)),</span>
<span id="cb565-3"><a href="#cb565-3"></a>             <span class="dt">w.band =</span> <span class="dv">50</span>,</span>
<span id="cb565-4"><a href="#cb565-4"></a>            <span class="dt">.comparison.fun =</span> <span class="st">`</span><span class="dt">&lt;</span><span class="st">`</span>)</span></code></pre></div>
<pre><code>## Object: generic_spct [12 x 6]
## Wavelength range 215 to 765 nm, step 50 nm 
## 
## # A tibble: 12 x 6
##   w.length wl.min wl.max pet.transmittance yllw.transmittance comparison.result
##      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;             &lt;dbl&gt;              &lt;dbl&gt; &lt;lgl&gt;            
## 1      215    190    240           0.00862          0.000169  TRUE             
## 2      265    240    290           0.00385          0.0000100 TRUE             
## 3      315    290    340           0.292            0.00221   TRUE             
## 4      365    340    390           0.861            0.000815  TRUE             
## # ... with 8 more rows</code></pre>
</div>
<div id="rgb-colours" class="section level2">
<h2>RGB colours</h2>
<p>Different <code>color_of()</code> methods allow calculation of RGB color values for light sources or objects. The returned values are R color definitions. Method <code>color_of()</code> works rather differently depending on the object. The method for <code>numeric</code> vectors assumes the numbers are wavelengths in nanometers, and returns a vector of color definitions of the same length assuming monochromatic light.</p>
<div class="sourceCode" id="cb567"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb567-1"><a href="#cb567-1"></a><span class="kw">color_of</span>(<span class="dv">550</span>) <span class="co"># green</span></span></code></pre></div>
<pre><code>## wl.550.nm.CMF 
##     &quot;#00FF00&quot;</code></pre>
<div class="sourceCode" id="cb569"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb569-1"><a href="#cb569-1"></a><span class="kw">color_of</span>(<span class="dv">630</span>) <span class="co"># red</span></span></code></pre></div>
<pre><code>## wl.630.nm.CMF 
##     &quot;#FF0000&quot;</code></pre>
<div class="sourceCode" id="cb571"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb571-1"><a href="#cb571-1"></a><span class="kw">color_of</span>(<span class="kw">c</span>(<span class="dv">550</span>, <span class="dv">630</span>, <span class="dv">380</span>, <span class="dv">750</span>)) <span class="co"># vectorized</span></span></code></pre></div>
<pre><code>## wl.550.nm.CMF wl.630.nm.CMF wl.380.nm.CMF wl.750.nm.CMF 
##     &quot;#00FF00&quot;     &quot;#FF0000&quot;     &quot;#000000&quot;     &quot;#000000&quot;</code></pre>
<p>The method for <code>source_spct</code> objects returns a single colour definition corresponding to the whole spectrum of a light sources.</p>
<div class="sourceCode" id="cb573"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb573-1"><a href="#cb573-1"></a><span class="kw">color_of</span>(sun.spct)</span></code></pre></div>
<pre><code>## source.CMF 
##  &quot;#544F4B&quot;</code></pre>
<div class="sourceCode" id="cb575"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb575-1"><a href="#cb575-1"></a><span class="kw">color_of</span>(sun.spct <span class="op">*</span><span class="st"> </span>yellow_gel.spct)</span></code></pre></div>
<pre><code>## source.CMF 
##  &quot;#946000&quot;</code></pre>
<p>There are no methods for <code>filter_spct</code> and <code>reflector_spct</code> objects so as shown above we need to convolve them with spectral irradiance from a <code>source_spct</code> object.</p>
<p>The method for <code>waveband</code> objects returns one color definition per waveband, corresponding to their central wavelength.</p>
<div class="sourceCode" id="cb577"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb577-1"><a href="#cb577-1"></a><span class="kw">color_of</span>(<span class="kw">waveband</span>(<span class="kw">c</span>(<span class="dv">400</span>, <span class="dv">500</span>), <span class="dt">wb.name =</span> <span class="st">&quot;my_BL&quot;</span>))</span></code></pre></div>
<pre><code>## my_BL.CMF 
## &quot;#000EFF&quot;</code></pre>
<p>By default CIE coordinates for <em>typical</em> human vision are used, but the functions have a parameter that can be used for supplying a different chromaticity definition as a <code>chroma_spct</code> object.</p>
<div class="sourceCode" id="cb579"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb579-1"><a href="#cb579-1"></a><span class="kw">color_of</span>(sun.spct, <span class="dt">chroma.type =</span> <span class="st">&quot;CC&quot;</span>)</span></code></pre></div>
<pre><code>## source.CC 
## &quot;#B63C37&quot;</code></pre>
<div class="sourceCode" id="cb581"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb581-1"><a href="#cb581-1"></a><span class="kw">color_of</span>(sun.spct, <span class="dt">chroma.type =</span> <span class="st">&quot;CMF&quot;</span>)</span></code></pre></div>
<pre><code>## source.CMF 
##  &quot;#544F4B&quot;</code></pre>
<div class="sourceCode" id="cb583"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb583-1"><a href="#cb583-1"></a><span class="kw">color_of</span>(sun.spct, <span class="dt">chroma.type =</span> beesxyzCMF.spct)</span></code></pre></div>
<pre><code>## source.chroma 
##     &quot;#CD1F11&quot;</code></pre>
<p>In the case of bees, the RGB values represent a shift towards longer wavelengths compared to the true sensitivity. In other words, they are translated into colours that humans can see and monitors and printers can generate.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
