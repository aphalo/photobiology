%\VignetteEngine{knitr}
%\VignetteIndexEntry{User guide}
%\VignetteDepends{knitr, photobiology, photobiologyWavebands, photobiologySun, photobiologyFilters, photobiologySensors, ggplot2, ggtern}
%\VignetteKeyword{misc}

\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\usepackage{listings}
%\usepackage{booktabs}
%\usepackage{breakurl}
\usepackage{xspace}
\usepackage{framed}

\newcommand{\PB}{\textsf{photobiology}\xspace}
\newcommand{\PBVIS}{\textsf{photobiologyVIS}\xspace}
\newcommand{\PBUV}{\textsf{photobiologyUV}\xspace}
\newcommand{\PBPHY}{\textsf{photobiologyPhy}\xspace}
\newcommand{\PBCRY}{\textsf{photobiologyCry}\xspace}
\newcommand{\PBFLT}{\textsf{photobiologyFilters}\xspace}
\newcommand{\PBLA}{\textsf{photobiologyLamps}\xspace}

\newcommand{\UV}{UV\xspace}
\newcommand{\UVB}{UV-B\xspace}
\newcommand{\UVA}{UV-A\xspace}

\newcommand{\Unit}[1]{\ensuremath{\mathrm{#1}}\xspace}

\newcommand{\watt}{\Unit{W\,m^{-2}}}
\newcommand{\wattnm}{\Unit{W\,m^{-2}\,nm^{-1}}}
\newcommand{\mwattnm}{\Unit{mW\,m^{-2}\,nm^{-1}}}
\newcommand{\mol}{\Unit{mol\,m^{-2}\,s^{-1}}}
\newcommand{\molnm}{\Unit{mol\,m^{-2}\,s^{-1}\,nm^{-1}}}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(fig.path='figure/pos-', fig.align='center', fig.show='hold',
               fig.width=7, fig.height=6, size="footnotesize")
# options(replace.assign=TRUE,width=60)
@

<<example-0-hiden, eval=TRUE, include=FALSE>>=
library(photobiology)
library(photobiologyWavebands)
library(photobiologySun)
library(photobiologyFilters)
library(photobiologySensors)
library(ggplot2)
library(ggtern)
@

<<own-set-up, echo=FALSE, include=FALSE>>=
my_version <- packageVersion("photobiology")
@

\title{\PB Version \Sexpr{my_version}\\ User Guide}
\author{Pedro J. Aphalo}

\maketitle

\tableofcontents

\section{Introduction}

We have developed a set of packages to
facilitate the calculation of many different quantities that can be derived from spectral irradiance data. The base package in this suite is called \PB, and is the package described here. There other specialized packages for quantification of ultraviolet radiation (\PBUV), visible radiation (\PBVIS), or based on Phytochrome (\PBPHY), Cryptochrome (\PBCRY) (both photoreceptors present in plants), and
spectral data for filters (\PBFLT). In the future it will be submitted to CRAN (Comprehensive R archive network), it is meanwhile available from \url{https://www.r4photobiology.info/}. There is also a public Git repository at \url{https://bitbucket.org/aphalo/} from where the source code of the current an earlier versions can be cloned.

\section{Installation and use}

The functions in the package \PB are
made available by installing the packages \verb!photobiology! (once) and
loading it from the library when needed.

To load the package into the workspace we use \verb!library(photobiology)!.

<<example-0-visible, eval=FALSE>>=
library(photobiology)
library(photobiologyWavebands)
library(photobiologySun)
library(photobiologyFilters)
library(photobiologySensors)
library(ggplot2)
library(ggtern)
@

\section{Spectral data and their handling}

The package provides two sets of functions for many operations: functions programmed following a functional paradigm, and functions using an object-oriented paradigm. The former functions take as arguments numeric vectors and are probably faster. The later ones take `spectra' objects as arguments, are easier to use, and at least at the moment, to some extent slower. For everyday use `spectra' objects are recommended, but when maximum performance or flexibility in scripts is desired, the use of the functions taking numeric vectors as arguments may allow optimizations that are not possible with the object-oriented higher level functions.

\subsection{Example spectral data}

A few data objects are included in the package for use in examples. Two simulated solar spectra, \texttt{sun.spct} and \texttt{sun.daily.spct}, \ldots

\subsection{Using numeric vectors}

When dealing with spectra, we operate on pairs of vectors, one with the wavelengths in nm, and a second one with the corresponding values for the spectral data.

It is usual to `group' these two (or more) vectors into a data frame. For vectors within a data frame we need to `make them visible' when operating with the functions that expect numeric vectors as arguments.

\subsection{Using `spectra' objects}

This package defines a family of objects based on data tables (data frame compatible objects) which impose some restrictions on the naming of the vectors, something that allows the second set of functions to `find' the data when passed one of these objects as argument. In addition, as the data is checked when the object is built, there is no need to test for the validity of the data each time a calculation is carried out. The other advantage of using \texttt{spct} objects, is that specialized versions of generic functions like \texttt{print} and operators like \texttt{+} can be defined for spectra. \texttt{\_\_\_.spct} objects are derived from data.table objects, which in turn are derived from data.frame objects. In this package we define a \textit{generic} spectrum type of object, derived from data table, from which specialized types of spectra are derived. This `parenthood' hierarchy means that spectra objects can be used almost anywhere where a \texttt{data.frame} or \texttt{data.table} is expected. Many functions defined in package \texttt{data.table} are useful when working with spectra.
%, so that in most cases there is no need to explicitly include \texttt{library(data.table)} in your scripts.

Although \texttt{data.tables} are syntactically compatible with \texttt{data.frames}, in some special cases the same code may have different semantics as data tables use references in some cases were data frames would use a copy of the data. In general, no such problems exist, and the different semantics only applies to data table specific syntax. If in doubt, to avoid problems, when you really intend to make a new copy of a spectrum, preserving the original object unchanged by later operations on the new `name', use function \texttt{copy} in addition to the assignment operator.

<<>>=
# 1) data frame syntax on a data.frame
a.df <- data.frame(x=1:3, y=rep(1, 3))
b.df <- a.df
b.df$y <- b.df$y * 2
b.df
a.df # not modified!
# 2) data frame syntax on a data.table
a.dt <- data.table(x=1:3, y=rep(1, 3))
b.dt <- a.dt
b.dt$y <- b.dt$y * 2
b.dt
a.dt # not modified!
# 3) data table syntax on a data.table
a.dt <- data.table(x=1:3, y=rep(1, 3))
b.dt <- a.dt
b.dt[ , y := y * 2]
a.dt # modified!
# 4) forcing creation of a copy
a.dt <- data.table(x=1:3, y=rep(1, 3))
c.dt <- copy(a.dt)
c.dt[ , y := y * 2]
a.dt # not modified!
@

From the examples above one can see that in example 3) \texttt{b.dt} is not a copy of \texttt{a.dt}, but instead a reference (a new name pointing to the original object), while in examples 1), 2) and 4) \texttt{b.dt}, is a new object, initialized to the value of \texttt{a.dt}.

Spectral objects are printed in the current version of the package by the function defined in package \texttt{data.frame}, consequently, it is possible to use options from this package to control printing. The first option set below, \texttt{datatable.print.nrows}, determines the number of rows above which only `head' and `tail' rows are printed. The second option, \texttt{datatable.print.topn}, determines how many rows are printed when not all rows are printed.

<<set-up-printing>>=
options(datatable.print.nrows=10)
options(datatable.print.topn=2)
@

The number of rows printed can be also controlled through an explicit argument to the second parameter of \texttt{print}, \texttt{head}, and \texttt{tail}. Setting an option by means of \texttt{options} changes the default behaviour of \texttt{print}, but explicit arguments can still be used for changing this behaviour in an individual statement. The statement \texttt{a.dt} implicitly calls \texttt{print} when using R in interactive mode.

<<>>=
a.dt
print(a.dt)
print(a.dt, 1L)
head(a.dt, 2L)
tail(a.dt, 2L)
@

\subsection{Spectral data assumptions}

An assumption of the package is that wavelengths are always expressed in nanometres ($1~\Unit{nm} = 1 \cdot 10^{-9}\,\Unit{m}$). If the data to be analysed uses different units for wavelengths, e.g.\ Angstrom ($1~\Unit{Å} = 1 \cdot 10^{-10}\,\Unit{m$}), the values need to be re-scaled before any calculations.

Energy irradiances are assumed to be expressed in \watt and photon irradiances in \mol, that is to say using second as unit for time. This is the default, but it is possible to set the unit for time to day in the case of \texttt{source.spct} objects.

The default time unit used is \emph{second}, but \emph{day} can be used by supplying the argument \texttt{"day"}
to a parameter of the constructor of \texttt{source.spct} objects.

\begin{framed}
\noindent
Not respecting these assumptions will yield completely wrong results! It is extremely important to make sure that the wavelengths are in nanometres as this is what all functions expect. If wavelength values are in the wrong units, the action-spectra weights and quantum conversions will be wrongly calculated, and the values returned by most functions completely wrong, without warning.
\end{framed}

If spectral irradiance data is in \wattnm, and the wavelength in nm, as is the case for many
Macam spectroradiometers, the data can be used directly and functions in the package will return irradiances in \watt.

If, for example, the spectral irradiance data output by a spectroradiometer is expressed in \mwattnm,
and the wavelengths are in Ångstrom then to obtain correct results when using any of the packages in the suite, we
need to rescale the data.

<<example-1, eval=FALSE>>=
# not run
energy_irradiance(wavelength/10, irrad/1000)
@

In the example above, we take advantage of the behavior of the S language: an operation between a scalar
and vector, is equivalent to applying this operation to each member of the vector.
Consequently, in the code above, each value from the vector of wavelengths is divided
by 10, and each value in the vector of spectral irradiances is divided by 1000.

\subsection{Spectral objects}

There are basically three different approaches to the creation of spectra. The first approach consist in setting the class attribute of an existing data frame or data table, in simple terms, converting an existing object into a spectral object. This approach avoids creating a copy of the data, and should be fastest. The second approach is to use an 'as' function to create a new spectral object from a data frame or data table (the original object remains unchanged, and independent of the spectral object). The third approach is to use a function with the same name as the spectrum object class, and supply the data as numeric vector arguments. With the first two approaches the variables should be suitably named so that they can be recognized, in the third approach the parameter to which the argument vector is supplied determines how it is interpreted.

\subsubsection{Querying the class of a spectrum object}

Consistently with R design, the package provides `is' functions for querying the type of spectra objects.

<<>>=
is.source.spct(sun.spct)
is.filter.spct(sun.spct)
is.any.spct(sun.spct)
@

In addition function \texttt{class.spc} returns directly the spectrum-related class attributes.

<<>>=
class.spct(sun.spct)
class.spct(1:10)
@

The built-in R function \texttt{class} returns all class attributes of an R object.

<<>>=
class(sun.spct)
class(1:10)
@

\subsubsection{Special attributes}

\texttt{source.spct} objects have a \texttt{time.unit} attribute which can take one of two values \texttt{"second"} or \texttt{"day"}, the default is \texttt{"second"}. However, if the spectral data is for daily exposure, then the attribute should be set when the object is constructed. It is also possible to set the attribute for an existing object with function \texttt{setTimeUnit}.

\texttt{filter.spct} objects have a \texttt{Tfr.type} attribute which can take one of two values \texttt{"total"} or \texttt{"internal"}, the default being \texttt{"total"}. However, if the spectral transmittance or absorbance data is internal, meaning excluding the contribution of reflection, then the attribute should be set when the object is constructed. It is also possible to set the attribute for an existing object with function \texttt{setTfrType}.

\begin{framed}
\noindent
Spectral objects created with earlier versions of this package are missing these attributes. For this reason `summary' and `plot' functions may not work as expected. The objects can be updated by adding the missing attribute using the functions  \texttt{setTimeUnit} and \texttt{setTfrType}.
\end{framed}

\subsubsection{Setting the class of a spectrum object}

\texttt{generic.spct} objects can be created from data tables and data frames simply by setting them as such. However, a column called \texttt{w.length} must be present and contain wavelength values expressed in nm. Functions with names of the form \texttt{is.\_\_\_\_.spct} are defined for all classes of spectra and can take as arguments any R object. In addition function \texttt{is.any.spct} can use to query if an R object inherits from any of the classes of spectra defined in this package. Finally function \texttt{class.spct} works similarly to R's \texttt{class} functions but returns only a vector with only the names of spectra classes. The `set' functions keep unrecognized variables.

With create a data.table object \texttt{a.spct}, and query its class.

<<>>=
a.spct <- data.table(w.length = 300:305, y = rep(1,6))
class(a.spct)
class.spct(a.spct)
is.any.spct(a.spct)
@

We convert \texttt{a.spct} into a \texttt{generic.spct} object, and query its class.

<<>>=
setGenSpct(a.spct)
class(a.spct)
class.spct(a.spct)
is.generic.spct(a.spct)
a.spct
@

\texttt{source.spct} objects can be created from data tables, data frames, and \texttt{generic.spct} simply by setting them as such. However, columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{s.e.irrad} (\wattnm) or \texttt{s.q.irrad} (\molnm) must be present.

<<>>=
b.spct <- setSourceSpct(data.table(w.length = 300:305, s.e.irrad = rep(1,6)))
attr(b.spct, "time.unit")
class(b.spct)
b.spct
@

If the spectral irradiance is expressed per day, then the parameter \texttt{time.unit} should be set to \texttt{"day"} instead of the default of \texttt{"second"}. This information is used when printing and plotting source spectra.

<<>>=
b.d.spct <- setSourceSpct(
  data.table(w.length = 300:305, s.e.irrad = rep(1,6)),
  time.unit="day")
attr(b.d.spct, "time.unit")
class(b.d.spct)
b.d.spct
@

\texttt{filter.spct} objects can be created from data tables, data frames, and \texttt{generic.spct} simply by setting them as such. However, columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{Tpc} (T\%), \texttt{Tfr} (T as fraction of 1) and\textbackslash or \texttt{A} (absorbance ($\log_{10}$ based)) must be present.

<<>>=
c.spct <- setFilterSpct(data.table(w.length = 300:305, Tfr = rep(1,6)))
attr(c.spct, "Tfr.type")
class(c.spct)
c.spct
@

If the spectral transmittance or absorbance is the internal component, then the parameter \texttt{Tfr.type} should be set to \texttt{"internal"} instead of the default of \texttt{"total"}. This information is used when printing and plotting source spectra.

<<>>=
c.i.spct <- setFilterSpct(data.table(w.length = 300:305, Tfr = rep(1,6)), "internal")
attr(c.i.spct, "Tfr.type")
class(c.i.spct)
c.i.spct
@

\texttt{reflector.spct} objects can be created from data tables, data frames, and \texttt{generic.spct} simply by setting them as such. However, columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{Rpc} (R\%), and\textbackslash or \texttt{Rfr} (R as fraction of 1) must be present.

<<>>=
d.spct <- setReflectorSpct(data.table(w.length = 300:305, Rfr = rep(1,6)))
class(d.spct)
d.spct
@

\texttt{chroma.spct} objects can be created from data tables, data frames, and \texttt{generic.spct} simply by setting them as such. However, columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{x}, \texttt{y} and \texttt{z} must be present, giving the trichromic chromaticity constants.

<<>>=
e.spct <- setChromaSpct(data.table(w.length = 300:305, x = rep(1,6),
                                   y = rep(1,6), z = rep(1,6)))
class(e.spct)
e.spct
@

In all cases if the expected data is not available, then it is filled-in if possible with values.

<<>>=
f.spct <- setReflectorSpct(data.table(w.length = 300:305, Rpc = rep(100,6)))
class(f.spct)
f.spct
@

When required data is not available, and it cannot be calculated from other columns, the required column is added and filled with \texttt{NA}s.
<<>>=
g.spct <- setReflectorSpct(data.table(w.length = 300:305, z = rep(1,6)))
class(g.spct)
g.spct
@

If no \texttt{w.length} column is present, and a \texttt{wl} column is found, it is renamed to \texttt{w.length}.

<<>>=
h.spct <- setReflectorSpct(data.table(wl = 300:305, Rfr = rep(1,6)))
class(h.spct)
h.spct
@

Here we just use the example data supplied with the package.

<<>>=
class(sun.spct)
sun.spct
@

We can set a spectrum object to a different type of spectrum, but as above this can result in NAs in case of missing data. We need to make a copy of \texttt{sun.spct}, because being part of the package, it is protected and should no be modified by user code.

<<>>=
i.spct <- copy(sun.spct)
setGenericSpct(i.spct)
class(i.spct)
@


\subsubsection{Using `as' functions}

We here very briefly describe theses functions, as what has been discussed above for the `set' applies to these functions, as they simply make a copy of their argument before calling the set functions, and then return this new object.

We can make a `generic.spct' copy of any spectrum object.

<<>>=
j.spct <- as.generic.spct(sun.spct)
class(j.spct)
class(sun.spct)
@

Or of a data frame.
<<>>=
k.df <- data.frame(wl = 400:4010, anything = 1)
k.spct <- as.generic.spct(k.df)
class(k.spct)
class(k.df)
@

Both \texttt{as.source.spct} and \texttt{as.filter.spct} accept an argument for setting the \texttt{time.unit} and \texttt{Tfr.type} attributes, respectively, with the same defaults as described above.

\subsubsection{Using constructors}

This approach is similar to using function \texttt{data.frame} to create a data frame, but in this case the names of the arguments are meaningful.

<<>>=
s.spct <- source.spct(w.length = 300:305, s.e.irrad = 100) # '100' is recycled
class.spct(s.spct)
s.spct
@

<<>>=
s.spct <- source.spct(w.length = 300:305, s.q.irrad = 40, time.unit = "day") # '40' is recycled
class.spct(s.spct)
s.spct
@

<<>>=
l.spct <- filter.spct(w.length = 300:305, Tpc = 100) # '100' is recycled
class.spct(l.spct)
l.spct
@

<<>>=
l.spct <- filter.spct(w.length = 300:305, A = 2) # '2' is recycled
class.spct(l.spct)
l.spct
@

<<>>=
wl1 <- 300:305
m.spct <- reflector.spct(w.length = wl1, Rfr = 0.5) # '0.5' is recycled
class.spct(m.spct)
m.spct
@

<<>>=
l.spct <- response.spct(w.length = 300:305, s.e.response = 0.5) # '0.5' is recycled
class.spct(l.spct)
l.spct
@

Both \texttt{source.spct} and \texttt{filter.spct} functions accept an argument for setting the \texttt{time.unit} and \texttt{Tfr.type} attributes, respectively, with the same defaults as described above.

\subsection{Conversions between radiation units}

The functions \texttt{e2q} and \texttt{q2e} can be used on source spectra to convert spectral energy irradiance into spectral photon irradiance and vice versa. The first argument should be a spectrum, and the second optional argument sets the action with \texttt{"add"} and \texttt{"replace"} as possible values. In the second case the whole spectrum object is copied, while in the first case a column is added but the unchanged columns are references to the original ones, rather than copies.

<<>>=
b.spct
b1.spct <- e2q(b.spct, "replace")
b.spct
b1.spct

b2.spct <- e2q(b.spct, "add")
b.spct
b2.spct
@

For \texttt{filter.spct} objects functions \texttt{T2A} and \texttt{A2T} allow conversion between spectral transmittance and spectral absorbance and vice versa.

\subsection{Remapping a spectrum to different wavelengths}

Converting spectra available at a given set of wavelengths values to a different one, is frequently needed when operating with several spectra of different origin. One can increase the \emph{apparent} resolution by interpolation, and reduce it by local averaging or smoothing and resampling. The same function works on all \texttt{spct} objects, interpolating every column except \texttt{w.length} and replacing in this last column the old wavelength values with the new ones supplied as argument. The optional argument \texttt{fill.value} control what value is assigned to wavelengths in the new data that are outside the range of the old wavelengths.

<<>>=
interpolate_spct(sun.spct, seq(400, 500, by=0.1))
@

\subsection{Trimming spectral objects}\label{sec:trim:spct}

Sometimes it is desirable to change the range of wavelengths included in a spectrum. If we are interested in a given part of the spectrum, there is no need to do calculations or plotting the whole spectrum. Sometimes we may want to expand the range of wavelengths, filling the expansion of all other variables with a certain value (i.e.\ a number, or NA.)

We can supply the arguments \texttt{band}, \texttt{low.limit}, \texttt{high.limit}, and \texttt{fill}. Either \texttt{band} or \texttt{xxx.limit} arguments should supplied, but not both at once. We use \texttt{head} to print the first six lines.

<<>>=
head(trim_spct(sun.spct, PAR()))
@


<<>>=
head(trim_spct(sun.spct, low.limit=297))
@

By default \code{trim\_spct} trims its argument by copy, this can be changed by setting \code{byref=TRUE} but as \code{sun.spct} is protected as part of the package, we cannot use it here.

<<>>=
my_sun.spct <- copy(sun.spct)
head(trim_spct(my_sun.spct, low.limit=297, byref=TRUE))
@

The default \texttt{fill} value is \texttt{NULL} which means deleting the values outside the trimmed region. It is possible to supply a different argument.

<<>>=
head(trim_spct(sun.spct, low.limit=297, fill=0))
@

<<>>=
head(trim_spct(sun.spct, low.limit=297, fill=NA))
@

In addition, when fill is not \texttt{NULL}, expansion is possible.

<<>>=
head(trim_spct(sun.spct, low.limit=290, fill=0))
@

\subsection{Summaries}

Functions \texttt{integrate\_spct} and \texttt{average\_spct} take into account each individual wavelength step, so they return valid results even for spectra measured at arbitrary and varying wavelength steps.

<<>>=
integrate_spct(sun.spct)
average_spct(sun.spct)
@

The `usual' and a couple of new functions are available for spectra, but redefined to return wavelengths.

<<>>=
range(sun.spct)
min(sun.spct)
max(sun.spct)
midpoint(sun.spct)
spread(sun.spct)
stepsize(sun.spct)
@

Function \texttt{stepsize} computes the size of every single step in the spectrum, and returns the range of these values. In the example above for a simulated spectrum the step size is uniform, but in data from array spectrometers this is not the norm.

<<>>=
stepsize(sun_May_morning.spct)
@

Specialized definitions of \texttt{summary} and the corresponding \texttt{print} methods are available for spectral objects. In the case of \texttt{source.spct} objects the \texttt{time.unit} attribute makes it possible to print the summary using the correct units.

<<>>=
summary(sun.spct)
@

<<>>=
summary(sun.daily.spct)
@

\subsection{Defining wavebands}

All functions use \texttt{waveband}s as definitions of the range of wave lengths and the spectral weighting function (SWF) to use in the calculations. A few other bits of information may be included to fine-tune calculations. The waveband definitions do NOT describe whether input spectral irradiances are photon or energy based, nor whether the output irradiance will be based on photon or energy units. Waveband objects belong to the S3 class "waveband".

When defining a waveband which uses a SWF, a function can be supplied either based on energy effectiveness, on photon effectiveness, or one function for each one. If only one function is supplied the other one is built automatically, but if performance is a concern it is better to provide two separate functions. Another case when you might want to enter the same function twice, is if you are using an absorptance spectrum as SWF, as the percent of radiation absorbed will be independent of whether photon or energy units are used for the spectral irradiance.

Two different functions can be used to create a waveband: \texttt{waveband} and \texttt{new\_waveband}.

The difference is that \texttt{waveband} accepts the limits through a single argument, which can be any R object for which there is a suitable \texttt{range} function, which returns the range of wavelengths as a numeric vector of length 2.

<<example-waveband-01, eval=TRUE>>=
my_PAR <- new_waveband(400, 700)
my_PARx <- new_waveband(400, 700, wb.name="my_PARx")

my_CIE_1 <-
  new_waveband(250, 400, weight="SWF", SWF.e.fun=CIE.e.fun, SWF.norm=298)
my_CIE_2 <-
  new_waveband(250, 400, weight="SWF", SWF.q.fun=CIE.q.fun, SWF.norm=298)
my_CIE_3 <-
  new_waveband(250, 400, weight="SWF", SWF.e.fun=CIE.e.fun,
                         SWF.q.fun=CIE.q.fun, SWF.norm=298)
@

The first example above, can be also written as, and in the same way all other statements above can be rewritten, replacing the two separate limits with an array of length 2:

<<>>=
my_PAR <- waveband(c(400, 700))
@

The function \texttt{waveband} is useful when wanting to create a waveband covering the whole range of an spectrum, on when creating an unweighted waveband which covers exactly the same range of wavelengths as an existing weighted waveband.

<<>>=
waveband(sun.spct)
waveband(my_CIE_1)
@

The function \texttt{split\_bands} can be used to generate lists of unweighted wavebands in two different ways: a) it can be used to split a range of wavelengths given by an R object into a series of adjacent wavebands, or b) with a list of objects returning ranges, it can be used to create non-adjacent and even overlapping wavebands.

The code chunk bellow shows an example of two variations of case a). With the default value for \texttt{length.out} of \texttt{NULL} each numerical value in the input is taken as a wavelength (nm) at the boundary between adjacent wavebands. If a numerical value is supplied to \texttt{length.out}, then the whole wavelength range of the input is split into this number of equally spaced adjacent wavebands.

<<>>=
split_bands(c(200, 225, 300))
split_bands(c(200, 225, 300), length.out = 2)
@

In both examples above, the output is a list of two wavebands, but the boundary is at a different wavelength. The chunck bellow gives a few more examples of the use of case a).

<<>>=
split_bands(sun.spct, length.out = 2)
split_bands(PAR(), length.out = 2)
split_bands(c(200, 800), length.out = 3)
# we use head show the first two out of 100 wavebands
head(split_bands(c(200, 800), length.out = 100), 2)
@

Now we demonstrate case b). This is handles by recursion, so each list element can be anything that is a valid input to the function, including a nested list. However, the returned value is always a flat list of wavebands.

<<>>=
split_bands(list(A=c(200, 300), B=c(400, 500), C=c(250, 350)))
split_bands(list(c(100, 150, 200), c(800, 825)))
@

In case b) if we supply a numeric value to \texttt{length.out}, this value is used recursively for each element of the list.

<<>>=
split_bands(list(R=Red(), B=Blue()), length.out = 2)
split_bands(list(c(100, 150, 200), c(800, 825)), length.out = 1)
@

The function \texttt{is.waveband} can the used to query any R object.

<<>>=
is.waveband(my_CIE_1)
is.waveband(PAR())
is.waveband(sun.spct)
@

The function \texttt{is.effective} can the used to query any R object.

<<>>=
is.effective(my_CIE_1)
is.effective(GEN.G())
is.effective(PAR())
is.effective(sun.spct)
@

\subsection{Using operators with spectra}

The basic math operators have definitions for spectra. It is possible to sum, subtract, multiply and divide spectra. These operators can be used even if the spectral data is on different arbitrary sets of wavelengths. Operators by default use values expressed in energy units. Only certain operations are meaningful for a given combination of
objects belonging to different classes, and meaningless combinations return \texttt{NA}. At the moment, without issuing a warning. By default operations are carried out on spectral energy irradiance for \texttt{source.spct} objects and transmittance for \texttt{filter.spct} onbjects.

<<>>=
sun.spct * sun.spct
sun.spct / sun.spct
sun.spct + sun.spct
sun.spct - sun.spct
@

When meaningful operations between different spectra are also allowed. For example, it is possible to simulate the effect of a filter on a light source by multiplying (or convoluting) the two spectra.

<<>>=
sun.spct * polyester.new.spct
@

If we have two layers of the filter, this can be approximated using either of these two statements.

<<>>=
sun.spct * polyester.new.spct * polyester.new.spct
sun.spct * polyester.new.spct^2
@

Operators are also defined for operations between a spectrum and a numeric vector (with normal recycling).

<<>>=
sun.spct * 2
2 * sun.spct
sun.spct * c(0,1)
@

There is one special case, for \texttt{chroma.spct}: if the numeric operand has length three, containing three \emph{named} values `x', `y' and `z', the corresponding value is used for each of the chromaticity `columns' in the \texttt{chroma.spct}. Un-named values or differently named values are not treated specially.

Operators are also defined for operations between an spectrum and a \texttt{waveband} object.

<<>>=
sun.spct * UVB()
sun.spct * CIE()
@

And of course these operations can be combined into more complex statements, including parentheses, when needed. The example below estimates the difference in effective spectral irradiance according to the CIE98 deffinition, between sunlight and sunlight filtered with a polyester film. Of course, the result is valid only for the
solar spectral data used, which corresponds to Southern Finland.

<<>>=
sun.spct * CIE() - sun.spct * polyester.new.spct * CIE()
@

The behaviour of the operators depends on the value of two global options. If we would like the operators to
operate on spectral photon irradiance and return spectral photon irradiance instead of spectral energy irradiance,
this behaviour can be set, and will remain active until unset or reset.

<<>>=
options(photobiology.radiation.unit = "photon")
sun.spct * UVB()
options(photobiology.radiation.unit = "energy")
sun.spct * UVB()
@

For filters, an option controls whether transmittance, the default, or absorbance is use in the operations, and returned.

<<>>=
options(photobiology.filter.qty = "absorbance")
polyester.new.spct*2
options(photobiology.filter.qty = "transmittance")
polyester.new.spct^2
@

Either option can be unset, by means of the \texttt{NULL} value.
<<>>=
options(photobiology.radiation.unit = NULL)
options(photobiology.filter.qty = NULL)
@

\subsection{Calculating irradiance or exposure}

The package includes two `families' of functions, one taking as argument spectrum objects and another taking numeric vectors as arguments. We prefer in general the first `family'.

In each `family' there is one basic function for these calculations \texttt{irradiance()} or \texttt{irrad}, and specialized functions for `photon' and `energy' based calculations.

\subsubsection{Irradiances from spectra}

The code using \texttt{spct} objects is simple, to integrate the whole spectrum we can use

<<>>=
irrad(sun.spct)
@

and, to integrate a range of wavelength, in the example, photosynthetically active radiation, we use \texttt{PAR()} that is a predefined waveband constructor.

<<>>=
irrad(sun.spct, PAR(), unit.out = "energy") # W m-2
irrad(sun.spct, PAR(), unit.out = "photon") # mol s-1 m-2
irrad(sun.spct, PAR(), unit.out = "photon") * 1e6 # umol s-1 m-2
@

The default for \texttt{irrad}, when no argument \texttt{unit.out} is supplied, is to return the irradiance value in energy irradiance units, unless the R \texttt{photobiology.radiation.unit} option is set.

<<>>=
irrad(sun.spct, PAR()) # W m-2
options(photobiology.radiation.unit = "photon")
irrad(sun.spct, PAR()) # mol s-1 m-2
options(photobiology.radiation.unit = NULL)
@

\sloppy
Functions \texttt{e\_irrad} and \texttt{q\_irrad} save some typing, and always return the same type of spectral irradiance quantity, independently of global option \texttt{photobiology.radiation.unit}.

<<>>=
e_irrad(sun.spct, PAR()) # W m-2
q_irrad(sun.spct, PAR()) * 1e6 # umol s-1 m-2
q_irrad(sun.daily.spct, PAR()) # mol d-1 m-2
@

We can use predefined waveband constructors, waveband objects, or define wavebands on the fly.

<<>>=
my_par <- PAR()
e_irrad(sun.spct, my_par) # W m-2
e_irrad(sun.spct, waveband(c(400,700))) # W m-2
@

Lists of wavebands are also accepted as argument.

<<>>=
e_irrad(sun.spct, list(CIE(), CIE(298), CIE(300)))
my_wavebands <- list(Red(), Blue(), Green())
e_irrad(sun.spct, my_wavebands)
@

These functions have an additional argument \texttt{quantity}, with default \texttt{"total"}, which can take values controlling the output.

<<>>=
irrad(sun.spct, UV_bands())
irrad(sun.spct, UV_bands(), quantity="total")
irrad(sun.spct, UV_bands(), quantity="contribution")
irrad(sun.spct, UV_bands(), quantity="contribution.pc")
irrad(sun.spct, UV_bands(), quantity="relative")
irrad(sun.spct, UV_bands(), quantity="relative.pc")
irrad(sun.spct, UV_bands(), quantity="average")
@

\subsubsection{Irradiances from numeric vectors}

The code using numeric vectors is more complicated, but adds some additional flexibility. Under normal circumstances it is easier to use the functions described above.

Function \texttt{irradiance} takes an array of wavelengths (sorted in strictly increasing order), and the corresponding values of spectral irradiance. By default the input is assumed to be in energy units, but parameter \texttt{unit.in} cab be used to adjust the calculations to expect photon units. The type of unit used for the calculated irradiance (or exposure) is set by the parameter \texttt{unit.out} with no default. If no \texttt{w.band} parameter is supplied, the whole spectrum spectrum input is used, unweighted, to calculate the total irradiance. If a \texttt{w.band} is supplied, then the range of wavelengths specified and SWF if present are used for calculating the irradiance. If the waveband definition does not include a SWF, then the unweighted irradiance is returned, if the definition includes a SWF, then a weighted irradiance is returned.

The functions \texttt{photon\_irradiance()} and \texttt{energy\_irradiance()}, just call \texttt{irradiance()} with the \texttt{unit.out} set to \texttt{"photon"} or \texttt{"energy"} respectively.

The functions taking numerical vectors as arguments can be used with data stored as vectors, or using \texttt{with} with data frames, data tables, lists, and spectra objects.

<<>>=
with(sun.data, photon_irradiance(w.length, s.e.irrad, PAR()))
with(sun.spct, photon_irradiance(w.length, s.e.irrad, PAR()))
@

Lists of wavebands are also accepted as argument.

<<>>=
with(sun.data, energy_irradiance(w.length, s.e.irrad, list(CIE(), CIE(298), CIE(300))))
my_wavebands <- list(Red(), Blue(), Green())
with(sun.data, energy_irradiance(w.length, s.e.irrad, my_wavebands))
@

The recommended practice is to use \texttt{with}, as above.

\sloppy
The are also available convenience functions for calculating how `total' irradiance is split among different contiguous bands
of the spectrum. The functions \texttt{split\_photon\_irradiance()} and \texttt{split\_energy\_irradiance()}, just call \texttt{split\_irradiance()} with the \texttt{unit.out} set to \texttt{"photon"} or \texttt{"energy"} respectively.

<<>>=
with(sun.data,
     split_energy_irradiance(w.length, s.e.irrad,
                             c(300, 400, 500, 600, 700, 800))
)
with(sun.data,
     split_energy_irradiance(w.length, s.e.irrad,
                             c(400, 500, 600, 700),
                             scale="percent")
)
with(sun.data,
     split_photon_irradiance(w.length, s.e.irrad,
                             c(400, 500, 600, 700),
                             scale="percent")
)
@


\subsection{Calculating ratios}

The package includes two `families' of functions, one taking as argument spectrum objects and another taking numeric vectors as arguments. We prefer in general the first `family'.

In each `family' there is one basic function for these calculations \texttt{waveband\_ratio()} or \texttt{ratio}, and specialized functions for `photon' and `energy' based calculations.

\subsubsection{Ratios from spectra}

The functions described here, in there simplest use, calculate a ratio between two wavebands. The function \texttt{q\_ratio} returning photon ratios. However both waveband parameters can take lists of wavebands as arguments, with normal recycling rules in effect.

<<>>=
q_ratio(sun.spct, UVB(), PAR())
q_ratio(sun.spct,
        list(UVC(), UVB(), UVA()),
        UV())
q_ratio(sun.spct,
        UVB(),
        list(UV(), PAR()))
@

Function \texttt{e\_ratio} returns energy ratios.

<<>>=
e_ratio(sun.spct, UVB(), PAR())
e_ratio(sun.spct,
        list(UVC(), UVB(), UVA()),
        UV())
@

Function \texttt{qe\_ratio}, has only one waveband parameter, and returns the `photon' to `energy' ratio,

<<>>=
qe_ratio(sun.spct, PAR())
qe_ratio(sun.spct, list(Blue(), Green(), Red()))
@

Function \texttt{eq\_ratio}, has only one waveband parameter, and returns the`energy' to `photon' ratio,

<<>>=
eq_ratio(sun.spct, PAR())
eq_ratio(sun.spct, list(Blue(), Green(), Red()))
@

If we would like to calculate a conversion factor between PPFD (PAR photon irradiance in mol s-1 m-2) and PAR (energy) irradiance (W m-2) for a light source for which we have spectral data we could use the following code.

<<example-ratios-02>>=
conv.factor <- qe_ratio(sun.spct, PAR())

PPFD.mol.photon <- 1000e-6
PAR.energy <- PPFD.mol.photon / conv.factor
conv.factor
PPFD.mol.photon * 1e6
PAR.energy
@

\subsubsection{Ratios from vectors}

The function \texttt{waveband\_ratio()} takes basically the same parameters as \texttt{irradiance}, but two waveband definitions instead of one, and two \texttt{unit.out} definitions instead of one. This is the base function used in all the vector based `ratio' functions in the \PB package.

\sloppy
The derived functions are: \texttt{photon\_ratio()}, \texttt{energy\_ratio()}, and \texttt{photons\_energy\_ratio}. The packages \PBVIS and \PBUV use these to define some convenience functions, and here we give and example for a function not yet implemented, but which you may find as a useful example.

In contrast to the functions described in the previous section, these functions only accept individual waveband definitions (not lists of them).

If for example we would like to calculate the ratio between UVB and PAR radiation, we would use either
of the following function calls, depending on which type of units we desire.

<<example-ratios-01>>=
with(sun.data,
     photon_ratio(w.length, s.e.irrad, UVB(), PAR())
)
with(sun.data,
     energy_ratio(w.length, s.e.irrad, UVB(), PAR())
)
@

\subsection{Calculating average transmittance, absorbance and reflectance}

The functions \texttt{transmittance}, \texttt{absorbance} and \texttt{reflectance} take filter.spct and reflector.spct objects as arguments, and return an average value for these quantities \textbf{assuming} a light source with a flat spectral energy output. Values expressed as percentages.

<<>>=
transmittance(polyester.new.spct, list(UVB(), UVA(), PAR()))
transmittance(polyester.new.spct, list(UVB(), UVA(), PAR()), pc.out=TRUE)
@

This function has an additional argument \texttt{quantity}, with default \texttt{"average"}, which can take values controlling the output.

<<>>=
transmittance(polyester.new.spct, UV_bands())
transmittance(polyester.new.spct, UV_bands(), quantity="total")
transmittance(polyester.new.spct, UV_bands(), quantity="contribution")
transmittance(polyester.new.spct, UV_bands(), quantity="contribution.pc")
transmittance(polyester.new.spct, UV_bands(), quantity="relative")
transmittance(polyester.new.spct, UV_bands(), quantity="relative.pc")
transmittance(polyester.new.spct, UV_bands(), quantity="average")
@

An equivalent function returning absorbance instead of transmittance takes the same arguments as \texttt{transmittance}, except for \texttt{pc.out} which is not useful for absorbance.

<<>>=
absorbance(polyester.new.spct, list(UVB(), UVA(), PAR()))
@

This function has an additional argument \texttt{quantity}, with default \texttt{"average"}, which can take values controlling the output.

<<>>=
transmittance(polyester.new.spct, UV_bands())
transmittance(polyester.new.spct, UV_bands(), quantity="total")
transmittance(polyester.new.spct, UV_bands(), quantity="contribution")
transmittance(polyester.new.spct, UV_bands(), quantity="contribution.pc")
transmittance(polyester.new.spct, UV_bands(), quantity="relative")
transmittance(polyester.new.spct, UV_bands(), quantity="relative.pc")
transmittance(polyester.new.spct, UV_bands(), quantity="average")
@

It is more likely that we would like to calculate these values with reference to light of a certain spectral quality. This needs to be calculated by hand, which is not difficult. For example, for UV-B, which we can
calculate, either by trimming the waveband as shown here, or by extending the sun spectrum with zeros.

<<>>=
tr.UVB <- trim_waveband(UVB(), sun.spct, trim=TRUE)
irrad(sun.spct * polyester.new.spct, tr.UVB) /
                            irrad(sun.spct, tr.UVB) * 100
@

And for a list of wavebands, as percentages.

<<>>=
irrad(sun.spct * polyester.new.spct, list(UVB(), UVA(), PAR()), wb.trim=TRUE) /
  irrad(sun.spct, list(UVB(), UVA(), PAR()), wb.trim=TRUE) * 100
@

\subsection{Calculating integrated response}

The functions  \texttt{response}, \texttt{e\_response} and \texttt{q\_response} take response.spct objects as arguments, and return the integrated value for each waveband (integrated over wavelength) \textbf{assuming} a light source with a flat spectral energy or photon output respectively.

If no waveband is supplied as argument, the whole spectrum is integrated.

<<>>=
response(Vital_BW_20.spct)
e_response(Vital_BW_20.spct)
@

<<>>=
q_response(Vital_BW_20.spct) * 1e-6
@

When a waveband, or list of wavebands, is supplied the response is calculated for the wavebands.

<<>>=
e_response(Vital_BW_20.spct, UVB())
q_response(Vital_BW_20.spct, UVB()) * 1e-6
@

<<>>=
e_response(Vital_BW_20.spct, list(UVB(), UVA()))
@

This function has an additional argument \texttt{quantity}, with default \texttt{"total"}, which can take values controlling the output.

<<>>=
response(Vital_BW_20.spct, UV_bands())
response(Vital_BW_20.spct, UV_bands(), quantity="total")
response(Vital_BW_20.spct, UV_bands(), quantity="contribution")
response(Vital_BW_20.spct, UV_bands(), quantity="contribution.pc")
response(Vital_BW_20.spct, UV_bands(), quantity="relative")
response(Vital_BW_20.spct, UV_bands(), quantity="relative.pc")
response(Vital_BW_20.spct, UV_bands(), quantity="average")
@

If we would like to calculate these values with reference to light of a certain spectral irradiance. This can be achieved by multiplying the sensor's spectral responsivity by the light source spectral irradiance.

<<>>=
e_response(sun.spct * Vital_BW_20.spct, UVB())
q_response(sun.spct * Vital_BW_20.spct, UVB()) * 1e-6
@

And for a list of wavebands

<<>>=
q_response(sun.spct * KIPP_PQS1_PAR_quantum.spct, list(UVA(), PAR())) * 1e-6
@

\subsection{Integrating a generic spectrum}

In some cases we may want to integrate the values of arbitrary columns other than \texttt{w.length} in an spectral object. All spectral classes are derived from \texttt{generic.spct}, so the examples in this section apply to objects of any of the `child' spectral classes as well.

<<>>=
integrate_spct(sun.spct)
integrate_spct(sun.spct * UVA())
e_irrad(sun.spct, UVA())
@

The function \texttt{integrate\_spct} integrates every column holding numeric values from a spectrum object, except for \texttt{w.length}.

<<>>=
my.sun.spct <- copy(sun.spct)
my.sun.spct[ , one := 1L]
integrate_spct(my.sun.spct)
spread(sun.spct)
@

In the simple example above, the integral of \texttt{one} gives us the span in nanometres of the spectrum.
\subsection{Tagging observations in a spectrum}

The function \texttt{tag} can be used to tag different parts of a spectrum according to wavebands.

<<>>=
tag(sun.spct, PAR(), byref=FALSE)
tag(sun.spct, UV_bands(), byref=FALSE)
@

The added factor and colour data can be used for further processing or for plotting. Information about the tagging and wavebands is stored in an attribute \code{tag.attr} in every tagged spectrum, this yields a more compact output and keeps a `trace' of the tagging.

<<>>=
tg.sun.spct <- tag(sun.spct, PAR(), byref=FALSE)
attr(tg.sun.spct, "spct.tags")
@

Additional functions are available which return a tagged spectrum and take as input a list of wavebands, but no spectral data. They `build' an spectrum from the data in the wavebands, and are useful for plotting the boundaries of wavebands.

<<>>=
wb2tagged_spct(UV_bands())
wb2rect_spct(UV_bands())
@

Function \code{wb2tagged\_spct} returns a tagged spectrum, with two rows for each waveband, corresponding to the low and high wavelength boundaries, while function \code{wb2rect\_spct} returns a spectrum with only one row per waveband, with \code{w.length} set to its midpoint but with additional columns  \code{xmin} and \code{xmax} corresponding to the low and high wavelength boundaries of the wavebands.

Function \code{is.tagged} can be used to query if an spectrum is tagged or not, and function \code{untag} removes the tags.

<<>>=
tg.sun.spct
is.tagged(tg.sun.spct)
untag(tg.sun.spct)
is.tagged(tg.sun.spct)
@

In the chuck above, we can see how this works, using in this case the default \code{byref=TRUE} which adds the tags in place, or ``by reference'', to the spct object supplied as argument.

In the chunk bellow, we demonstrate that if an already tagged spectrum is re-tagged, the old tags are replaced with new ones, with a warning.

<<>>=
tag(tg.sun.spct, PAR())
tag(tg.sun.spct, VIS())
@

\subsection{Calculating weighted spectral irradiances}

This calculation is not very frequently used, but it is very instructive to look at spectral data in this way, as it can make apparent the large effect that small measuring errors can have on the estimated effective irradiances or exposures.

\subsubsection{Weighted spectral irradiance from spectrum objects}

The multiplication operator is defined for operations between a \texttt{source.spct} and a \texttt{waveband}, so this is the easiest way of doing the calculations.

<<>>=
sun.CIE.spct <- sun.spct * CIE()
sun.CIE.spct
@

We here plot, using \texttt{ggplot2}, weighted (in red) and unweighted irradiances using simulated solar spectral irradiance data stored as a source.spct object, and applying the BSWF weights on the fly.

<<>>=
ggplot(data=sun.spct, aes(x=w.length, y=s.e.irrad/max(s.e.irrad))) +
  geom_line() +
  geom_line(data=sun.spct * CIE(), colour="red",
            aes(y=s.e.response/max(s.e.response))) +
  labs(x="Wavelength (nm)",
       y="UnWeighted and CIE98-weighted spectral irradiance (relative units)")
@

\subsubsection{Weighted spectral irradiance from vectors}

It is also possible to use vectors, and base R plot functions.

<<weighted-spectra-01, tidy=FALSE>>=
weighted.s.e.irrad <-
  with(sun.spct,
       s.e.irrad * calc_multipliers(w.length, CIE())
  )
plot(weighted.s.e.irrad/max(weighted.s.e.irrad) ~ w.length, type="l",
     data=sun.spct,
     col="red",
     xlab="Wavelength (nm)",
     ylab="UnWeighted and CIE98-weighted spectral irradiance (relative units)")
lines(s.e.irrad/max(s.e.irrad) ~ w.length, col="black", data=sun.spct)
@


\section{Astronomical calculations}

\subsection{Position of the sun in the sky}

In photobiology research we sometimes need to calculate the position on the sun at arbitrary locations and positions. The function \texttt{sun\_angles} returns the azimuth in degrees eastwards, altitude in degrees above the horizon, solar disk diameter in degrees and sun to earth distance in astronomical units. The time should be a \texttt{POSIXct} vector, possibly of length one, and it is easiest to use package \texttt{lubridate} for working with time and dates.

<<>>=
sun_angles(now(), lat=34, lon=0)
sun_angles(ymd_hms("2014-01-01 0:0:0", tz="UTC"))
@

\subsection{Calculating times of sunrise and sunset}

<<>>=
day_night()
day_night(ymd("2014-05-30", tz = "UTC"), lat=30, lon=0)
day_night(ymd("2014-05-30", tz = "UTC"), lat=30, lon=0, twilight="civil")
@

\section{Calculating equivalent RGB colours for display}

Two functions allow calculation of simulated colour of light sources as R colour definitions. Three different functions are available, one for monochromatic light taking as argument wavelength values, and one for polychromatic light taking as argument spectral energy irradiances and the corresponding wave length values. The third function can be used to calculate a representative RGB colour for a band of the spectrum represented as a range of wavelength, based on the assumption of a flat energy irradiance across the range.
By default CIE coordinates for \textit{typical} human vision are used, but the functions
have a parameter that can be used for supplying a different chromaticity definition.

Examples for monochromatic light:

<<>>=
w_length2rgb(550) # green
w_length2rgb(630) # red
w_length2rgb(380) # UVA
w_length2rgb(750) # far red
w_length2rgb(c(550, 630, 380, 750)) # vectorized
@


Examples for wavelength ranges:

<<>>=
w_length_range2rgb(c(400,700))
w_length_range2rgb(400:700)
w_length_range2rgb(sun.spct$w.length)
w_length_range2rgb(550)
@

Examples for spectra as vectors, in this case for the solar spectrum:

<<>>=
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens=ciexyzCMF2.spct))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens=ciexyzCMF10.spct))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens=ciexyzCC2.spct))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens=ciexyzCC10.spct))
@

Examples with \texttt{source.spct} objects.

<<>>=
rgb_spct(sun.spct)
rgb_spct(sun.spct, sens=ciexyzCMF2.spct)
@

And also a \texttt{color} method for \texttt{source.spct}.

<<>>=
color(sun.spct)
color(sun.spct * rg630.spct)
@

Here we plot the RGB colours for the range covered by the CIE 2006 proposed standard calculated at each 1 nm step:

<<>>=
wl <- c(390, 829)

my.colors <- w_length2rgb(wl[1]:wl[2])

colCount <- 40 # number per row
rowCount <- trunc(length(my.colors) / colCount)

plot( c(1,colCount), c(0,rowCount), type="n", ylab="", xlab="",
      axes=FALSE, ylim=c(rowCount,0))
title(paste("RGB colours for", as.character(wl[1]),
            "to", as.character(wl[2]), "nm"))

for (j in 0:(rowCount-1))
{
  base <- j*colCount
  remaining <- length(my.colors) - base
  RowSize <- ifelse(remaining < colCount, remaining, colCount)
  rect((1:RowSize)-0.5,j-0.5, (1:RowSize)+0.5,j+0.5,
       border="black",
       col=my.colors[base + (1:RowSize)])
}

@

Given a color in any of the above ways, yields RGB values that can be used to locate the position of any colour on Maxwell's triangle. Here using R's predefined colours.

<<>>=
colours <- c("red", "green", "yellow", "white", "orange",
             "blue", "pink", "purple")
rgb.values <- col2rgb(colours)
test.data <-
  data.frame(colour=colours,
             R=rgb.values[1, ], G=rgb.values[2, ], B=rgb.values[3, ])
maxwell.tern <- ggtern(data=test.data,
                       aes(x=R, y=G, z=B, label=colour, fill=colour)) +
  geom_point(shape=21, size=4) + geom_text(hjust=-0.3) +
  labs(x = "R", y="G", z="B") + scale_fill_identity()
maxwell.tern
@

We simulate the spectra of filtered sunlight by multiplying the solar spectrum by filter transmittance spectra.

<<>>=
yellow.light.spct <- canary.yellow.new.spct * sun.spct
green.light.spct <- moss.green.new.spct * sun.spct
polyester.light.spct <- polyester.new.spct * sun.spct
@

Now using the filtered sunlight spectra we calculate colours based on human vision photoreceptors.

<<>>=
coord <- 1 # CMF
yellow.filter <- color(yellow.light.spct)[coord]
green.filter <- color(green.light.spct)[coord]
polyester.filter <- color(polyester.light.spct)[coord]
colours <- c(yellow.filter, green.filter, polyester.filter)
rgb.values <- col2rgb(colours)
test.data <- data.frame(colour=colours,
                        R=rgb.values[1, ], G=rgb.values[2, ], B=rgb.values[3, ],
                        labels=c("canary yellow", "moss green", "polyester"))
maxwell.tern <- ggtern(data=test.data,
                       aes(x=R, y=G, z=B, fill=colour, label=labels)) +
  geom_point(shape=21, size=4) +
  geom_text(hjust=-0.15) +
  labs(x = "R", y="G", z="B")  +
  scale_fill_identity()
maxwell.tern
@

\section{Auxiliary functions}

To stack spectral objects the function \texttt{rbindspct} should be used instead of \texttt{rbind} or \texttt{rbindlist} from package \texttt{data.table}. The functions from package \texttt{data.table} strip the spectral class attributes from the output, returning always a \texttt{data.table} object.

\begin{framed}
\noindent
In some past versions of the package we had included our own version of \texttt{rbindlist} to override the one defined in package \texttt{data.table}, but this was triggering warnings and causing other problems. Because of this it has been removed.
\end{framed}

Sometimes it is needed to add (parallel sum) between two spectra, even if the two spectra have been
measured at different wavelengths or wavelength steps. This can happen for example when we would like
to calculate the spectrum of a combination of two light sources from the individual spectra.

A function \verb|interpolate_spectrum| is also included to facilitate interpolation of spectral values. It is used internally, but can also be used by itself when interpolation is needed.
Under the hood it uses R's \verb|spline| function if there are fewer than 25 data points, and uses \verb|approx|
otherwise. It allows easier control of values to be used for extrapolation.

\section{Dealing with real `noisy' spectral data}

The first thing to do is to think whether any part of the spectral measurements can be \textit{a priori} known to be equal to zero. For example for the solar spectrum at ground level it is safe to assume that the spectral irradiance is zero for all wavelengths shorter than 293~nm. If the data are noisy, it is best to discard these data before calculating any effective UV doses.

In the following example we use a longer wavelength (297~nm) just to show how the function works, because the example spectral data set starts at 293~nm.

<<example-sun>>=
head(sun.spct, 2L)
@

Sub-setting can be easily done as follows if the data are in a data.frame (of course, replacing \texttt{w.length} with the name used in your data frame for the wavelengths array):

<<example-subset>>=
subsetted.sun.spct <- subset(sun.spct, w.length >= 297)
head(subsetted.sun.spct, 2L)
@

And then just use the sub-setted data in your calculations.

If the data are not in a data frame, then there are different options: 1) create a data frame from your data, 2) use the function \texttt{trim\_tails()} from this package, or 3) just use R commands. Here we give examples of the use of \texttt{trim\_tails()}, using the same data as in earlier examples. First we `trim' (delete) all data for wavelengths shorter than 293~nm.

\subsection{Trimming spectra stored as vectors}

See earlier section \ref{sec:trim:spct} on page \pageref{sec:trim:spct} for details on trimming spectrum objects, which is an easier way of achieving the same results as here.

<<example-trim-low>>=
trimmed.sun.spct <-
  with(sun.spct,
       trim_tails(w.length, s.e.irrad, low.limit=297)
  )
print(trimmed.sun.spct)
class(trimmed.sun.spct)
@

This function returns a new data.frame and uses always the same variable names for the columns.

<<example-trim-both>>=
trimmed.both.sun.spct <-
  with(sun.spct,
       trim_tails(w.length, s.e.irrad, low.limit=297, high.limit=550)
  )
print(trimmed.both.sun.spct)
@

If we supply a different value than the default NULL for the parameter \texttt{fill}, the w.length values are kept, and the trimmed spectral irradiance values replaced by the value supplied.

<<example-trim-na>>=
trimmed.na.sun.spct <-
  with(sun.spct,
       trim_tails(w.length, s.e.irrad, low.limit=297, fill=NA)
  )
print(trimmed.na.sun.spct)
@

<<example-trim-both-na>>=
trimmed.both.na.sun.spct <-
  with(sun.spct,
       trim_tails(w.length, s.e.irrad, low.limit=297, high.limit=400, fill=NA)
  )
print(trimmed.both.na.sun.spct)
@

In addition to NA we can supply an arbitrary numeric value as fill.

<<example-trim-zero>>=
trimmed.zero.sun.spct <-
  with(sun.spct,
       trim_tails(w.length, s.e.irrad, low.limit=297, fill=0.0)
  )
print(trimmed.zero.sun.spct)
@

\section{Optimizing performance}

When developing the current version of \PB quite a lot of effort was spent in optimizing performance, especially of the functions accepting vectors as arguments, as in one of our experiments, we need to process several hundred thousands of measured spectra. The defaults should provide good performance in most cases, however, some further improvements are achievable, when a series of different calculations are done on the same spectrum, or when a series of spectra measured at exactly the same wavelengths are used for calculating weighted irradiances or exposures.

In the case of doing calculations repeatedly on the same spectrum, a small improvement in performance can be achieved by setting the parameter \texttt{check.spectrum=FALSE} for all but the first call to \texttt{irradiance()}, or \texttt{photon\_irradiance()}, or \texttt{energy\_irradiance()}, or the equivalent function for ratios. It is also possible to set this parameter to FALSE in all calls, and do the check beforehand by explicitly calling \texttt{check\_spectrum()}.

In the case of calculating weighted irradiances on many spectra having exactly the same wavelength values, then a significant improvement in the performance can be achieved by setting \texttt{use.cached.mult=TRUE}, as this reuses the multipliers calculated during successive calls based on the same waveband. However, to achieve this increase in performance, the tests to ensure that the wavelength values have not changed, have to be kept to the minimum. Currently only the length of the wavelength array is checked, and the cached values discarded and recalculated if the length changes. For this reason, this is not the default, and when using caching the user is responsible for making sure that the array of wavelengths has not changed between calls.

You can use the package \texttt{microbenchmark} to time the code and find the parts that slow it down. I have used it, and also
I have used profiling to optimize the code for speed. The choice of defaults is based on what is
best when processing a moderate number of spectra, say less than a few hundreds, as opposed to many thousands.

\end{document}
