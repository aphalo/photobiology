%\VignetteEngine{knitr}
%\VignetteIndexEntry{User guide}
%\VignetteDepends{knitr, photobiology, photobiologyWavebands, photobiologySun, photobiologyFilters, photobiologyReflectors, photobiologySensors, photobiologyPlants, photobiologygg, ggplot2, ggtern, lubridate}
%\VignetteKeyword{misc}

\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{bbding}
\usepackage{xspace}
\usepackage{framed}
\usepackage{array}

\newcommand{\PB}{\textsf{photobiology}\xspace}
\newcommand{\PBPla}{\textsf{photobiologyPlants}\xspace}
\newcommand{\PBFLT}{\textsf{photobiologyFilters}\xspace}
\newcommand{\PBSU}{\textsf{photobiologySun}\xspace}
\newcommand{\PBLA}{\textsf{photobiologyLamps}\xspace}
\newcommand{\PBLD}{\textsf{photobiologyLEDs}\xspace}
\newcommand{\PBSN}{\textsf{photobiologySensors}\xspace}
\newcommand{\PBWB}{\textsf{photobiologyWavebands}\xspace}

\newcommand{\UV}{UV\xspace}
\newcommand{\UVB}{UV-B\xspace}
\newcommand{\UVA}{UV-A\xspace}

\newcommand{\Unit}[1]{\ensuremath{\mathrm{#1}}\xspace}

\newcommand{\watt}{\Unit{W\,m^{-2}}}
\newcommand{\wattnm}{\Unit{W\,m^{-2}\,nm^{-1}}}
\newcommand{\mwattnm}{\Unit{mW\,m^{-2}\,nm^{-1}}}
\newcommand{\mol}{\Unit{mol\,m^{-2}\,s^{-1}}}
\newcommand{\molnm}{\Unit{mol\,m^{-2}\,s^{-1}\,nm^{-1}}}

\newcommand{\jday}{\Unit{J\,m^{-2}\,d^{-1}}}
\newcommand{\kjday}{\Unit{kJ\,m^{-2}\,d^{-1}}}
\newcommand{\jdaynm}{\Unit{J\,m^{-2}\,d^{-1}\,nm^{-1}}}
\newcommand{\molday}{\Unit{molday\,m^{-2}\,d^{-1}}}
\newcommand{\moldaynm}{\Unit{mol\,m^{-2}\,d^{-1}\,nm^{-1}}}

\newcommand{\jtot}{\Unit{J\,m^{-2}}}
\newcommand{\kjtot}{\Unit{kJ\,m^{-2}}}
\newcommand{\jtotnm}{\Unit{J\,m^{-2}\,nm^{-1}}}
\newcommand{\moltot}{\Unit{molday\,m^{-2}}}
\newcommand{\moltotnm}{\Unit{mol\,m^{-2}\,nm^{-1}}}

\newcommand{\cps}{\Unit{\mathit{n}\,s^{-1}}}
\newcommand{\qresponse}{\Unit{\mathit{x}\,mol^{-1}\,s^{-1}}}
\newcommand{\eresponse}{\Unit{\mathit{x}\,J^{-1}\,s^{-1}}}
\newcommand{\qresponsenm}{\Unit{\mathit{x}\,mol^{-1}\,s^{-1}\,nm^{-1}}}
\newcommand{\eresponsenm}{\Unit{\mathit{x}\,J^{-1}\,s^{-1}\,nm^{-1}}}

\newcommand{\qresponseday}{\Unit{\mathit{x}\,mol^{-1}\,d^{-1}}}
\newcommand{\eresponseday}{\Unit{\mathit{x}\,J^{-1}\,d^{-1}}}
\newcommand{\qresponsedaynm}{\Unit{\mathit{x}\,mol^{-1}\,d^{-1}\,nm^{-1}}}
\newcommand{\eresponsedaynm}{\Unit{\mathit{x}\,J^{-1}\,d^{-1}\,nm^{-1}}}

\newcommand{\qresponsetot}{\Unit{\mathit{x}\,mol^{-1}}}
\newcommand{\eresponsetoto}{\Unit{\mathit{x}\,J^{-1}}}
\newcommand{\qresponsetotnm}{\Unit{\mathit{x}\,mol^{-1}\,nm^{-1}}}
\newcommand{\eresponsetotnm}{\Unit{\mathit{x}\,J^{-1}\,nm^{-1}}}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(fig.path='figure/pos-', fig.align='center', fig.show='hold',
               fig.width=7, fig.height=6, size="footnotesize")
# options(replace.assign=TRUE,width=60)
@

<<example-0-hiden, eval=TRUE, include=FALSE>>=
library(photobiology)
library(photobiologyWavebands)
library(photobiologySun)
library(photobiologyFilters)
library(photobiologyReflectors)
library(photobiologySensors)
library(photobiologyPlants)
library(lubridate)
@

<<own-set-up, echo=FALSE, include=FALSE>>=
my_version <- packageVersion("photobiology")
@

\title{\PB Version \Sexpr{my_version}\\ User Guide}
\author{Pedro J. Aphalo}

\maketitle

\tableofcontents

\section{Introduction}

\sloppy
We have developed a set of packages to
facilitate the calculation of many different quantities that can be derived from spectral irradiance data. The base package in this suite is called \PB, and is the package described here. There other specialized packages for quantification of ultraviolet radiation and visible radiation (\PBWB), or plant photoreceptors (\PBPla). Other packages in the suite provide example spectral data for filters (\PBFLT), lamps (\PBLA), LEDs (\PBLD), sunlight (\PBSU) and broadband sensors (\PBSN). In the future it will be submitted to CRAN (Comprehensive R archive network), it is meanwhile available from \url{https://www.r4photobiology.info/}. There is also a public Git repository at \url{https://bitbucket.org/aphalo/} from where the source code of the current an earlier versions can be cloned.

Package \PB provides two sets of functions for many operations: functions programmed following a functional paradigm, and functions using an object-oriented paradigm. The former functions take as arguments numeric vectors and are probably faster. The later ones take `spectra' objects as arguments, are easier to use, and at least at the moment, to some extent slower. For everyday use `spectra' objects are recommended, but when maximum performance or flexibility in scripts is desired, the use of the functions taking numeric vectors as arguments may allow optimizations that are not possible with the object-oriented higher level functions.

\section{Installation and use}

The functions in the package \PB are
made available by installing the packages \verb!photobiology! (once) and
loading it from the library when needed.

To load the package into the workspace we use \verb!library(photobiology)!.

<<example-0-visible, eval=FALSE>>=
library(photobiology)
library(photobiologyWavebands)
library(photobiologySun)
library(photobiologyFilters)
library(photobiologyReflectors)
library(photobiologySensors)
library(photobiologyPlants)
@

\section{Spectra}

This package defines a family of classes based on data frames which impose some restrictions on the naming of the vectors, something that allows methods and some functions to `find' the data when passed one of these objects as argument. In addition, as the data is checked when the object is built, there is no need to test for the validity of the data each time a calculation is carried out. The other advantage of using \texttt{spct} objects, is that specialized versions of generic functions like \texttt{print} and operators like \texttt{+} can be defined for spectra. \texttt{\_\_\_spct} objects are \texttt{data.frame} objects, as a result of how classes have been derived. In this package we define a \textit{generic} or \emph{base} spectrum class, derived from \texttt{data.frame}, from which specialized types of spectra are in turn derived. This `parenthood' hierarchy means that spectra objects can be used almost anywhere where a \texttt{data.frame} is expected.

\subsection{Printing}

Spectral objects are printed in the current version of the package by the function defined in package \texttt{dplyr}, consequently, it is possible to the option from this package to control printing. Below texttt{dplyr.print_max}, the number of rows above which only `head' rows are printed, is set to 10, instead of the default 20.

<<set-up-printing>>=
options(dplyr.print_max = 10)
@

The number of rows printed can be also controlled through an explicit argument to the second parameter of \texttt{head}.

\subsection{Classes}

The package defines several classes intended to be used to store different types of spectral data. They are all derived from \texttt{generic\_spct}, which in turn is derived from \texttt{data.frame} and internally created using \texttt{dplyr::data\_frame}. Table \ref{tab:spct:classes} lists them. Attributes are used in objects of these classes to keep \emph{metadata} such as information about units of expression.

\begin{table}
\caption[Classes for spectral data]{Classes for spectral data. In addition to the attributes listed, all spectral objects have attributes \texttt{normalized} and \texttt{scaled}, plus the normal attributes of \texttt{data.frame} objects.}\label{tab:spct:classes}
\centering
\begin{tabular}{lll}
\toprule
Name & Variables & Attributes\\
\midrule
generic\_spct & w.length & \\
cps\_spct & w.length, cps & \\
source\_spct & w.length, s.e.irrad, s.q.irrad & time.unit, bswf \\
filter\_spct & w.length, Tfr, A & Tfr.type \\
reflector\_spct & w.length, Rfr & Rfr.type \\
object\_spct & w.length, Tfr, Rfr & Tfr.type, Rfr.type \\
response\_spct & w.length, s.e.response, s.q.response & time.unit \\
chroma\_spct & w.length, x, y, z & \\
\bottomrule
\end{tabular}
\end{table}

The \emph{design} imposes that data from different observations are never present as different
\emph{data columns}, if present, additional data columns represent different properties from
the same observation event.
In most cases, one spectral object corresponds to one spectral observation, but some functions
are compatible or can be used to create spectral objects where the spectral data from different
observations are stored ``longitudinally'' and ``tagged'' with a factor with a level for each
observation event. These observations must use consistent units of expression
and attribute values.

\subsection{Data assumptions}

An assumption of the package is that wavelengths are always expressed in nanometres ($1~\Unit{nm} = 1 \cdot 10^{-9}\,\Unit{m}$). If the data to be analysed uses different units for wavelengths, e.g.\ Ångstrom ($1~\Unit{Å} = 1 \cdot 10^{-10}\,\Unit{m}$), the values need to be re-scaled before any calculations. Table \ref{tab:spct:units} lists the units of expression for the different variables listed in  Table  \ref{tab:spct:classes}.

\begin{table}
\caption[Variables for spectral data]{Variables used for spectral data and their units of expression: A: as stored in objects of the spectral classes, B: also recognized by the \texttt{set} family of functions for spectra and automatically converted. \texttt{time.unit} accepts in addition to the character strings listed in the table, objects of classes \texttt{lubridate::duration} and \texttt{period}, in addition \texttt{numeric} values are interpreted as seconds. \texttt{exposure.time} accepts these same values, but not the character strings.}\label{tab:spct:units}
\centering
\begin{tabular}{lll}
\toprule
Variables & Unit of expression & Attribute value \\
\midrule
A: stored & & \\
\midrule
w.length & nm &  \\
cps & \cps & \\
s.e.irrad &  \wattnm & time.unit = "second" \\
s.e.irrad &  \jdaynm & time.unit = "day" \\
s.e.irrad &  varies & time.unit = \emph{duration} \\
s.q.irrad &  \molnm & time.unit = "second" \\
s.q.irrad &  \moldaynm & time.unit = "day" \\
s.q.irrad &  \moltotnm & time.unit = "exposure" \\
s.q.irrad &  varies & time.unit = \emph{duration} \\
Tfr & [0,1] &  Tfr.type = "total" \\
Tfr & [0,1] &  Tfr.type = "internal" \\
A   & a.u.  &  Tfr.type = "internal" \\
Rfr & [0,1] &  Rfr.type = "total" \\
Rfr & [0,1] &  Rfr.type = "specular" \\
s.e.response & \eresponsenm &  time.unit = "second" \\
s.e.response & \eresponsedaynm &  time.unit = "day" \\
s.e.response & \eresponsetotnm &  time.unit = "exposure" \\
s.e.response & varies &  time.unit = \emph{duration} \\
s.q.response & \qresponsenm &  time.unit = "second" \\
s.q.response & \qresponsedaynm &  time.unit = "day" \\
s.q.response & \qresponsetotnm &  time.unit = "exposure" \\
s.q.response & varies &  time.unit = \emph{duration} \\
x, y, z & [0,1] & \\
\midrule
B: converted & & \\
\midrule
wl $\to$ w.length & nm & \\
wavelength $\to$ w.length & nm & \\
Tpc $\to$ Tfr & [0,100] &  Tfr.type = "total" \\
Tpc $\to$ Tfr  & [0,100] &  Tfr.type = "internal" \\
Rpc $\to$ Rfr  & [0,100] &  Rfr.type = "total" \\
Rpc $\to$ Rfr  & [0,100] &  Rfr.type = "specular" \\
counts.per.second $\to$ cps & \cps &  \\
\bottomrule
\end{tabular}
\end{table}

Energy irradiances are assumed to be expressed in \watt and photon irradiances in \mol, that is to say using second as unit for time. This is the default, but it is possible to set the unit for time to day in the case of \texttt{source\_spct} objects.

The default time unit used is \emph{second}, but \emph{day} and \emph{exposure} can be used by supplying the arguments \texttt{"day"} or \texttt{"exposure"}\footnote{The meaning of \texttt{"exposure"} is the total exposure  time, in other words, fluence instead of irradiance.}
to a parameter of the constructor of \texttt{source\_spct} objects.

The attributes are normally set when an object spectral object is created, either using default values of values supplied as arguments to the constructor.

\begin{framed}
\noindent
Not respecting these assumptions will yield completely wrong results! It is extremely important to make sure that the wavelengths are in nanometres as this is what all functions expect. If wavelength values are in the wrong units, the action-spectra weights and quantum conversions will be wrongly calculated, and the values returned by most functions completely wrong, without warning.
\end{framed}

If spectral irradiance data is in \wattnm, and the wavelength in nm, as is the case for many
Macam spectroradiometers, the data can be used directly and functions in the package will return irradiances in \watt.

If, for example, the spectral irradiance data output by a spectroradiometer is expressed in \mwattnm,
and the wavelengths are in Ångstrom then to obtain correct results when using any of the packages in the suite, we need to rescale the data when creating a new object.

<<example-1, eval=FALSE>>=
# not run
my.spct <- source_spct(w.length = wavelength/10, s.e.irrad = irrad/1000)
@

In the example above, we take advantage of the behaviour of the S language: an operation between a scalar and vector, is equivalent to applying this operation to each member of the vector.
Consequently, in the code above, each value from the vector of wavelengths is divided
by 10, and each value in the vector of spectral irradiances is divided by 1000.

\subsection{Querying the class}

Before giving examples of how to construct objects to store spectral data we show how to query the class of an object, and how to query the class of a spectrum. Consistently with R design, the package provides `is' functions for querying the type of spectra objects.

<<>>=
is.source_spct(sun.spct)
is.filter_spct(sun.spct)
is.any_spct(sun.spct)
@

In addition function \texttt{class.spc} returns directly the spectrum-related class attributes.

<<>>=
class_spct(sun.spct)
class_spct(1:10)
@

The built-in R function \texttt{class} returns all class attributes of an R object.

<<>>=
class(sun.spct)
class(1:10)
@

\subsection{Construction}

There are basically three different approaches to the creation of spectra. The first approach consist in setting the class attribute of an existing data frame or data table, in simple terms, converting an existing object into a spectral object. This approach avoids creating a copy of the data, and should be fastest. The second approach is to use an `as' function to create a new spectral object from a data frame or data table (the original object remains unchanged, and independent of the spectral object). The third approach is to use a function with the same name as the spectrum object class, and supply the data as numeric vector arguments. With the first two approaches the variables should be suitably named so that they can be recognized, in the third approach the formal argument to which the actual argument vector is supplied determines how it is interpreted.

\subsubsection{Setting the class of an object}\label{sec:set:spct}

\texttt{generic\_spct} objects can be created from data tables and data frames simply by setting them as such. However, a column called \texttt{w.length} must be present and contain wavelength values expressed in nm. Functions with names of the form \texttt{is.\_\_\_\_spct} are defined for all classes of spectra and can take as arguments any R object. In addition function \texttt{is.any\_spct} can use to query if an R object inherits from any of the classes of spectra defined in this package. Finally function \texttt{class\_spct} works similarly to R's \texttt{class} functions but returns a vector containing only the names of spectra classes. The `set' functions keep unrecognised variables, and fill missing required variables with \texttt{NA}, except for \texttt{w.length}, which if missing triggers an error.

We create a data.table object \texttt{a.spct}, and query its class.

<<>>=
a.spct <- data.frame(w.length = 300:305, y = 1)
class(a.spct)
class_spct(a.spct)
is.any_spct(a.spct)
@

We convert \texttt{a.spct} into a \texttt{generic\_spct} object, and query its class.

<<>>=
setGenericSpct(a.spct)
class(a.spct)
class_spct(a.spct)
is.generic_spct(a.spct)
a.spct
@

\texttt{source\_spct} objects can be created from data tables, data frames, and \texttt{generic\_spct} simply by setting them as such. However, columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{s.e.irrad} (\wattnm) or \texttt{s.q.irrad} (\molnm) must be present.

<<>>=
b.spct <- setSourceSpct(data.frame(w.length = 300:305, s.e.irrad = 1))
getTimeUnit(b.spct)
class(b.spct)
b.spct
@

If the spectral irradiance is expressed per day, then the parameter \texttt{time.unit} should be set to \texttt{"day"} instead of the default of \texttt{"second"}. This information is used when printing and plotting source spectra.

<<>>=
b.d.spct <- setSourceSpct(
  data.frame(w.length = 300:305, s.e.irrad = rep(1,6)),
  time.unit = "day")
getTimeUnit(b.d.spct)
class(b.d.spct)
b.d.spct
@

\texttt{filter\_spct} objects can be created from data tables, data frames, and \texttt{generic\_spct} simply by setting them as such. However, columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{Tpc} (T\%), \texttt{Tfr} (T as fraction of 1) and\textbackslash or \texttt{A} (absorbance ($\log_{10}$ based)) must be present.

<<>>=
c.spct <- setFilterSpct(data.frame(w.length = 300:305, Tfr = 1))
getTfrType(c.spct)
class(c.spct)
c.spct
@

If the spectral transmittance or absorbance is the internal component, then the parameter \texttt{Tfr.type} should be set to \texttt{"internal"} instead of the default of \texttt{"total"}. This information is used when printing and plotting source spectra.

<<>>=
c.i.spct <- setFilterSpct(data.frame(w.length = 300:305, Tfr = 1), "internal")
getTfrType(c.i.spct)
class(c.i.spct)
c.i.spct
@

\texttt{reflector\_spct} objects can be created from data tables, data frames, and \texttt{generic\_spct} simply by setting them as such. However, columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{Rpc} (R\%), and\textbackslash or \texttt{Rfr} (R as fraction of 1) must be present.

<<>>=
d.spct <- setReflectorSpct(data.frame(w.length = 300:305, Rfr = 1))
class(d.spct)
d.spct
@

\texttt{object\_spct} objects can be created from data tables, data frames, and \texttt{generic\_spct} simply by setting them as such. However, columns called \texttt{w.length} (wavelength values expressed in nm), \texttt{Tfr} (Transmittance, T, as fraction of one), and\textbackslash or \texttt{Rfr} (Reflectance, R, as fraction of one) must be present.

<<>>=
e.spct <- setObjectSpct(data.frame(w.length = 300:305, Tfr = 0.5, Rfr = 0.5))
class(e.spct)
e.spct
@

\texttt{object\_spct} objects can be also created by merging a \texttt{filter\_spct} object and \texttt{reflector\_spct} object if they share \texttt{w.length} values.

<<>>=
merged.spct <- merge(c.spct, d.spct)
class(merged.spct)
merged.spct
@

\texttt{chroma\_spct} objects can be created from data tables, data frames, and \texttt{generic\_spct} simply by setting them as such. However, columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{x}, \texttt{y} and \texttt{z} must be present, giving the trichromic chromaticity constants.

<<>>=
e.spct <- setChromaSpct(data.frame(w.length = 300:305, x = 1, y = 1, z = 1))
class(e.spct)
e.spct
@

In all cases if the expected data is not available, then it is filled-in if possible with values.

<<>>=
f.spct <- setReflectorSpct(data.frame(w.length = 300:305, Rpc = 100))
class(f.spct)
f.spct
@

When required data is not available, and it cannot be calculated from other columns, the required column is added and filled with \texttt{NA}s.
<<warning=TRUE, purl=FALSE>>=
g.spct <- setReflectorSpct(data.frame(w.length = 300:305, z = 1))
class(g.spct)
g.spct
@

If no variable named \texttt{w.length} is present, and a variable named \texttt{wl} is found, it is renamed to \texttt{w.length}.

<<error=TRUE, purl=FALSE>>=
h.spct <- setReflectorSpct(data.frame(wl = 300:305, Rfr = 1))
class(h.spct)
h.spct
@

The range of the input is checked, and warnings or errors issued. The wavelength range test cannot be overridden as the most likely reason for it to be triggered is the expression of wavelengths in units other than the expected nanometres (nm).

<<error=TRUE, purl=FALSE>>=
h1.spct <- setReflectorSpct(data.frame(wl = 5999:6001, Rfr = 1))
@

Transmittance and reflectance values are checked to be within their valid range, and spectral irradiance values to be zero or positive. By default failure of this test generates a fatal error.

<<error=TRUE, purl=FALSE>>=
h2.spct <- setReflectorSpct(data.frame(wl = 300:305, Rfr = -1))
@

The constructor converts percents to fractions before applying the tests.

<<error=TRUE, purl=FALSE>>=
h3.spct <- setReflectorSpct(data.frame(wl = 300:305, Rpc = -100))
@

Setting \texttt{strict.range = FALSE} issues a warning instead of an error, and returns a \texttt{reflector\_spct} object possibly containing the \emph{bad data}.

<<warning=TRUE, purl=FALSE>>=
h4.spct <- setReflectorSpct(data.frame(wl = 300:305, Rfr = -1),
                            strict.range = FALSE)
class(h4.spct)
h4.spct
@

Setting \texttt{strict.range = NULL} skips tests, and silently returns a \texttt{reflector\_spct} object possibly containing the \emph{bad data}.

<<>>=
h5.spct <- setReflectorSpct(data.frame(wl = 300:305, Rfr = -1),
                            strict.range = NULL)
class(h5.spct)
h5.spct
@

The constructor converts percents to fractions before applying the tests.

<<warning=TRUE, purl=FALSE>>=
h6.spct <- setReflectorSpct(data.frame(wl = 300:305, Rpc = -100),
                            strict.range = FALSE)
class(h6.spct)
h6.spct
@

\begin{framed}
\noindent
A very frequent source of off-range values is measurement noise. This noise should be preferably explicitly dealt with before any further calculations. Normal R and/or \texttt{data.frame} syntax can be used resolve these problems by smoothing or replacement of the problem data. If the `bad' data is outside the range of interest it can be trimmed by means of function \texttt{trim\_spct} after creating a spectrum with setting \texttt{strict.range = FALSE} or setting \texttt{strict.range = NULL}
\end{framed}

We next use the example solar spectral irradiance data included in the package.

<<>>=
class(sun.spct)
sun.spct
@

We can set a spectrum object to a different type of spectrum, but as above this can result in NAs in case of missing data. We need to make a copy of \texttt{sun.spct}, because being part of the package, it is protected and should not be modified by user code.

<<>>=
i.spct <- copy(sun.spct)
setGenericSpct(i.spct)
class(i.spct)
@


\subsubsection{Using `as' functions}

Here we briefly describe the `as' functions, as what has been discussed above for `set' functions also applies to `as' functions, as they simply make a copy of their argument before calling the set functions, and then return this new object.

We can make a `generic\_spct' copy of any spectrum object.

<<>>=
j.spct <- as.generic_spct(sun.spct)
class(j.spct)
class(sun.spct)
@

Or of a data frame.
<<>>=
k.df <- data.frame(wl = 400:410, anything = 1)
k.spct <- as.generic_spct(k.df)
class(k.spct)
class(k.df)
@

Both \texttt{as.source\_spct} and \texttt{as.filter\_spct} accept an argument for setting the \texttt{time.unit} and \texttt{Tfr.type} attributes, respectively, with the same defaults as described above.

\subsubsection{Using constructors}

This approach is similar to using function \texttt{data.frame} to create a data frame, but in this case the names of the arguments are meaningful and convey information on the nature of the spectral data and basis of expression. In the examples below we supply a single value for the spectral data. This value gets recycled as is normal in R, but of course in real use it is more usual to supply a vector of the same length as the \texttt{w.length} vector.

<<>>=
s.spct <- source_spct(w.length = 300:305, s.e.irrad = 100)
class_spct(s.spct)
s.spct
@

<<>>=
s.spct <- source_spct(w.length = 300:305, s.q.irrad = 40, time.unit = "day")
class_spct(s.spct)
s.spct
@

<<>>=
l.spct <- filter_spct(w.length = 300:305, Tpc = 100)
class_spct(l.spct)
l.spct
@

<<>>=
l.spct <- filter_spct(w.length = 300:305, A = 2)
class_spct(l.spct)
l.spct
@

<<>>=
wl1 <- 300:305
m.spct <- reflector_spct(w.length = wl1, Rfr = 0.5)
class_spct(m.spct)
m.spct
@

<<>>=
l.spct <- response_spct(w.length = 300:305, s.e.response = 0.5)
class_spct(l.spct)
l.spct
@

Function \texttt{source\_spct} accepts an argument for setting the \texttt{time.unit}, and functions \texttt{filter\_spct} and \texttt{object\_spct} accept an argument for setting the \texttt{Tfr.type} attributes, with the same defaults as described above. Functions \texttt{source\_spct}, \texttt{filter\_spct}, \texttt{reflector\_spct} and \texttt{object\_spct} have a \texttt{strict.range} formal argument, that alters checks as described in section \ref{sec:set:spct} above.

\subsection{Special attributes}

\texttt{source\_spct} objects have a \texttt{time.unit} attribute which can take one of two values \texttt{"second"} or \texttt{"day"}, the default is \texttt{"second"}. However, if the spectral data is for daily exposure, then the attribute should be set when the object is constructed. \texttt{source\_spct} objects have a \texttt{bswf.used} attribute which can take one of several values \texttt{"none"}, \texttt{"unknown"} or the name of a BSWF. It is also possible to set the attributes for an existing object with functions \texttt{setTimeUnit} and \texttt{setBSWFUsed}, and to query the value of the attributes for an existing object with functions \texttt{getTimeUnit} and \texttt{getBSWFUsed}.

\subsubsection{Retrieving attributes}

The function \texttt{is\_effective} returns \texttt{TRUE} if the value of the \texttt{bswf.used} is neither \texttt{NULL} nor equal to \texttt{"none"}.

<<>>=
is_effective(sun.spct)
is_effective(sun.spct * VIS())
getBSWFUsed(sun.spct * VIS())
is_effective(sun.spct * CIE())
getBSWFUsed(sun.spct * CIE())
@

\texttt{filter\_spct} and \texttt{object\_spct} objects have a \texttt{Tfr.type} attribute which can take one of two values \texttt{"total"} or \texttt{"internal"}, the default being \texttt{"total"}. However, if the spectral transmittance or absorbance data is internal, meaning excluding the contribution of reflection, then the attribute should be set when the object is constructed. It is also possible to set the attribute for an existing object with function \texttt{setTfrType}, and to query the value of the attribute  for an existing object with function \texttt{setTfrType}.

\texttt{reflector\_spct} and \texttt{object\_spct} objects have a \texttt{Rfr.type} attribute which can take one of two values \texttt{"total"} or \texttt{"specular"}, the default being \texttt{"total"}. However, if the spectral reflectance data is specular, meaning excluding the contribution of scattered reflection, then the attribute should be set when the object is constructed. It is also possible to set the attribute for an existing object with function \texttt{setRfrType}, and to query the value of the attribute for an existing object with function \texttt{setRfrType}.

\texttt{source\_spct} and \texttt{response\_spct} objects have a \texttt{time.unit} attribute. This can contain either character strings or \texttt{duration} objects as defined in package \texttt{lubridate}. When querying the \texttt{time.unit} of an object, by default the stored value is returned, but it is possibly to force the returned object to be a \texttt{lubridate::duration}, in which case \emph{character strings} are converted into \texttt{duration}, possibly \texttt{NA}.

<<>>=
getTimeUnit(sun.spct)
getTimeUnit(sun.daily.spct)
getTimeUnit(sun.spct, force.duration = TRUE)
getTimeUnit(sun.daily.spct, force.duration = TRUE)
@

\subsubsection{Setting attributes}

In most cases attributes are set during the constructions of spectral objects and should be changed with \emph{set} functions only to correct earlier mistakes, or exceptionally update objects created earlier versions of the package.
Although functions are available for directly setting attributes, these functions are very rarely used in user code, as changing attributes alone normally invalidates the data object. In some cases one may need to copy or restore attributes between objects that have become corrupted by their loss. In general, conversion methods should be used instead.

For example, sometimes it may be useful to change the time unit used for expresing spectral irradiance or spectral response, and this can be achieved with function \texttt{convertTimeUnit}. This function both converts spectral data to the new unit of expression and set the \texttt{time.unit} attribute, preserving the validity of the data object.

<<>>=
ten.minutes.spct <-
  convertTimeUnit(sun.spct, time.unit = duration(10, "minutes"), byref = FALSE)
head(ten.minutes.spct)
getTimeUnit(ten.minutes.spct)
@

\begin{framed}
\noindent
Spectral objects created with earlier (pre-release) versions of this package are missing some attributes. For this reason `summary' and `plot' functions may not work as expected with them. These \emph{old} objects can be updated by adding the missing attribute using functions \texttt{setTimeUnit}, \texttt{setBSWFUsed}, \texttt{setTfrType} and \texttt{setRfrType}. However, in many cases function \texttt{update\_spct} can be used to set the missing attributes to default values, or the scripts re-run to rebuild the data objects from raw data.
\end{framed}

\section{Collections of spectra}

\subsection{Classes}

The package defines several classes intended to be used to store \emph{collections} of different types of spectral data. They are all derived from \texttt{generic\_mspct}, which in turn is derived from \texttt{list}. Table \ref{tab:mspct:classes} lists them.

\begin{table}
\caption{Classes for colletion of spectral objects}\label{tab:spct:classes}
\centering
\begin{tabular}{lll}
\toprule
Name & Member objects & Attributes\\
\midrule
generic\_mspct & generic\_spct & names, dim \\
cps\_mspct & cps\_spct & names, dim \\
source\_mspct & source\_spct & names, dim \\
filter\_mspct & filter\_spct & names, dim \\
reflector\_mspct & reflector\_spct & names, dim \\
object\_mspct & object\_spct & names, dim \\
response\_mspct & response\_spct & names, dim \\
chroma\_mspct & chroma\_spct & names, dim \\
\bottomrule
\end{tabular}
\end{table}

Objects of these classes, except for those of class \texttt{generic\_mspct}, can contain members belonging to one of the classes. Being all other spectral object classes derived from \texttt{generic\_spct}, \texttt{generic\_mspct} objects can contain heterogeneous collections of spectra. In all cases, there are no restrictions on the lengths, wavelength range and/or wavelength step size, or attributes other than \texttt{class} of the contained spectra. Mimicking R's arrays and matrixes, a \texttt{dim} attribute is always present and \texttt{dim} methods are provided. These allows the storage of time series of spectral data, or (hyper)spectral image data, or even higher dimensional spectral data. The handling of 1D and 2D spectral collections is already implemented in the summary methods. Handling of 3D and higher dimensional data can be implemented in the future without changing the class definition. By having implemented \texttt{dim}, also methods \texttt{ncol} and \texttt{nrow} are available as they use \texttt{dim} internally. Array-like subscripting is \textbf{not} implemented.

\subsection{Construction}

\subsubsection{Constructors}

We can construct a collection using a list of spectral objects as a starting point, in this case the spectral transmittance for two glass filters.
<<>>=
two_filters.mspct <- filter_mspct(list(gg400 = gg400.spct,
                                       og550 = og550.spct))
@

We can also create heterogeneous collections, but this reduces the number of methods that can be used on the resulting collection.

<<>>=
mixed.mspct <- generic_mspct(list(filter = clear.spct, source = sun.spct))
@

\subsubsection{Using `as' functions}

The \texttt{as} functions for collections of spectra, not only change the class of the collection object, but also apply the corresponding {as} functions to the member objects. They copy the original objects and then convert the copy, which is returned.

<<>>=
two_gen.mscpt <- as.generic_mspct(two_filters.mspct)
class(two_gen.mscpt)
lapply(two_gen.mscpt, class_spct)
@

\subsection{Querying the class}

\texttt{is.} functions are defined for these classes. R's \texttt{class} method can also be used.

<<>>=
is.filter_mspct(two_filters.mspct)
class(two_filters.mspct)
@

In addition to using \texttt{class} to query the class of the collection, we can use base R's \texttt{lapply} together with \texttt{class} or \texttt{class\_spct} to query the class of each of the members of the collection.

<<>>=
is.filter_mspct(mixed.mspct)
is.any_mspct(mixed.mspct)
class(mixed.mspct)
lapply(mixed.mspct, class_spct)
lapply(mixed.mspct, class)
@

\section{Wavebands}

When a range of wavelengths or a range of wavelengths plus a spectral weighting function (SWF) is needed for radiation summaries or transformations, methods, operators and functions defined in package \PB  use \texttt{waveband} objects to store and exchange these data. A few other bits of information can be included to fine-tune calculations. The waveband definitions do NOT describe whether input spectral irradiances are photon or energy based, nor whether the output irradiance will be based on photon or energy units. All waveband objects belong to the S3 class \texttt{waveband}.

\subsection{Construction}

When defining a waveband which uses a SWF, a function can be supplied either based on energy effectiveness, on photon effectiveness, or one function for each one. If only one function is supplied the other one is built automatically, but if performance is a concern it is better to provide two separate functions. Another case when you might want to enter the same function twice, is if you are using an absorptance spectrum as SWF, as the percent of radiation absorbed will be independent of whether photon or energy units are used for the spectral irradiance.

Two different functions can be used to create a waveband: \texttt{waveband} and \texttt{new\_waveband}.

The difference is that \texttt{waveband} accepts the limits through a single argument, which can be any R object for which there is a suitable \texttt{range} function returning the range of wavelengths (nm) as a numeric vector of length 2.

<<example-waveband-01, eval=TRUE>>=
my_PAR <- waveband(c(400, 700))
my_PARb <- new_waveband(400, 700)
my_PAR
my_PARb
@

The examples above, show that both constructors return equivalent waveband objects.

Below we give a name to the waveband.

<<>>=
my_PARx <- waveband(c(400, 700), wb.name = "my_PARx")
@

Three examples of how to define equivalent wavebands based on a SWF follow.

<<>>=
my_CIE_1 <-
  waveband(c(250, 400), weight = "SWF", SWF.e.fun = CIE_e_fun, SWF.norm = 298)
my_CIE_2 <-
  waveband(c(250, 400), weight = "SWF", SWF.q.fun = CIE_q_fun, SWF.norm = 298)
my_CIE_3 <-
  waveband(c(250, 400), weight = "SWF", SWF.e.fun = CIE_e_fun,
                         SWF.q.fun = CIE_q_fun, SWF.norm = 298)
@

The function \texttt{waveband} is also useful when wanting to create a waveband covering the whole range of an spectrum, or when creating an unweighted waveband which covers exactly the same range of wavelengths as an existing weighted waveband.

<<>>=
waveband(sun.spct)
waveband(my_CIE_1)
@

\subsection{Querying the class}

The function \texttt{is.waveband} can the used to query any R object. This function returns a logical value.

<<>>=
is.waveband(my_CIE_1)
is.waveband(PAR())
is.waveband(sun.spct)
@

Base R function \texttt{class} can the used to retrieve the class attribute of any R object. This function returns a character vector.

<<>>=
class(PAR())
@

\subsection{Retrieving properties}

The function \texttt{is\_effective} can the used to query any R object.

<<>>=
is_effective(my_CIE_1)
is_effective(GEN.G())
is_effective(PAR())
is_effective(sun.spct)
@

\section{Collections of wavebands}

In the current implementation there is no special class used for storing collections of \texttt{waveband} objects. We simply use base R's \texttt{list} class.

\subsection{Construction}

\subsubsection{List constructor}

Just base R's functions used to create a list object.

<<>>=
wavebands <- list(waveband(c(300,400)), waveband(c(400,500)))
wavebands
@

\subsubsection{Special constructor}

The function \texttt{split\_bands} can be used to generate lists of unweighted wavebands in two different ways: a) it can be used to split a range of wavelengths given by an R object into a series of adjacent wavebands, or b) with a list of objects returning ranges, it can be used to create non-adjacent and even overlapping wavebands.

The code chunk bellow shows an example of two variations of case a). With the default value for \texttt{length.out} of \texttt{NULL} each numerical value in the input is taken as a wavelength (nm) at the boundary between adjacent wavebands. If a numerical value is supplied to \texttt{length.out}, then the whole wavelength range of the input is split into this number of equally spaced adjacent wavebands.

<<>>=
split_bands(c(200, 225, 300))
split_bands(c(200, 225, 300), length.out = 2)
@

In both examples above, the output is a list of two wavebands, but the `split' boundaries are at a different wavelength. The chunk bellow gives a few more examples of the use of case a).

<<>>=
split_bands(sun.spct, length.out = 2)
split_bands(PAR(), length.out = 2)
split_bands(c(200, 800), length.out = 3)
# we use head show the first two out of 100 wavebands
head(split_bands(c(200, 800), length.out = 100), 2)
@

Now we demonstrate case b). This case is handled by recursion, so each list element can be anything that is a valid input to the function, including a nested list. However, the returned value is always a flat list of wavebands.

<<>>=
split_bands(list(A = c(200, 300), B = c(400, 500), C = c(250, 350)))
split_bands(list(c(100, 150, 200), c(800, 825)))
@

In case b) if we supply a numeric value to \texttt{length.out}, this value is used recursively for each element of the list.

<<>>=
split_bands(list(R = Red(), B = Blue()), length.out  =  2)
split_bands(list(c(100, 150, 200), c(800, 825)), length.out = 1)
@

\section{Transformations: using operators}

\subsection{Binary operators}

The basic maths operators have definitions for spectra. It is possible to sum, subtract, multiply and divide spectra. These operators can be used even if the spectral data is on different arbitrary sets of wavelengths. Operators by default use values expressed in energy units. Only certain operations are meaningful for a given combination of
objects belonging to different classes, and meaningless combinations return \texttt{NA} also issuing a warning (see Table \ref{tab:operators}). By default operations are carried out on spectral energy irradiance for \texttt{source\_spct} objects and transmittance for \texttt{filter\_spct} objects.

\begin{table}
\newcommand{\N}{\textcolor{red}{\small N}}
\newcommand{\Y}{\textcolor{green}{\small Y}}
\caption[Binary operators]{Binary operators and operands. Validity and class of result. All operations marked `\Y' are allowed, those marked `\N' are forbidden and return \texttt{NA} and issue a warning.}\label{tab:operators}\vspace{0.75ex}
\begin{tabular}{lcccccll}
\toprule
e1 & \verb|+| & \verb|-| & \verb|*| & \verb|/| & \verb|^| & e2 & result \\
\midrule
cps\_spct & \Y & \Y &\Y  & \Y & \Y & cps\_spct & cps\_spct \\
source\_spct & \Y & \Y &\Y  & \Y & \Y & source\_spct & source\_spct \\
filter\_spct (T) & \N & \N & \Y & \Y  & \N & filter\_spct & filter\_spct \\
filter\_spct (A) & \Y & \Y & \N & \N  & \N & filter\_spct & filter\_spct \\
reflector\_spct & \N & \N & \Y &\Y  & \N & reflector\_spct & reflector\_spct \\
object\_spct & \N & \N & \N & \N &\N & object\_spct & -- \\
response\_spct & \Y & \Y & \Y & \Y & \N & response\_spct & response\_spct \\
chroma\_spct & \Y  & \Y & \Y & \Y & \Y & chroma\_spct & chroma\_spct \\
\midrule
cps\_spct & \Y  & \Y &\Y  & \Y & \Y & numeric & cps\_spct \\
source\_spct & \Y  & \Y &\Y  & \Y & \Y & numeric & source\_spct \\
filter\_spct & \Y  &\Y  & \Y &\Y  & \Y & numeric & filter\_spct \\
reflector\_spct & \Y &\Y  &\Y  &\Y  & \Y & numeric & reflector\_spct \\
object\_spct & \N & \N & \N & \N &\N & numeric & -- \\
response\_spct & \Y  & \Y  & \Y  & \Y  & \Y & numeric & response\_spct \\
chroma\_spct & \Y & \Y  & \Y & \Y  & \Y & numeric & chroma\_spct \\
\midrule
source\_spct & \N & \N & \Y &\Y  & \N & response\_spct & response\_spct \\
source\_spct & \N & \N & \Y  & \Y  & \N & filter\_spct (T) & source\_spct \\
source\_spct & \N & \N & \Y  & \Y & \N & filter\_spct (A) & source\_spct \\
source\_spct & \N & \N & \Y  & \Y  & \N & reflector\_spct & source\_spct \\
source\_spct & \N & \N &\N  & \N & \N & object\_spct & -- \\
source\_spct & \N & \N &\Y  & \N & \N & waveband (no BSWF) & source\_spct \\
source\_spct & \N & \N &\Y  & \N & \N & waveband (BSWF) & source\_spct \\
\bottomrule
\end{tabular}
\end{table}


<<>>=
sun.spct * sun.spct
sun.spct / sun.spct
sun.spct + sun.spct
sun.spct - sun.spct
@

When meaningful, operations between different spectra are also allowed. For example, it is possible to simulate the effect of a filter on a light source by multiplying (or convolving) the two spectra.

<<>>=
sun.spct * polyester.new.spct
@

If we have two layers of the filter, this can be approximated using either of these two statements.

<<>>=
sun.spct * polyester.new.spct * polyester.new.spct
sun.spct * polyester.new.spct^2
@

Operators are also defined for operations between a spectrum and a numeric vector (with normal recycling).

<<>>=
sun.spct * 2
2 * sun.spct
sun.spct * c(0,1)
@

There is one special case, for \texttt{chroma\_spct}: if the numeric operand has length three, containing three \emph{named} values `x', `y' and `z', the corresponding value is used for each of the chromaticity `columns' in the \texttt{chroma\_spct}. Un-named values or differently named values are not treated specially.

Operators are also defined for operations between an spectrum and a \texttt{waveband} object. The next to code chunks demonstrate how the class of the result depends on whether the \texttt{waveband} object describes a range of wavelengths or a range of wavelengths plus a BSWF.

<<>>=
is_effective(UVB())
clipped.spct <- sun.spct * UVB()
class_spct(clipped.spct)
clipped.spct
@

<<>>=
is_effective(CIE())
weighted.spct <- sun.spct * CIE()
class_spct(weighted.spct)
is_effective(weighted.spct)
weighted.spct
@

And of course these operations can be combined into more complex statements, including parentheses, when needed. The example below estimates the difference in effective spectral irradiance according to the CIE98 definition, between sunlight and sunlight filtered with a polyester film. Of course, the result is valid only for the
solar spectral data used, which corresponds to Southern Finland.

<<warning=TRUE, purl=FALSE>>=
sun.spct * CIE() - sun.spct * polyester.new.spct * CIE()
@

\subsection{Unary operators and maths functions}

The most common mat functions, as well as unary minus and plus, are also implemented for spectral objects (see Table \ref{tab:unary}).

\begin{table}
\newcommand{\N}{\textcolor{red}{\small N}}
\newcommand{\Y}{\textcolor{green}{\small Y}}
\caption[Binary operators]{Unary operators and maths functions. Validity and class of result. All operations marked `\Y' are allowed, those marked `\N' are not implemented and return \texttt{NA} and issue a warning.}\label{tab:unary}\vspace{0.75ex}
\centering
\begin{tabular}{lcccccll}
\toprule
e1 & \verb|+| & \verb|-| & \verb|log()| & \verb|log10()| & \verb|exp()| & \verb|sqrt()| & result \\
\midrule
cps\_spct & \Y & \Y &\Y  & \Y & \Y & \Y & cps\_spct \\
source\_spct & \Y & \Y &\Y  & \Y & \Y & \Y & source\_spct \\
filter\_spct & \Y & \Y & \Y & \Y  & \Y & \Y & filter\_spct \\
reflector\_spct & \Y & \Y & \Y &\Y  & \Y & \Y & reflector\_spct \\
object\_spct & \N & \N & \N & \N & \N & \N & -- \\
response\_spct & \Y & \Y & \Y & \Y & \Y & \Y & response\_spct \\
chroma\_spct & \Y  & \Y & \Y & \Y & \Y & \Y & chroma\_spct \\
\bottomrule
\end{tabular}
\end{table}

<<>>=
+sun.spct
-sun.spct
log(sun.spct)
log10(sun.spct)
exp(sun.spct)
sqrt(sun.spct)
@

\subsection{Options}

Table \ref{tab:options} lists all the recognized options affecting maths operators and functions, and their default values. Within the suite all functions have a default value which is used when the options are undefined. Options are set using base R's function \texttt{options}, and queried with functions \texttt{options} and \texttt{getOption}.

\begin{table}
\caption[Options]{Options recognized by functions in the \PB package and the values they can take.\label{tab:options}}\vspace{0.75ex}

\centering
\begin{footnotesize}
\begin{tabular}{lll}
\toprule
\textbf{Option} & \textbf{default} & \textbf{function} \\
\midrule
\textbf{Base R} & & \\
\addlinespace
digits & 7 & $d - 3$ used by \texttt{summary} \\
\midrule
photobiology.radiation.unit & \texttt{"energy"} & output (\wattnm) \\
                            & \texttt{"photon"} & output (\molnm) \\
photobiology.filter.qty & \texttt{"transmittance"} & output ($/1$) \\
                        & \texttt{"absorptance"} & output ($/1$) \\
                        & \texttt{"absorbance"} & output (a.u. $\log_10$ base) \\
photobiology.use.hinges & \texttt{NULL} & guess automatically \\
                        & \texttt{TRUE} & do not insert hinges \\
                        & \texttt{FALSE} & do insert hinges \\
photobiology.auto.hinges.limit & 0.5 & wavelength step (nm) \\
photobiology.waveband.trim & \texttt{TRUE} & trim or exclude \\
photobiology.use.cached.mult & \texttt{FALSE} & cache intermediate results or not \\
photobiology.verbose & \texttt{FALSE} & give verbose output or not \\
\bottomrule
\end{tabular}
\end{footnotesize}
\end{table}

The behaviour of the operators defined in this package depends on the value of two global options. If we would like the operators to
operate on spectral photon irradiance and return spectral photon irradiance instead of spectral energy irradiance,
this behaviour can be set, and will remain active until unset or reset.

<<>>=
options(photobiology.radiation.unit = "photon")
sun.spct * UVB()
options(photobiology.radiation.unit = "energy")
sun.spct * UVB()
@

For filters, an option controls whether transmittance, the default, or absorbance is use in the operations, and returned.

<<>>=
options(photobiology.filter.qty = "absorbance")
polyester.new.spct * 2
options(photobiology.filter.qty = "transmittance")
polyester.new.spct ^ 2
@

Either option can be unset, by means of the \texttt{NULL} value.
<<>>=
options(photobiology.radiation.unit = NULL)
options(photobiology.filter.qty = NULL)
@


\section{Transformations: methods and functions}

In this section we describe methods and functions that take one or more spectral objects, and in some cases also waveband objects, as arguments and return another spectral object (Table \ref{tab:transform:spct}) or that take a collection of spectral objects, and in some cases also waveband objects, as argumnents and return a collection of spectral objects (Table \ref{tab:transform:mspct}).

\begin{table}
  \caption[Transformation methods for spectra]{Transformation methods for spectra. Key: + available, -- not available, f available in the future.}\label{tab:transform:spct}
  \centering
  \begin{footnotesize}
  \begin{tabular}{>{\ttfamily}lcccccc}
    \toprule
    \textnormal{methods} & source & response & filter & reflector & object & chroma \\
    \midrule
    merge & + & + & + & + & + & + \\
    rbindspct & + & + & + & + & + & + \\
    \midrule
    e2q, q2e & + & + & -- & -- & -- & -- \\
    A2T, T2A & -- & -- & + & -- & -- & -- \\
    subset & + & + & + & + & + & + \\
    trim\_spct & + & + & + & + & + & + \\
    interpolate\_spct & + & + & + & + & + & + \\
    f\_scale & + & + & + & + & + & +  \\
    normalize & + & + & + & + & + & +  \\
    \emph{math operators} & + & + & + & + & + & +  \\
    \emph{math functions} & + & + & + & + & + & +  \\
    tag & + & + & + & + & + & +  \\
    \bottomrule
  \end{tabular}
  \end{footnotesize}

\end{table}

\begin{table}
  \caption[Transformation methods for collections of spectra]{Transformation methods for collections of spectra. Key: + available, -- not available, f available in the future.}\label{tab:transform:mspct}
  \centering
  \begin{footnotesize}
  \begin{tabular}{>{\ttfamily}lcccccc}
    \toprule
    \textnormal{methods} & source & response & filter & reflector & object & chroma \\
    \midrule
    mutate\_mspct & + & + & + & + & + & + \\
    rbindspct & + & + & + & + & + & + \\
    \midrule
    e2q, q2e & + & + & -- & -- & -- & -- \\
    A2T, T2A & -- & -- & + & -- & -- & -- \\
    trim\_spct & f & f & f & f & f & f \\
    interpolate\_spct & f & f & f & f & f & f \\
    f\_scale & f & f & f & f & f & f \\
    normalize & f & f & f & f & f & f \\
    \emph{math operators} & f & f & f & f & f & f \\
    \emph{math functions} & f & f & f & f & f & f \\
    tag & f & f & f & f & f & f \\
    \bottomrule
  \end{tabular}
  \end{footnotesize}

\end{table}

\subsection{Row binding spectra}

Sometimes, especially for plotting, we may want to row-bind spectra. When the aim is that the returned object
retains its class attributes, and other spectrum related attributes like the time unit, functions \texttt{rbind}
from base R, and its reimplementation from package \texttt{data.table}, and function \texttt{rbindlist} also
defined in package \texttt{data.table} should NOT be used. Package \PB provides function \texttt{rbinspct} for
row-binding spectra, with the necessary checks for consistency of the bound spectra.

In addition to lists of spectral objects, \texttt{rbindspct} accepts objects of \texttt{generic\_mspct} and
derived classes as input.

<<>>=
# STOPGAP
shade.spct <- copy(sun.spct)
@

By default an ID factor named \texttt{spct.idx} is added so that it is possible to identify the origin of the observations after the binding. If the supplied list has named members, then these names are used as factor levels. Otherwise level names are generated automatically.

<<>>=
rbindspct(list(sun.spct, shade.spct))
@

It is possible to suppress the creation of the ID factor, but this is rarely of any use.

<<>>=
rbindspct(list(sun.spct, shade.spct), idfactor = FALSE)
@

If a named list of spectra with no missing names, is supplied as argument, these names are used for the levels of the ID factor.

<<>>=
rbindspct(list(sun = sun.spct, shade = shade.spct), idfactor = TRUE)
@

If a character string is supplied as argument, then this will be used as the name of the factor.

<<>>=
rbindspct(list(sun = sun.spct, shade = shade.spct), idfactor = "ID")
@

In the special case when the members of the list are \texttt{source\_spct} objects containing effective spectral irradiance data, and they are not based on the same BSWF, an additional factor \texttt{BSWF} will be automatically added, and the \texttt{BSWF} attribute of the resulting spectrum set to \texttt{"multiple"}.

<<>>=
rb2.spct <- rbindspct(list(sun.spct * CIE(), shade.spct * CIE()))
rb2.spct
getBSWFUsed(rb2.spct)
@

<<>>=
rb1.spct <- rbindspct(list(sun.spct * CIE(), sun.spct * GEN.G()))
rb1.spct
getBSWFUsed(rb1.spct)
@

The warning above is caused by the different length of the members of the list, and in this case it is safe to ignore it.

<<>>=
range(sun.spct * CIE())
range(sun.spct * GEN.G())
@

Special \textit{Extract} methods for spectral objects have been implemented. These are used by default and preserve the attributes used by this package, except when the retruned value is a single column from the spectral object.

<<>>=
sun.spct[1:10, ]
sun.spct[1:10, 1]
sun.spct[1:10, 1, drop = TRUE]
sun.spct[1:10, "w.length", drop = TRUE]
@

In contrast to \texttt{trim\_spct}, \texttt{subset} never interpolates or inserts \emph{hinges}. On the other hand, the \texttt{subset} argument accepts any logical expression and can be consequently used to do subsetting, for example, based on factors. Both \texttt{subset()} and \texttt{trim()} methods preserve attributes.

<<>>=
subset(sun.spct, s.e.irrad > 0.2)
subset(sun.spct, w.length > 600)
subset(sun.spct, c(TRUE, rep(FALSE, 99)))
@

\subsection{Conversions between radiation units}

The functions \texttt{e2q} and \texttt{q2e} can be used on source spectra to convert spectral energy irradiance into spectral photon irradiance and vice versa. The first argument should be a spectrum, and the second optional argument sets the action with \texttt{"add"} and \texttt{"replace"} as possible values. In the second case the whole spectrum object is copied, while in the first case a column is added but the unchanged columns are references to the original ones, rather than copies.

<<>>=
a.spct <-  e2q(sun.spct, "replace")
a.spct
@

For \texttt{filter\_spct} objects functions \texttt{T2A} and \texttt{A2T} allow conversion between spectral transmittance and spectral absorbance and vice versa.

\subsection{Normalizing a spectrum}

Function \texttt{normalize} permits normalizing a spectrum to one at an arbitrary wavelength (nm) or to the wavelength
of either the maximum or the minimum spectral value.

<<>>=
normalize(sun.spct)
@

Which is equivalent to

<<>>=
normalize(sun.spct, norm = "max")
@

We can also supply an arbitrary wavelength within the range of the data, and interpolation will be used if needed to calculate the multiplier but no insertion will be done on the spectral data. Consequently, a spectral value equal to one will not necessarily be generated when supplying a wavelength value as argument.

<<>>=
normalize(sun.spct, norm = 600.3)
@

It is also possible to supply a range within which the normalization wavelength will be searched.

<<>>=
normalize(sun.spct, range = PAR(), norm = "max")
@

As is the case for other functions, the argument \texttt{"unit.out"} can be used to change the type output from the default.

\subsection{Rescaling a spectrum}

Function \texttt{f\_scale} rescales a spectrum by dividing each spectral data value by a summary calculated with a function (f) selected by a character string, either the integrated "total" or the average or "mean" value over a range of wavelengths.

<<>>=
fscale(sun.spct)
@

<<>>=
fscale(sun.spct, f = "total")
@

It is also possible to supply a range within which integration or averaging will be done.

<<>>=
fscale(sun.spct, range = PAR(), f = "mean")
@

As is the case for other functions, the argument \texttt{"unit.out"} can be used to change the type output from the default.

In addition to the character constants \texttt{"total"} and \texttt{"mean"}, it is possible to pass any suitable R function, built-in or user defined, through parameter \texttt{f} plus additional named arguments to it.

\subsection{Wavelength interpolation}

Converting spectra available at a given set of wavelengths values to a different one, is frequently needed when operating with several spectra of different origin. One can increase the \emph{apparent} resolution by interpolation, and reduce it by local averaging or smoothing and resampling. The same function works on all \texttt{spct} objects, interpolating every column except \texttt{w.length} and replacing in this last column the old wavelength values with the new ones supplied as argument. The optional argument \texttt{fill.value} control what value is assigned to wavelengths in the new data that are outside the range of the old wavelengths.

<<>>=
interpolate_spct(sun.spct, seq(400, 500, by = 0.1))
@

\subsection{Trimming}\label{sec:trim:spct}

\begin{framed}
\noindent
Because of how \verb|[ ]| operators work in R, and especially on objects of classes derived from \texttt{data.table} some object attributes are lost when this operator is used to subset spectral objects, consequently it is safer to use the function described in this section.
\end{framed}

Sometimes it is desirable to change the range of wavelengths included in a spectrum. If we are interested in a given part of the spectrum, there is no need to do calculations or plotting the whole spectrum. Sometimes we may want to expand the range of wavelengths, filling the expansion of all other variables with a certain value (i.e.\ a number, or NA.)

We can supply the arguments \texttt{band}, \texttt{low.limit}, \texttt{high.limit}, and \texttt{fill}. Either \texttt{band} or \texttt{low.limit} and/or \texttt{high.limit} arguments should supplied, but not both at once. We use \texttt{head} to print the first six lines.

<<>>=
head(trim_spct(sun.spct, PAR()))
@


<<>>=
head(trim_spct(sun.spct, low.limit = 297))
@

By default \texttt{trim\_spct} trims its argument by copy, this can be changed by setting \texttt{byref = TRUE} but as \texttt{sun.spct} is protected as part of the package, we cannot use it here.

<<>>=
my_sun.spct <- copy(sun.spct)
head(trim_spct(my_sun.spct, low.limit = 297, byref = TRUE))
@

The default \texttt{fill} value is \texttt{NULL} which means deleting the values outside the trimmed region. It is possible to supply a different argument.

<<>>=
head(trim_spct(sun.spct, low.limit = 297, fill = 0))
@

<<>>=
head(trim_spct(sun.spct, low.limit = 297, fill = NA))
@

In addition, when fill is not \texttt{NULL}, expansion is possible.

<<>>=
head(trim_spct(sun.spct, low.limit = 290, fill = 0))
@

\subsection{Convoluting weights}

It is very instructive to look at weighted spectral data to understand how effective irradiances are calculated. Plotting effective spectral irradiance data can be very instructive when analyzing the interaction of photoreceptors and ambient radiation. It can also illustrate what a large effect that small measuring errors can have on the estimated effective irradiances or exposures when SWFs have a steep slope.

\subsubsection{Individual spectra}

The multiplication operator is defined for operations between a \texttt{source\_spct} and a \texttt{waveband}, so this is the easiest way of doing the calculations.

<<>>=
sun.CIE.spct <- sun.spct * CIE()
sun.CIE.spct
@

We here plot, using \texttt{ggplot2}, weighted (in red) and unweighted irradiances using simulated solar spectral irradiance data stored as a \texttt{source\_spct} object, and applying the BSWF weights on the fly.

<<>>=
ggplot(data = sun.spct, aes(x = w.length, y = s.e.irrad/max(s.e.irrad))) +
  geom_line() +
  geom_line(data = sun.spct * CIE(), colour = "red") +
  labs(x = "Wavelength (nm)",
       y = "UnWeighted and CIE98-weighted spectral irradiance (relative units)")
@

An alternative is as follows, where it is easier to use other aesthetics, or plot additional curves as shown in the chunk below.

<<warning=FALSE>>=
combined.spct <- rbindspct(list(normalize(sun.spct * PG(), range = c(290,400)),
                                normalize(sun.spct * GEN.G(), range = c(290,400)),
                                normalize(sun.spct * GEN.T(), range = c(290,400)),
                                normalize(sun.spct * GEN.M(), range = c(290,400))
                                )
                           )
@

<<fig.width=8, fig.height=4>>=
ggplot(data = combined.spct, aes(x = w.length, y = s.e.irrad, colour = BSWF)) +
  geom_line() +
  labs(x = "Wavelength (nm)",
       y = "Effective spectral irradiance (relative units)")
@

<<>>=
ggplot(data = combined.spct, aes(x = w.length, y = s.e.irrad)) +
  geom_line() + facet_wrap(~BSWF, ncol = 2) +
  labs(x = "Wavelength (nm)",
       y = "Effective spectral irradiance (relative units)")
@

\subsubsection{Vectors}

It is also possible to use vectors, and base R plot functions.

<<weighted-spectra-01, tidy=FALSE>>=
weighted.s.e.irrad <-
  with(sun.spct,
       s.e.irrad * calc_multipliers(w.length, CIE())
  )
plot(weighted.s.e.irrad/max(weighted.s.e.irrad) ~ w.length, type = "l",
     data = sun.spct,
     col = "red",
     xlab = "Wavelength (nm)",
     ylab = "UnWeighted and CIE98-weighted spectral irradiance (relative units)")
lines(s.e.irrad/max(s.e.irrad) ~ w.length, col = "black", data = sun.spct)
@

\subsection{Tagging with bands and colours}

We call tagging, to the process of adding reference information to spectral data. For example we can add a factor indicating regions or bands in the spectrum. We can add also information on the colour, as seen by humans, for each observed value, or for individual regions or bands of the spectrum. In most cases this additional information is used for annotations when plotting the spectral data.

\subsubsection{Individual spectra}

The function \texttt{tag} can be used to tag different parts of a spectrum according to wavebands.

<<>>=
tag(sun.spct, PAR(), byref = FALSE)
tag(sun.spct, UV_bands(), byref = FALSE)
@

The added factor and colour data can be used for further processing or for plotting. Information about the tagging and wavebands is stored in an attribute \texttt{tag.attr} in every tagged spectrum, this yields a more compact output and keeps a `trace' of the tagging.

<<>>=
tg.sun.spct <- tag(sun.spct, PAR(), byref = FALSE)
attr(tg.sun.spct, "spct.tags")
@

Additional functions are available which return a tagged spectrum and take as input a list of wavebands, but no spectral data. They `build' a spectrum from the data in the wavebands, and are useful for plotting the boundaries of wavebands.

<<>>=
wb2tagged_spct(UV_bands())
wb2rect_spct(UV_bands())
@

Function \texttt{wb2tagged\_spct} returns a tagged spectrum, with two rows for each waveband, corresponding to the low and high wavelength boundaries, while function \texttt{wb2rect\_spct} returns a spectrum with only one row per waveband, with \texttt{w.length} set to its midpoint but with additional columns  \texttt{xmin} and \texttt{xmax} corresponding to the low and high wavelength boundaries of the wavebands.

Function \texttt{is\_tagged} can be used to query if an spectrum is tagged or not, and function \texttt{untag} removes the tags.

<<>>=
tg.sun.spct
is_tagged(tg.sun.spct)
untag(tg.sun.spct)
is_tagged(tg.sun.spct)
@

In the chuck above, we can see how this works, using in this case the default \texttt{byref = TRUE} which adds the tags in place, or ``by reference'', to the spct object supplied as argument.

In the chunk bellow, we demonstrate that if an already tagged spectrum is re-tagged, the old tags are replaced with new ones, with a warning.

<<warning=TRUE, purl=FALSE>>=
tag(tg.sun.spct, PAR())
tag(tg.sun.spct, VIS())
@

\section{Summaries}

Summaries can be calculated both from individual spectral objects (Table \ref{tab:summaries:spct}) and from collections of spectral objects (Table \ref{tab:summaries:mspct}). They return a \emph{simpler} object than the spectral data in their arguments. For example a vector of numeric values, possibly of length one, in the case of individual spectra, or a data frame containing one row of summary data for each spectrum the collection of multiple spectra supplied as argument.

\begin{table}
  \caption[Summary methods for spectra]{Summary methods for spectra.  Key: + available, -- not available, f available in the future.}\label{tab:summaries:spct}
  \centering
  \begin{footnotesize}
  \begin{tabular}{>{\ttfamily}lcccccc}
    \toprule
    \textnormal{methods} & source & response & filter & reflector & object & chroma \\
    \midrule
    irrad, e\_irrad, q\_irrad & + & -- & -- & -- & -- & -- \\
    fluence, e\_fluence, q\_fluence & + & -- & -- & -- & -- & -- \\
    ratio, e\_ratio, q\_ratio & + & -- & -- & -- & -- & -- \\
    qe\_ratio, eq\_ratio & + & -- & -- & -- & -- & -- \\
    response, e\_response, q\_response & -- & + & -- & -- & -- & -- \\
    transmittance & -- & -- & + & -- & + & -- \\
    absorptance & -- & -- & + & -- & + & -- \\
    absorbance & -- & -- & + & -- & + & -- \\
    range, min, max & + & + & + & + & + & + \\
    stepsize, spread, midpoint & + & + & + & + & + & + \\
    labels & + & + & + & + & + & + \\
    summary & + & + & + & + & + & + \\
    peaks & + & + & + & + & + & + \\
    valleys & + & + & + & + & + & + \\
    integrate\_spct & + & + & + & + & + & + \\
    average\_spct & + & + & + & + & + & + \\
    color & + & -- & + & + & -- & + \\
    \bottomrule
  \end{tabular}
  \end{footnotesize}

\end{table}

\begin{table}
  \caption[Summary methods for collections of spectra]{Summary methods for collections of spectra. Key: + available, -- not available, f available in the future.}\label{tab:summaries:mspct}
  \centering
  \begin{footnotesize}
  \begin{tabular}{>{\ttfamily}lcccccc}
    \toprule
    \textnormal{methods} & source & response & filter & reflector & object & chroma \\
    \midrule
    f\_mspct & + & + & + & + & + & + \\
    \midrule
    irrad, e\_irrad, q\_irrad & + & -- & -- & -- & -- & -- \\
    fluence, e\_fluence, q\_fluence & + & -- & -- & -- & -- & -- \\
    ratio, e\_ratio, q\_ratio & + & -- & -- & -- & -- & -- \\
    qe\_ratio, eq\_ratio & + & -- & -- & -- & -- & -- \\
    response, e\_response, q\_response & -- & + & -- & -- & -- & -- \\
    transmittance & -- & -- & + & -- & + & -- \\
    absorptance & -- & -- & + & -- & + & -- \\
    absorbance & -- & -- & + & -- & + & -- \\
    range, min, max & + & + & + & + & + & + \\
    stepsize, spread, midpoint & + & + & + & + & + & + \\
    labels & -- & -- & -- & -- & -- & -- \\
    summary & -- & -- & -- & -- & -- & -- \\
    peaks & f & f & f & f & f & f \\
    valleys & f & f & f & f & f & f \\
    integrate\_spct & f & f & f & f & f & f \\
    average\_spct & f & f & f & f & f & f \\
    color & f & f & f & f & f & f \\
    \bottomrule
  \end{tabular}
  \end{footnotesize}

\end{table}

\subsection{Summary}

Specialized definitions of \texttt{summary} and the corresponding \texttt{print} methods are available for spectral objects. In the case of \texttt{source\_spct} objects the \texttt{time.unit} attribute makes it possible to print the summary using the correct units.

<<>>=
summary(sun.spct)
@

<<>>=
summary(sun.spct * CIE())
@

<<>>=
summary(sun.daily.spct)
@

\subsection{Wavelength}

\subsubsection{Individual spectra}

Functions \texttt{integrate\_spct} and \texttt{average\_spct} take into account each individual wavelength step, so they return valid results even for spectra measured at arbitrary and varying wavelength steps. They operate on every numeric column in the spectrum object given as argument.

<<>>=
integrate_spct(sun.spct)
average_spct(sun.spct)
@

The `usual' and a couple of new summary functions are available for spectra, but redefined to return wavelength based summaries in nanometres (nm).

<<>>=
range(sun.spct)
min(sun.spct)
max(sun.spct)
midpoint(sun.spct)
spread(sun.spct)
stepsize(sun.spct)
@

Function \texttt{stepsize} computes the size of every single step in the spectrum, and returns the range of these values. In the example above for a simulated spectrum the step size is uniform, but in data from array spectrometers this is not the norm.

<<>>=
stepsize(sun_May_morning.spct)
@

\subsubsection{Collections of spectra}

\begin{framed}
Not all summary methods are yet implemented for collections of spectra, because this is a new set of classes, just added to the package. See Table \ref{tab:summaries:mspct} where methods be implemented in the \emph{future} are marked with `f'. Functions \texttt{f\_mspct} or \texttt{plyr::ldply} can be used to apply a function to all the spectra in a collection and obtain the results in a data frame object. Other \emph{apply} functions or \texttt{for} loops can also be used if needed.
\end{framed}

Collections of spectra can be useful not only for time-series of spectra or spectral images, but also when dealing with a small group of related spectra. In the example below we show how to use a collection of spectra for calculating summaries. The spectra in a collection do \textbf{not} need to have been measured at the same wavelength values, or have the same number of rows or even of columns. Consequently, in many cases applying the wavelength summary functions described above to collections of spectra can be useful. The value returned is a data frame, with a number of data columns equal to the length of the returned value by the corresponding method for individual spectra.

<<>>=
filtered_sun <-
  source_mspct(
    lapply(list(none = clear.spct,
                ug1 = ug1.spct, ug11 = ug11.spct,
                gg400 = gg400.spct,
                og550 = og550.spct,
                rg665 = rg665.spct, rg830 = rg830.spct),
           `*`,
           y = sun.spct))
range(filtered_sun)
@


\subsection{Peaks and valleys}

\subsubsection{Individual spectra}

Functions \texttt{peaks} and \texttt{valleys} take spectra as first argument and return a subset of the spectral object data corresponding to local maxima and local minima of the measured variable. \texttt{span} defines the width of the `window' used as a number of observations.

<<>>=
peaks(sun.spct, span = 51)
valleys(sun.spct, span = 51)
@

In the case of \texttt{source\_spct} and \texttt{response\_spct} methods \texttt{unit.out} can be used to force peaks to be searched using either energy or photon based spectral irradiance. The default is energy, or the option \texttt{"photobiology.radiation.unit"} if set.

<<>>=
peaks(sun.spct, span = 51, unit.out = "photon")
@

In the case of \texttt{filter\_spct} methods \texttt{unit.out} can be used to force peaks to be searched using either spectral transmittance or spectral absorbance. The default is transmittance, or the option
\texttt{"photobiology.filter.qty"} if set.

<<>>=
peaks(ug1.spct)
peaks(ug1.spct, filter.qty = "absorbance")
valleys(ug1.spct, filter.qty = "absorbance")
@

It is possible to approximately set the width of the windows in nanometres by using function \texttt{step\_size}. As \texttt{stepsize} returns a range, we use \texttt{mean} in this example, although one could also use an index (1 or 2), or \texttt{min} or \texttt{max} depending on needs.

<<>>=
peaks(sun.spct, span = 21 / mean(stepsize(sun.spct)))
@

Low level functions \texttt{find\_peaks}, \texttt{get\_peaks} and \texttt{get\_valleys} take numeric vectors as arguments.

\subsection{Irradiance}

\subsubsection{Individual spectra}

The code using \texttt{spct} objects is simple, to integrate the whole spectrum we can use

<<>>=
irrad(sun.spct)
@

and, to integrate a range of wavelength, in the example, photosynthetically active radiation, we use \texttt{PAR()} that is a predefined waveband constructor.

<<>>=
irrad(sun.spct, PAR(), unit.out = "energy") # W m-2
irrad(sun.spct, PAR(), unit.out = "photon") # mol s-1 m-2
irrad(sun.spct, PAR(), unit.out = "photon") * 1e6 # umol s-1 m-2
@

The default for \texttt{irrad}, when no argument \texttt{unit.out} is supplied, is to return the irradiance value in energy irradiance units, unless the R option \texttt{photobiology.radiation.unit} is set.

<<>>=
irrad(sun.spct, PAR()) # W m-2
options(photobiology.radiation.unit = "photon")
irrad(sun.spct, PAR()) # mol s-1 m-2
options(photobiology.radiation.unit = NULL)
@

\sloppy
Functions \texttt{e\_irrad} and \texttt{q\_irrad} save some typing, and always return the same type of spectral irradiance quantity, independently of global option \texttt{photobiology.radiation.unit}.

<<>>=
e_irrad(sun.spct, PAR()) # W m-2
q_irrad(sun.spct, PAR()) * 1e6 # umol s-1 m-2
q_irrad(sun.daily.spct, PAR()) # mol d-1 m-2
@

It is also possible to supply a time unit to use as basis of expression for the returned value, but be aware that conversion into a loger time unit is only valid for sources like lamps, which have an output the remains constant in time.

<<>>=
irrad(sun.spct, PAR(), time.unit = "hour")
irrad(sun.spct, PAR(), time.unit = duration(8, "hours"))
@

Using a shorter time unit than the original, yields an average value re-expressed on a new time unit base.

<<>>=
irrad(sun.daily.spct, PAR(), time.unit = "second")
@

We can use predefined waveband constructors, waveband objects, or define wavebands on the fly.

<<>>=
my_par <- PAR()
e_irrad(sun.spct, my_par) # W m-2
e_irrad(sun.spct, waveband(c(400,700))) # W m-2
@

Lists of wavebands are also accepted as argument.

<<>>=
e_irrad(sun.spct, list(CIE(), CIE(298), CIE(300))) # W m-2 (BE)
my_wavebands <- list(Red(), Blue(), Green())
e_irrad(sun.spct, my_wavebands) # W m-2
@

These functions have an additional argument \texttt{quantity}, with default \texttt{"total"}, which can take values controlling the output.

<<>>=
irrad(sun.spct, UV_bands())
irrad(sun.spct, UV_bands(), quantity = "total")
irrad(sun.spct, UV_bands(), quantity = "contribution")
irrad(sun.spct, UV_bands(), quantity = "contribution.pc")
irrad(sun.spct, UV_bands(), quantity = "relative")
irrad(sun.spct, UV_bands(), quantity = "relative.pc")
irrad(sun.spct, UV_bands(), quantity = "average")
@

\subsubsection{Collections of spectra}

Collections of spectra can be useful not only for time-series of spectra or spectral images, but also when dealing with a small group of related spectra. In the example below we show how to use a collection of spectra for estimating irradiances under different filters set up in sunlight.

One thing to remember, is that operators in R are just functions with special names and call syntax. They can also be called with the usual function call syntax by enclosing their \emph{name} in backquotes. We use this trick to use the multiplication operator \texttt{`*`} in a call to \texttt{lapply} which returns a list, which we convert into a \texttt{source\_multi\_spct} object. After this we just call the \texttt{irrad} method on the \emph{collection of spectra} and obtain the result as a data frame with one row per spectrum and one column by waveband.

<<>>=
filtered_sun <-
  source_mspct(
    lapply(list(none = clear.spct,
                ug1 = ug1.spct, ug11 = ug11.spct,
                gg400 = gg400.spct,
                og550 = og550.spct,
                rg665 = rg665.spct, rg830 = rg830.spct),
           `*`,
           y = sun.spct))
irrad(filtered_sun, list(UVA(), VIS()))
@

\subsubsection{Numeric vectors}

The code using numeric vectors is more complicated, but adds some additional flexibility. Under normal circumstances it is easier to use the functions described above.

Function \texttt{irradiance} takes an array of wavelengths (sorted in strictly increasing order), and the corresponding values of spectral irradiance. By default the input is assumed to be in energy units, but parameter \texttt{unit.in} cab be used to adjust the calculations to expect photon units. The type of unit used for the calculated irradiance (or exposure) is set by the parameter \texttt{unit.out} with no default. If no \texttt{w.band} parameter is supplied, the whole spectrum spectrum input is used, unweighted, to calculate the total irradiance. If a \texttt{w.band} is supplied, then the range of wavelengths specified and SWF if present are used for calculating the irradiance. If the waveband definition does not include a SWF, then the unweighted irradiance is returned, if the definition includes a SWF, then a weighted irradiance is returned.

The functions \texttt{photon\_irradiance()} and \texttt{energy\_irradiance()}, just call \texttt{irradiance()} with the \texttt{unit.out} set to \texttt{"photon"} or \texttt{"energy"} respectively.

The functions taking numerical vectors as arguments can be used with data stored as vectors, or using \texttt{with} with data frames, data tables, lists, and spectra objects.

<<>>=
with(sun.data, photon_irradiance(w.length, s.e.irrad, PAR()))
with(sun.spct, photon_irradiance(w.length, s.e.irrad, PAR()))
@

Lists of wavebands are also accepted as argument.

<<>>=
with(sun.data, energy_irradiance(w.length, s.e.irrad, list(CIE(), CIE(298), CIE(300))))
my_wavebands <- list(Red(), Blue(), Green())
with(sun.data, energy_irradiance(w.length, s.e.irrad, my_wavebands))
@

The recommended practice is to use \texttt{with}, as above.

\sloppy
The are also available convenience functions for calculating how `total' irradiance is split among different contiguous bands
of the spectrum. The functions \texttt{split\_photon\_irradiance()} and \texttt{split\_energy\_irradiance()}, just call \texttt{split\_irradiance()} with the \texttt{unit.out} set to \texttt{"photon"} or \texttt{"energy"} respectively.

<<>>=
with(sun.data,
     split_energy_irradiance(w.length, s.e.irrad,
                             c(300, 400, 500, 600, 700, 800))
)
with(sun.data,
     split_energy_irradiance(w.length, s.e.irrad,
                             c(400, 500, 600, 700),
                             scale = "percent")
)
with(sun.data,
     split_photon_irradiance(w.length, s.e.irrad,
                             c(400, 500, 600, 700),
                             scale = "percent")
)
@

\subsection{Fluence}

The code using \texttt{spct} objects is simple, to integrate the whole spectrum we can use code similar to that for irradiances, but we need to always supply \texttt{exposure.time} as it has no default. The exposure time is a \texttt{lubridate::duration}, but any argument accepted by \texttt{as.duration} can also be used.

<<>>=
fluence(sun.spct, exposure.time = duration(1, "hours"))
fluence(sun.spct, exposure.time = 3600) # seconds
fluence(sun.spct, exposure.time = hms("01:00:00"))
@

and, to integrate a range of wavelengths, in the example, photosynthetically active radiation, we use \texttt{PAR()} that is a predefined waveband constructor.

<<>>=
fluence(sun.spct, PAR(), unit.out = "photon",
        exposure.time = duration(1, "hours"))
@

<<>>=
fluence(sun.spct, CIE(),
        exposure.time = duration(30, "minutes"))
@

<<>>=
fluence(sun.spct, CIE(),
        exposure.time = duration(0.5, "hours"))
@

\subsection{Photon and energy ratios}

\subsubsection{Individual spectra}

The functions described here, in there simplest use, calculate a ratio between two wavebands. The function \texttt{q\_ratio} returning photon ratios. However both waveband parameters can take lists of wavebands as arguments, with normal recycling rules in effect.

<<>>=
q_ratio(sun.spct, UVB(), PAR())
q_ratio(sun.spct,
        list(UVC(), UVB(), UVA()),
        UV())
q_ratio(sun.spct,
        UVB(),
        list(UV(), PAR()))
@

Function \texttt{e\_ratio} returns energy ratios.

<<>>=
e_ratio(sun.spct, UVB(), PAR())
e_ratio(sun.spct,
        list(UVC(), UVB(), UVA()),
        UV())
@

Function \texttt{qe\_ratio}, has only one waveband parameter, and returns the `photon' to `energy' ratio,

<<>>=
qe_ratio(sun.spct, PAR())
qe_ratio(sun.spct, list(Blue(), Green(), Red()))
@

Function \texttt{eq\_ratio}, has only one waveband parameter, and returns the `energy' to `photon' ratio,

<<>>=
eq_ratio(sun.spct, PAR())
eq_ratio(sun.spct, list(Blue(), Green(), Red()))
@

If we would like to calculate a conversion factor between PPFD (PAR photon irradiance in mol s-1 m-2) and PAR (energy) irradiance (W m-2) for a light source for which we have spectral data we could use the following code.

<<example-ratios-02>>=
conv.factor <- qe_ratio(sun.spct, PAR())

PPFD.mol.photon <- 1000e-6
PAR.energy <- PPFD.mol.photon / conv.factor
conv.factor
PPFD.mol.photon * 1e6
PAR.energy
@

\subsubsection{Collections of spectra}

<<>>=
q_ratio(filtered_sun, list(UVB(), UVA()), PAR())
@

\subsubsection{Vectors}

The function \texttt{waveband\_ratio()} takes basically the same parameters as \texttt{irradiance}, but two waveband definitions instead of one, and two \texttt{unit.out} definitions instead of one. This is the base function used in all the vector based `ratio' functions in the \PB package.

\sloppy
The derived functions are: \texttt{photon\_ratio()}, \texttt{energy\_ratio()}, and \texttt{photons\_energy\_ratio}.

In contrast to the functions described in the previous section, these functions only accept individual waveband definitions (not lists of them).

If for example we would like to calculate the ratio between UVB and PAR radiation, we would use either
of the following function calls, depending on which type of units we desire.

<<example-ratios-01>>=
with(sun.data,
     photon_ratio(w.length, s.e.irrad, UVB(), PAR())
)
with(sun.data,
     energy_ratio(w.length, s.e.irrad, UVB(), PAR())
)
@

\subsection{Normalized difference indexes}

\subsection{Individual spectra}

These indexes are frequently used to summarize reflectance data, for example in remote rensing the NDVI (normalized difference vegetation index). Here we give an \emph{unusual} example to demonstrate that function \texttt{normalized\_diff\_ind()} can be used to calculate, or define any similar index.

<<>>=
normalized_diff_ind(sun.spct,
                    waveband(c(400, 700)), waveband(c(700, 1100)),
                    irrad)
@

\subsection{Transmittance, reflectance, absorptance and absorbance}

\subsubsection{Individual spectra}

The functions \texttt{transmittance}, and \texttt{absorbance} take \texttt{filter\_spct} as argument, while function \texttt{reflectance} takes \texttt{reflector\_spct} objects as argument. Functions \texttt{transmittance}, \texttt{reflectance} and \texttt{absorptance} are implemented for \texttt{object\_spct}. They return as default an average value for these quantities \textbf{assuming} a light source with a flat spectral energy output.

<<>>=
transmittance(polyester.new.spct, list(UVB(), UVA(), PAR()))
@

<<>>=
transmittance(Solidago_lower_adax.spct, Plant_bands())
@

<<>>=
reflectance(Solidago_lower_adax.spct, Plant_bands())
@

<<>>=
absorptance(Solidago_lower_adax.spct, Plant_bands())
@

<<>>=
reflectance(gold.spct, VIS_bands())
@

Function \texttt{transmittance} has an additional argument \texttt{quantity}, with default \texttt{"average"}, which can take values controlling the output.

<<>>=
transmittance(polyester.new.spct, UV_bands())
transmittance(polyester.new.spct, UV_bands(), quantity = "total")
transmittance(polyester.new.spct, UV_bands(), quantity = "contribution")
transmittance(polyester.new.spct, UV_bands(), quantity = "contribution.pc")
transmittance(polyester.new.spct, UV_bands(), quantity = "relative")
transmittance(polyester.new.spct, UV_bands(), quantity = "relative.pc")
transmittance(polyester.new.spct, UV_bands(), quantity = "average")
@

An equivalent function returning absorbance instead of transmittance takes the same arguments as \texttt{transmittance}.

<<>>=
absorbance(polyester.new.spct, list(UVB(), UVA(), PAR()))
@

Function \texttt{absorbance} also has an additional argument \texttt{quantity}, with default \texttt{"average"}, which can take values controlling the output.

<<>>=
transmittance(polyester.new.spct, UV_bands())
transmittance(polyester.new.spct, UV_bands(), quantity = "total")
transmittance(polyester.new.spct, UV_bands(), quantity = "contribution")
transmittance(polyester.new.spct, UV_bands(), quantity = "contribution.pc")
transmittance(polyester.new.spct, UV_bands(), quantity = "relative")
transmittance(polyester.new.spct, UV_bands(), quantity = "relative.pc")
transmittance(polyester.new.spct, UV_bands(), quantity = "average")
@

It is more likely that we would like to calculate these values with reference to light of a certain spectral quality. This needs to be calculated by hand, which is not difficult. For example, for UV-B, which we can
calculate, either by trimming the waveband as shown here, or by extending the sun spectrum with zeros.

<<>>=
tr.UVB <- trim_waveband(UVB(), sun.spct, trim = TRUE)
irrad(sun.spct * polyester.new.spct, tr.UVB) /
                            irrad(sun.spct, tr.UVB) * 100
@

And for a list of wavebands, as percentages.

<<>>=
irrad(sun.spct * polyester.new.spct, list(UVB(), UVA(), PAR()), wb.trim = TRUE) /
  irrad(sun.spct, list(UVB(), UVA(), PAR()), wb.trim = TRUE) * 100
@

\subsubsection{Collections of spectra}

Here we construct a collection of filter spectra, and then we calculate the transmittance of these filters for two wavebands, obtaining the results as a data frame, with one row per filter, and one column per waveband.

<<>>=
filters <-
  filter_mspct(
    list(clear = clear.spct,
         ug1 = ug1.spct, ug11 = ug11.spct,
         gg400 = gg400.spct,
         og550 = og550.spct,
         rg665 = rg665.spct, rg830 = rg830.spct))
transmittance(filters, list(UVA(), VIS()))
@

\subsection{Integrated response}

\subsubsection{Individual spectra}

The functions  \texttt{response}, \texttt{e\_response} and \texttt{q\_response} take \texttt{response\_spct} objects as arguments, and return the integrated value for each waveband (integrated over wavelength) \textbf{assuming} a light source with a flat spectral energy or photon output respectively.

If no waveband is supplied as argument, the whole spectrum is integrated.

<<>>=
response(Vital_BW_20.spct)
e_response(Vital_BW_20.spct)
@

<<>>=
q_response(Vital_BW_20.spct) * 1e-6
@

When a waveband, or list of wavebands, is supplied the response is calculated for the wavebands.

<<>>=
e_response(Vital_BW_20.spct, UVB())
q_response(Vital_BW_20.spct, UVB()) * 1e-6
@

<<>>=
e_response(Vital_BW_20.spct, list(UVB(), UVA()))
@

This function has an additional argument \texttt{quantity}, with default \texttt{"total"}, which can take values controlling the output.

<<>>=
response(Vital_BW_20.spct, UV_bands())
response(Vital_BW_20.spct, UV_bands(), quantity = "total")
response(Vital_BW_20.spct, UV_bands(), quantity = "contribution")
response(Vital_BW_20.spct, UV_bands(), quantity = "contribution.pc")
response(Vital_BW_20.spct, UV_bands(), quantity = "relative")
response(Vital_BW_20.spct, UV_bands(), quantity = "relative.pc")
response(Vital_BW_20.spct, UV_bands(), quantity = "average")
@

If we would like to calculate these values with reference to light of a certain spectral irradiance. This can be achieved by multiplying the sensor's spectral responsivity by the light source spectral irradiance.

<<>>=
e_response(sun.spct * Vital_BW_20.spct, UVB())
q_response(sun.spct * Vital_BW_20.spct, UVB()) * 1e-6
@

And for a list of wavebands

<<>>=
q_response(sun.spct * KIPP_PQS1_PAR_quantum.spct, list(UVA(), PAR())) * 1e-6
@

\subsubsection{Collections of spectra}

<<>>=
sensors <-
  response_mspct(
    list(BW20 = Vital_BW_20.spct,
         Berger = Berger_UV_erythemal.spct))
response(sensors, list(UVC(), UVB(), UVA()), quantity = "contribution")
@

\subsection{Integration over wavelengths}

When we need to integrate some \emph{non-standard} \texttt{numeric} variable stored in a spectral object we can use functions \texttt{integrate\_spct} or \texttt{average\_spct}.

\subsubsection{Calculation from individual spectra}

We can integrate the values of arbitrary \texttt{numeric} columns other than \texttt{w.length} in an spectral object. All spectral classes are derived from \texttt{generic\_spct}, so the examples in this section apply to objects of any of the derived spectral classes as well.

<<>>=
integrate_spct(sun.spct)
integrate_spct(sun.spct * UVA())
e_irrad(sun.spct, UVA(), use.hinges = TRUE)
@

The function \texttt{integrate\_spct} integrates every column holding numeric values from a spectrum object, except for \texttt{w.length}, returning a total value no longer expressed per nanometre.

<<>>=
my.sun.spct <- copy(sun.spct)
my.sun.spct[ , one := 1L]
integrate_spct(my.sun.spct)
spread(sun.spct)
@

In the simple example above, the integral of \texttt{one} gives us the span in nanometres of the spectrum.

The function \texttt{average\_spct} integrates every column holding numeric values from a spectrum object, except for \texttt{w.length}, and divides the result by the \emph{spread} or width of the wavelength range integrated, returning a value expressed in the same units as the spectral data.

<<>>=
average_spct(my.sun.spct)
@

\section{Handling `noisy' spectral data}

The first thing to do is to think whether any part of the spectral measurements can be \textit{a priori} known to be equal to zero. For example for the solar spectrum at ground level it is safe to assume that the spectral irradiance is zero for all wavelengths shorter than 290~nm. If the data are noisy, it is best to discard these data before calculating any effective UV doses.

Another possibility is do smoothing of the spectral data using one a series of possible algorithms. Smoothing can distort the spectrum because distinguishing between real peaks and valleys from noise is difficult.

A third possibility is, when replicate measurements are available, to calculate "parallel" means, medians or other summary quantities, at each value of wavelength.

We will discuss these three approaches in each of the sections below.

\subsubsection{Trimming of noisy regions}

In the following example we use a longer wavelength (297~nm) just to show how the function works, because the example spectral data set starts at 293~nm.

<<example-sun>>=
head(sun.spct, 2L)
@

Sub-setting can be easily done as follows if the data are in a data.frame (of course, replacing \texttt{w.length} with the name used in your data frame for the wavelengths array):

<<example-trim-noise>>=
trimmed.sun.spct <- trim_spct(sun.spct, low.limit = 297)
head(trimmed.sun.spct, 2L)
@

The code above deletes the data outside the limits. However, if we supply a different value than the default NULL for the parameter \texttt{fill}, the w.length values are kept, and the trimmed spectral irradiance values replaced by the value supplied.

<<example-set-na>>=
trimmed.sun.spct <- trim_spct(sun.spct, low.limit = 297, fill = NA)
head(trimmed.sun.spct, 2L)
@

The code above sets the spectral irradiance values for wavelengths outside the limits to \texttt{NA}, but, for example when plotting, it is useful to replace the noise in the spectrum with zeros.

<<example-set-zero>>=
trimmed.sun.spct <- trim_spct(sun.spct, low.limit = 297, fill = 0)
head(trimmed.sun.spct, 2L)
@

After `cleaning' the data we just use the trimmed ($\approx$ sub-setted) spectral data object in further calculations or plotting.

If the data are in a data frame, instead of a spct object then \texttt{subset} or indexing can be used. If the data are available as vectors, different options: 1) create a data frame from your data, 2) use the function \texttt{trim\_tails()} from this package, or 3) just use R commands. Here we give examples of the use of \texttt{trim\_tails()}, using the same data as in earlier examples. First we `trim' (delete) all data for wavelengths shorter than 293~nm.

\subsubsection{Smoothing}

Function \texttt{smooth\_spct} can be used to smoothen noise in spectra. Smoothing is effective in removing noise, but in case of spectra with a fine structure like the one for sunlight, the details of real peaks and valleys are also smoothed out. Smoothing should be used with great care as it can cause bias and distort the shape of spectra.

We first generate a noisy solar spectrum by adding random noise to a noiseless solar spectrum. We will use this data to demonstrate smoothing.

<<noisy-solar, fig.width=7, fig.height=4, warning=TRUE, purl=FALSE>>=
noisy.sun.spct <- sun.spct +
  rnorm(length(sun.spct$w.length), sd = 0.04) *
  irrad(sun.spct, quantity = "average")
plot(sun.spct) + labs(title = "Noiseless solar spectrum")
plot(noisy.sun.spct) + labs(title = "Noisy solar spectrum")
@


The default \texttt{"custom''} method is our own, and is suitable for small amounts of noise, as it only applies smoothing to low signal regions of the spectrum, and also forces to zero those regions which are `detected' to contain mostly noise. The strength parameter should be used to adjust the sensitivity to noise according to the signal-to-noise ratio in the spectral data. This algorithm is quite safe, and tends to preserve most of the fine structure of spectra.

<<smooth-custom, fig.width=7, fig.height=4>>=
plot(smooth_spct(noisy.sun.spct))  +
  labs(title = "Noisy solar spectrum: custom smoothing")
@

Methods \texttt{"lowess"} and \texttt{"supsmu"} are general purpose methods, which with their default values for the parameters tend to smooth spectra very aggressively. They remove a significant portion of the spectral detail but could be useful when the data is very noisy or when the overall shape of a spectrum is of interest rather than the finer structure.

<<smooth-lowess, fig.width=7, fig.height=4>>=
plot(smooth_spct(noisy.sun.spct, method = "lowess"))  +
  labs(title = "Noisy solar spectrum: lowess smoothing")
@

<<smooth-supsmu, fig.width=7, fig.height=4>>=
plot(smooth_spct(noisy.sun.spct, method = "supsmu"))  +
  labs(title = "Noisy solar spectrum: supsmu smoothing")
@

Stronger or weaker smoothing is also possible.

<<smooth-custom-10, fig.width=7, fig.height=4>>=
plot(smooth_spct(noisy.sun.spct, method = "supsmu", strength = 10))  +
  labs(title = "Noisy solar spectrum: supsmu smoothing, strength = 10")
@


Function \texttt{smooth\_spct} is generic with specializations for \texttt{source\_spct}, \texttt{filter\_spct}, \texttt{reflector\_spct}, and \texttt{response\_spct}.

\subsubsection{Parallel averaging and summaries}

It is quite easy to calculate `parallel' summary quantities using \texttt{data.table} syntax and function \texttt{rbindspct}. However, one should be careful with the handling of \texttt{NA} values, and specially make sure that all spectra have values for spectral irradiance at the same wavelengths. Similar code to that given in this section, using \texttt{source\_spct} objects, can be used for \texttt{filter\_spct}, \texttt{reflector\_spct}, and \texttt{response\_spct} objects.

For the \texttt{source\_spct} example we generate four independent noisy replicates of the same solar spectrum, to demonstrate parallel summaries. Under normal use we would use \texttt{rbindspct} to bind the different true replicate measured spectra.

<<four-noisy-solar, fig.width=7, fig.height=4>>=
bound.spct <- rbindspct(list(sun.spct, sun.spct, sun.spct, sun.spct),
                        idfactor = "ID")

noisy.sun.spct <- bound.spct +
  rnorm(length(bound.spct$w.length), sd = 0.05) *
  irrad(sun.spct, quantity = "average")

raw.data.fig <- ggplot(noisy.sun.spct, aes(w.length, s.e.irrad, colour = ID)) +
  geom_point(alpha = 0.33)
raw.data.fig
@

<<parallel-simple-1, fig.width=7, fig.height=4>>=

mean.spct <- bound.spct[ , .(s.e.irrad = mean(s.e.irrad, na.rm = TRUE)),
                        by = w.length]
setSourceSpct(mean.spct)
mean.spct

mean.fig <- raw.data.fig + geom_line(data = mean.spct, colour = "black")
mean.fig

plot(mean.spct)
@

<<parallel-simple-2>>=
median.spct <- bound.spct[ , .(s.e.irrad = median(s.e.irrad, na.rm = TRUE)),
                          by = w.length]
setSourceSpct(median.spct)
median.spct
@

If the wavelength values in the different spectra are not the same, or if NAs are present, this slightly more complex code will make diagnosis of any problems much easier, and the resulting spectrum will still behave as a \texttt{source\_spct} object when applying any other functions.

<<parallel-multiple-1>>=
meanx.spct <- bound.spct[ , .(s.e.irrad = mean(s.e.irrad, na.rm = TRUE),
                              sd = sd(s.e.irrad, na.rm = TRUE),
                              n = length(na.omit(s.e.irrad)),
                              n.na = sum(is.na(s.e.irrad))
                              ), by = w.length]
setSourceSpct(meanx.spct)
meanx.spct
@

<<parallel-multiple-2>>=
medianx.spct <- bound.spct[ , .(s.e.irrad = median(s.e.irrad, na.rm = TRUE),
                                mad = mad(s.e.irrad, na.rm = TRUE),
                                n = length(na.omit(s.e.irrad)),
                                n.na = sum(is.na(s.e.irrad))
                                ), by = w.length]
setSourceSpct(medianx.spct)
medianx.spct
@

The two code chunks above can be easily modified as needed, but they do not preserve all the attributes of the original spectra.

\section{Astronomy}

\subsection{Position of the sun}

In photobiology research we sometimes need to calculate the position on the sun at arbitrary locations and positions. The function \texttt{sun\_angles} returns the azimuth in degrees eastwards, altitude in degrees above the horizon, solar disk diameter in degrees and sun to earth distance in astronomical units. The time should be a \texttt{POSIXct} vector, possibly of length one, and it is easiest to use package \texttt{lubridate} for working with time and dates.

<<>>=
sun_angles(now(), lat = 34, lon = 0)
sun_angles(ymd_hms("2014-01-01 0:0:0", tz = "UTC"))
@

\subsection{Times of sunrise, solar noon and sunset}

Functions \texttt{sunrise\_time}, \texttt{sunset\_time}, \texttt{noon\_time}, \texttt{day\_length} and \texttt{night\_length} have all the same parameter signature. In addition, function \texttt{day\_night} returns a list containing all the quantities returned by the other functions. They are all vectorized for the
\texttt{date} parameter.

We create a vector of dates to use in the examples---default time zone of \texttt{ymd} is UTC or GMT.

<<>>=
dates <- seq(from = ymd("2015-03-01"), to = ymd("2015-07-1"), length.out = 3)
@

Default latitude is zero (the Equator), the default longitude is zero (Greenwich), and default time zone for the functions in the \texttt{photobiology} package is \texttt{"UTC"}. Be also aware that for summer dates the times are expressed accrodingly. In the examples below this can be recognized for example, by the time zone being reported as EEST instead of EET for Eastern Europe.

<<>>=
noon_time(dates, tz = "UTC", lat =  60)
noon_time(dates, tz = "CET", lat =  60)
@

<<>>=
day_night(dates, lat =  60)
@

The default for \texttt{date} is the current day.

<<>>=
sunrise_time(lat = 60)
@

Both latitude and longitude can be supplied, but be aware that if the returned value is desired in the local time coordinates, the time zone should match the longitude.

<<>>=
sunrise_time(today(tzone = "UTC"), tz = "UTC", lat = 60, lon = 0)
sunrise_time(today(tzone = "EET"), tz = "EET", lat = 60, lon = 25)
@

Southern hemisphere latitudes are given as negative numbers.

<<>>=
sunrise_time(dates, lat =  60)
sunrise_time(dates, lat = -60)
@

The angle used in the twilight calculation can be supplied, either as the name of a standard definition, or as an angle in degrees (negative for sun positions below the horizon). Positive angles can be used when the time of sun occlusion behind a building, mountain, or other obstacle needs to be calculated.

<<>>=
sunrise_time(today(tzone = "EET"), tz = "EET", lat = 60, lon = 25,
             twilight = "civil")
sunrise_time(today(tzone = "EET"), tz = "EET", lat = 60, lon = 25,
             twilight = -10)
sunrise_time(today(tzone = "EET"), tz = "EET", lat = 60, lon = 25,
             twilight = +12)
@

Parameter \texttt{unit.out} can be used to obtain the returned value expresed as time-of-day in hours, minutes, or seconds since midnight.

<<>>=
sunrise_time(today(tzone = "EET"), tz = "EET", lat = 60, lon = 25,
             unit.out = "hour")
@

Functions \texttt{day\_length} and \texttt{night\_length} return by default the length of time in hours.

<<>>=
day_length(dates, lat = 60)
night_length(dates, lat = 60)
@

Function \texttt{day\_night} returns a list.

<<>>=
day_night(dates, lat = 60)
day_night(dates, lat = 60, unit.out = "hour")
@

\section{RGB colours}

Two functions allow calculation of simulated colour of light sources as R colour definitions. Three different functions are available, one for monochromatic light taking as argument wavelength values, and one for polychromatic light taking as argument spectral energy irradiances and the corresponding wave length values. The third function can be used to calculate a representative RGB colour for a band of the spectrum represented as a range of wavelength, based on the assumption of a flat energy irradiance across the range.
By default CIE coordinates for \textit{typical} human vision are used, but the functions
have a parameter that can be used for supplying a different chromaticity definition.

Examples for monochromatic light:

<<>>=
w_length2rgb(550) # green
w_length2rgb(630) # red
w_length2rgb(380) # UVA
w_length2rgb(750) # far red
w_length2rgb(c(550, 630, 380, 750)) # vectorized
@


Examples for wavelength ranges:

<<>>=
w_length_range2rgb(c(400,700))
w_length_range2rgb(400:700)
w_length_range2rgb(sun.spct$w.length)
w_length_range2rgb(550)
@

Examples for spectra as vectors, in this case for the solar spectrum:

<<>>=
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens = ciexyzCMF2.spct))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens = ciexyzCMF10.spct))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens = ciexyzCC2.spct))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens = ciexyzCC10.spct))
@

Examples with \texttt{source\_spct} objects.

<<>>=
rgb_spct(sun.spct)
rgb_spct(sun.spct, sens = ciexyzCMF2.spct)
@

And also a \texttt{color} method for \texttt{source\_spct}.

<<>>=
color(sun.spct)
color(sun.spct * rg630.spct)
@

Here we plot the RGB colours for the range covered by the CIE 2006 proposed standard calculated at each 1 nm step:

<<>>=
wl <- c(390, 829)

my.colors <- w_length2rgb(wl[1]:wl[2])

colCount <- 40 # number per row
rowCount <- trunc(length(my.colors) / colCount)

plot( c(1,colCount), c(0,rowCount), type = "n", ylab = "", xlab = "",
      axes = FALSE, ylim = c(rowCount,0))
title(paste("RGB colours for", as.character(wl[1]),
            "to", as.character(wl[2]), "nm"))

for (j in 0:(rowCount-1))
{
  base <- j*colCount
  remaining <- length(my.colors) - base
  RowSize <- ifelse(remaining < colCount, remaining, colCount)
  rect((1:RowSize)-0.5,j-0.5, (1:RowSize)+0.5,j+0.5,
       border = "black",
       col = my.colors[base + (1:RowSize)])
}

@

Given a color in any of the above ways, yields RGB values that can be used to locate the position of any colour on Maxwell's triangle. Here using R's predefined colours.

<<>>=
colours <- c("red", "green", "yellow", "white", "orange",
             "blue", "pink", "purple")
rgb.values <- col2rgb(colours)
test.data <-
  data.frame(colour = colours,
             R = rgb.values[1, ], G = rgb.values[2, ], B = rgb.values[3, ])
maxwell.tern <- ggtern(data = test.data,
                       aes(x = R, y = G, z = B, label = colour, fill = colour)) +
  geom_point(shape = 21, size = 4) + geom_text(hjust = -0.3) +
  labs(x = "R", y = "G", z = "B") + scale_fill_identity()
maxwell.tern
@

We simulate the spectra of filtered sunlight by multiplying the solar spectrum by filter transmittance spectra.

<<>>=
yellow.light.spct <- canary.yellow.new.spct * sun.spct
green.light.spct <- moss.green.new.spct * sun.spct
polyester.light.spct <- polyester.new.spct * sun.spct
@

Now using the filtered sunlight spectra we calculate colours based on human vision photoreceptors.

<<>>=
coord <- 1 # CMF
yellow.filter <- color(yellow.light.spct)[coord]
green.filter <- color(green.light.spct)[coord]
polyester.filter <- color(polyester.light.spct)[coord]
colours <- c(yellow.filter, green.filter, polyester.filter)
rgb.values <- col2rgb(colours)
test.data <- data.frame(colour = colours,
                        R = rgb.values[1, ], G = rgb.values[2, ], B = rgb.values[3, ],
                        labels = c("canary yellow", "moss green", "polyester"))
maxwell.tern <- ggtern(data = test.data,
                       aes(x = R, y = G, z = B, fill = colour, label = labels)) +
  geom_point(shape = 21, size = 4) +
  geom_text(hjust = -0.15) +
  labs(x = "R", y = "G", z = "B")  +
  scale_fill_identity()
maxwell.tern
@


\section{Optimizing performance}

When developing the current version of \PB quite a lot of effort was spent in optimizing performance, especially of the functions accepting vectors as arguments, as in one of our experiments, we need to process several hundred thousands of measured spectra. The defaults should provide good performance in most cases, however, some further improvements are achievable, when a series of different calculations are done on the same spectrum, or when a series of spectra measured at exactly the same wavelengths are used for calculating weighted irradiances or exposures.

In the case of doing calculations repeatedly on the same spectrum, a small improvement in performance can be achieved by setting the parameter \texttt{check.spectrum = FALSE} for all but the first call to \texttt{irradiance()}, or \texttt{photon\_irradiance()}, or \texttt{energy\_irradiance()}, or the equivalent function for ratios. It is also possible to set this parameter to FALSE in all calls, and do the check beforehand by explicitly calling \texttt{check\_spectrum()}.

In the case of calculating weighted irradiances on many spectra having exactly the same wavelength values, then a significant improvement in the performance can be achieved by setting \texttt{use.cached.mult = TRUE}, as this reuses the multipliers calculated during successive calls based on the same waveband. However, to achieve this increase in performance, the tests to ensure that the wavelength values have not changed, have to be kept to the minimum. Currently only the length of the wavelength array is checked, and the cached values discarded and recalculated if the length changes. For this reason, this is not the default, and when using caching the user is responsible for making sure that the array of wavelengths has not changed between calls.

You can use the package \texttt{microbenchmark} to time the code and find the parts that slow it down. I have used it, and also
I have used profiling to optimize the code for speed. The choice of defaults is based on what is
best when processing a moderate number of spectra, say less than a few hundreds, as opposed to many thousands.

\section{Example data}

A few example spectra are included in this package for use in examples and vignettes, and testing (Tables \ref{tab:data:spct} and \ref{tab:data:chroma}).

\begin{table}
\centering
\caption{Data sets included in the package: spectra. The CIE standard illuminant data in this package are normalized to one at $\lambda = 560\,$nm, while in the CIE standard they are normalized to 100 at the same wavelength.}\label{tab:data:spct}
\begin{tabular}{llll}
\toprule
Object & class & units & data description \\
\midrule
sun.spct & source\_spct & \wattnm & solar spectral irradiance \\
sun.daily.spct & source\_spct & \jdaynm & solar spectral exposure \\
sun.data & data.frame & \wattnm & solar spectral irradiance \\
sun.daily.data & data.frame & \jdaynm & solar spectral exposure\\
D65.illuminant.spct & source\_spct & (norm. 560 nm) & CIE standard \\
A.illuminant.spct & source\_spct & (norm. 560 nm)  & CIE standard \\
\bottomrule
\end{tabular}
\end{table}


\begin{table}
\centering
\caption{Data sets included in the package: chromaticity data}\label{tab:data:chroma}
\begin{tabular}{lll}
\toprule
Object & class & data description \\
\midrule
ciexyzCC2.spct & chroma\_spct &  human chromaticity coordinates $2^\circ$ \\
ciexyzCC10.spct & chroma\_spct &   human chromaticity coordinates $10^\circ$  \\
ciexyzCMF2.spct & chroma\_spct &   human colour matching function $2^\circ$ \\
ciexyzCMF10.spct & chroma\_spct &  human colour matching function $10^\circ$ \\
ciev2.spct & chroma\_spct &  human luminous efficiency $2^\circ$ \\
ciev10.spct & chroma\_spct &   human luminous efficiency $10^\circ$ \\
beesxyzCMF.spct &  chroma\_spct &  bee colour matching function \\
\bottomrule
\end{tabular}
\end{table}


\end{document}
