%\VignetteEngine{knitr}
%\VignetteIndexEntry{User guide}
%\VignetteDepends{knitr, photobiology, photobiologyWavebands, photobiologySun, photobiologyFilters, photobiologyReflectors, photobiologySensors, lubridate}
%\VignetteKeyword{misc}

\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{bbding}
\usepackage{xspace}
\usepackage{framed}
\usepackage{array}
\usepackage[font={small,sf},labelfont=bf]{caption}

\newcommand{\PB}{\textsf{photobiology}\xspace}
\newcommand{\PBPla}{\textsf{photobiologyPlants}\xspace}
\newcommand{\PBFLT}{\textsf{photobiologyFilters}\xspace}
\newcommand{\PBSU}{\textsf{photobiologySun}\xspace}
\newcommand{\PBLA}{\textsf{photobiologyLamps}\xspace}
\newcommand{\PBLD}{\textsf{photobiologyLEDs}\xspace}
\newcommand{\PBSN}{\textsf{photobiologySensors}\xspace}
\newcommand{\PBWB}{\textsf{photobiologyWavebands}\xspace}

\newcommand{\UV}{UV\xspace}
\newcommand{\UVB}{UV-B\xspace}
\newcommand{\UVA}{UV-A\xspace}

\newcommand{\Unit}[1]{\ensuremath{\mathrm{#1}}\xspace}

\newcommand{\watt}{\Unit{W\,m^{-2}}}
\newcommand{\wattnm}{\Unit{W\,m^{-2}\,nm^{-1}}}
\newcommand{\mwattnm}{\Unit{mW\,m^{-2}\,nm^{-1}}}
\newcommand{\mol}{\Unit{mol\,m^{-2}\,s^{-1}}}
\newcommand{\molnm}{\Unit{mol\,m^{-2}\,s^{-1}\,nm^{-1}}}

\newcommand{\jday}{\Unit{J\,m^{-2}\,d^{-1}}}
\newcommand{\kjday}{\Unit{kJ\,m^{-2}\,d^{-1}}}
\newcommand{\jdaynm}{\Unit{J\,m^{-2}\,d^{-1}\,nm^{-1}}}
\newcommand{\molday}{\Unit{molday\,m^{-2}\,d^{-1}}}
\newcommand{\moldaynm}{\Unit{mol\,m^{-2}\,d^{-1}\,nm^{-1}}}

\newcommand{\jtot}{\Unit{J\,m^{-2}}}
\newcommand{\kjtot}{\Unit{kJ\,m^{-2}}}
\newcommand{\jtotnm}{\Unit{J\,m^{-2}\,nm^{-1}}}
\newcommand{\moltot}{\Unit{molday\,m^{-2}}}
\newcommand{\moltotnm}{\Unit{mol\,m^{-2}\,nm^{-1}}}

\newcommand{\cps}{\Unit{\mathit{n}\,s^{-1}}}
\newcommand{\qresponse}{\Unit{\mathit{x}\,mol^{-1}\,s^{-1}}}
\newcommand{\eresponse}{\Unit{\mathit{x}\,J^{-1}\,s^{-1}}}
\newcommand{\qresponsenm}{\Unit{\mathit{x}\,mol^{-1}\,s^{-1}\,nm^{-1}}}
\newcommand{\eresponsenm}{\Unit{\mathit{x}\,J^{-1}\,s^{-1}\,nm^{-1}}}

\newcommand{\qresponseday}{\Unit{\mathit{x}\,mol^{-1}\,d^{-1}}}
\newcommand{\eresponseday}{\Unit{\mathit{x}\,J^{-1}\,d^{-1}}}
\newcommand{\qresponsedaynm}{\Unit{\mathit{x}\,mol^{-1}\,d^{-1}\,nm^{-1}}}
\newcommand{\eresponsedaynm}{\Unit{\mathit{x}\,J^{-1}\,d^{-1}\,nm^{-1}}}

\newcommand{\qresponsetot}{\Unit{\mathit{x}\,mol^{-1}}}
\newcommand{\eresponsetoto}{\Unit{\mathit{x}\,J^{-1}}}
\newcommand{\qresponsetotnm}{\Unit{\mathit{x}\,mol^{-1}\,nm^{-1}}}
\newcommand{\eresponsetotnm}{\Unit{\mathit{x}\,J^{-1}\,nm^{-1}}}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(fig.path='figure/pos-', fig.align='center', fig.show='hold',
               fig.width=7, fig.height=6, size="footnotesize")
# options(replace.assign=TRUE,width=60)
@

<<example-0-hiden, eval=TRUE, include=FALSE>>=
library(photobiology)
library(photobiologyWavebands)
library(photobiologySun)
library(photobiologyFilters)
library(photobiologyReflectors)
library(photobiologySensors)
library(lubridate)
@

<<own-set-up, echo=FALSE, include=FALSE>>=
my_version <- packageVersion("photobiology")
@

\title{\PB Version \Sexpr{my_version}\\ User Guide}
\author{Pedro J. Aphalo}

\maketitle

\tableofcontents

\section{Introduction}

\sloppy
We have developed a set of packages to
facilitate the calculation of many different quantities that can be derived from spectral irradiance data. The base package in this suite is called \PB, and is the package described here. There other specialized packages for quantification of ultraviolet radiation and visible radiation (\PBWB), or plant photoreceptors (\PBPla). Other packages in the suite provide example spectral data for filters (\PBFLT), lamps (\PBLA), LEDs (\PBLD), sunlight (\PBSU) and broadband sensors (\PBSN). In the future it will be submitted to CRAN (Comprehensive R archive network), it is meanwhile available from \url{https://www.r4photobiology.info/}. There is also a public Git repository at \url{https://bitbucket.org/aphalo/} from where the source code of the current an earlier versions can be cloned.

Package \PB provides two sets of functions for many operations: functions programmed following a functional paradigm, and functions using an object-oriented paradigm. The former functions take as arguments numeric vectors and are probably faster. The later ones take `spectra' objects as arguments, are easier to use, and at least at the moment, to some extent slower. For everyday use `spectra' objects are recommended, but when maximum performance or flexibility in scripts is desired, the use of the functions taking numeric vectors as arguments may allow optimizations that are not possible with the object-oriented higher level functions.

\section{Installation and use}

The functions in the package \PB are
made available by installing the packages \verb!photobiology! (once) and
loading it from the library when needed.

To load the package into the workspace we use \verb!library(photobiology)!.

<<example-0-hiden, eval=FALSE>>=
@

\section{Spectra}

This package defines a family of classes based on data frames which impose some restrictions on the naming of the vectors, something that allows methods and some functions to `find' the data when passed one of these objects as argument. In addition, as the data is checked when the object is built, there is no need to test for the validity of the data each time a calculation is carried out. The other advantage of using \texttt{spct} objects, is that specialized versions of generic functions like \texttt{print} and operators like \texttt{+} can be defined for spectra. \texttt{\_\_\_spct} objects are \texttt{data.frame} objects, as a result of how classes have been derived. In this package we define a \textit{generic} or \emph{base} spectrum class, derived from \texttt{data.frame}, from which specialized types of spectra are in turn derived. This `parenthood' hierarchy means that spectra objects can be used almost anywhere where a \texttt{data.frame} is expected.

\subsection{\texttt{print()}}

The \texttt{print()} method for spectra is based in the current version of the package on the function defined in package \texttt{dplyr}, consequently, it is possible to the options from this package to control printing.  \texttt{dplyr.print\_max}, the number of rows in the spectral object above which only \texttt{dplyr.print\_min} rows are printed, are both set to 5, instead of the default 20 and 10.

<<set-up-printing>>=
options(dplyr.print_max = 4)
options(dplyr.print_min = 4)
@

For explicit calls to \texttt{print()} its argument \texttt{n} can be used to control the number of lines printed. If \texttt{n} is set to \verb|Inf| the whole spectrum is always printed.

<<>>=
print(sun.spct, n = 3)
@

\subsection{\texttt{summary()}}

The \texttt{summary()} method for spectra is based on base R's \texttt{summary()} method for data frames, and accepts the same arguments, and obeys R's global \texttt{digits} option for its default.

<<>>=
summary(sun.spct)
@

\subsection{Classes}

The package defines several classes intended to be used to store different types of spectral data. They are all derived from \texttt{generic\_spct}, which in turn is derived from \texttt{data.frame} and internally created using \texttt{dplyr::data\_frame}. Table \ref{tab:spct:classes} lists them. Attributes are used in objects of these classes to keep \emph{metadata} such as information about units of expression.

\begin{table}
\caption[Classes for spectral data]{Classes for spectral data. In addition to the attributes listed, all spectral objects have attributes \texttt{normalized} and \texttt{scaled}, plus the normal attributes of \texttt{data.frame} objects.}\label{tab:spct:classes}
\centering
\begin{footnotesize}
\begin{tabular}{>{\ttfamily}l>{\ttfamily}l>{\ttfamily}l}
\toprule
\textnormal{Name} & \textnormal{Variables} & \textnormal{Attributes} \\
\midrule
generic\_spct & w.length & \\
raw\_spct & w.length, counts & \\
cps\_spct & w.length, cps & \\
source\_spct & w.length, s.e.irrad, s.q.irrad & time.unit, bswf \\
filter\_spct & w.length, Tfr, A & Tfr.type \\
reflector\_spct & w.length, Rfr & Rfr.type \\
object\_spct & w.length, Tfr, Rfr & Tfr.type, Rfr.type \\
response\_spct & w.length, s.e.response, s.q.response & time.unit \\
chroma\_spct & w.length, x, y, z & \\
\bottomrule
\end{tabular}
\end{footnotesize}
\end{table}

The \emph{design} imposes that data from different observations are never present as different
\emph{data columns}, if present, additional data columns represent different properties from
the same observation event.
In most cases, one spectral object corresponds to one spectral observation, but some functions
are compatible or can be used to create spectral objects where the spectral data from different
observations are stored ``longitudinally'' and ``tagged'' with a factor with a level for each
observation event. These observations must use consistent units of expression
and attribute values.

\subsection{Data assumptions}

An assumption of the package is that wavelengths are always expressed in nanometres ($1~\Unit{nm} = 1 \cdot 10^{-9}\,\Unit{m}$). If the data to be analysed uses different units for wavelengths, e.g.\ Ångstrom ($1~\Unit{Å} = 1 \cdot 10^{-10}\,\Unit{m}$), the values need to be re-scaled before any calculations. Table \ref{tab:spct:units} lists the units of expression for the different variables listed in  Table  \ref{tab:spct:classes}.

\begin{table}
\caption[Variables for spectral data]{Variables used for spectral data and their units of expression: A: as stored in objects of the spectral classes, B: also recognized by the \texttt{set} family of functions for spectra and automatically converted. \texttt{time.unit} accepts in addition to the character strings listed in the table, objects of classes \texttt{lubridate::duration} and \texttt{period}, in addition \texttt{numeric} values are interpreted as seconds. \texttt{exposure.time} accepts these same values, but not the character strings.}\label{tab:spct:units}
\centering
\begin{footnotesize}
\begin{tabular}{>{\ttfamily}ll>{\ttfamily}l}
\toprule
\textnormal{Variables} & Unit of expression & \textnormal{Attribute value} \\
\midrule
A: stored & & \\
\midrule
w.length & nm &  \\
counts & n & \\
cps & \cps & \\
s.e.irrad &  \wattnm & time.unit = "second" \\
s.e.irrad &  \jdaynm & time.unit = "day" \\
s.e.irrad &  varies & time.unit = \emph{duration} \\
s.q.irrad &  \molnm & time.unit = "second" \\
s.q.irrad &  \moldaynm & time.unit = "day" \\
s.q.irrad &  \moltotnm & time.unit = "exposure" \\
s.q.irrad &  varies & time.unit = \emph{duration} \\
Tfr & [0,1] &  Tfr.type = "total" \\
Tfr & [0,1] &  Tfr.type = "internal" \\
A   & a.u.  &  Tfr.type = "internal" \\
Rfr & [0,1] &  Rfr.type = "total" \\
Rfr & [0,1] &  Rfr.type = "specular" \\
s.e.response & \eresponsenm &  time.unit = "second" \\
s.e.response & \eresponsedaynm &  time.unit = "day" \\
s.e.response & \eresponsetotnm &  time.unit = "exposure" \\
s.e.response & varies &  time.unit = \emph{duration} \\
s.q.response & \qresponsenm &  time.unit = "second" \\
s.q.response & \qresponsedaynm &  time.unit = "day" \\
s.q.response & \qresponsetotnm &  time.unit = "exposure" \\
s.q.response & varies &  time.unit = \emph{duration} \\
x, y, z & [0,1] & \\
\midrule
B: converted & & \\
\midrule
wl $\to$ w.length & nm & \\
wavelength $\to$ w.length & nm & \\
Tpc $\to$ Tfr & [0,100] &  Tfr.type = "total" \\
Tpc $\to$ Tfr  & [0,100] &  Tfr.type = "internal" \\
Rpc $\to$ Rfr  & [0,100] &  Rfr.type = "total" \\
Rpc $\to$ Rfr  & [0,100] &  Rfr.type = "specular" \\
counts.per.second $\to$ cps & \cps &  \\
\bottomrule
\end{tabular}
\end{footnotesize}
\end{table}

Energy irradiances are assumed to be expressed in \watt and photon irradiances in \mol, that is to say using second as unit for time. This is the default, but it is possible to set the unit for time to day in the case of \texttt{source\_spct} objects.

The default time unit used is \emph{second}, but \emph{day} and \emph{exposure} can be used by supplying the arguments \texttt{"day"} or \texttt{"exposure"}\footnote{The meaning of \texttt{"exposure"} is the total exposure  time, in other words, fluence instead of irradiance.}
to a parameter of the constructor of \texttt{source\_spct} objects.

The attributes are normally set when an object spectral object is created, either using default values of values supplied as arguments to the constructor.

\begin{framed}
\noindent
Not respecting these assumptions will yield completely wrong results! It is extremely important to make sure that the wavelengths are in nanometres as this is what all functions expect. If wavelength values are in the wrong units, the action-spectra weights and quantum conversions will be wrongly calculated, and the values returned by most functions completely wrong, without warning.
\end{framed}

If spectral irradiance data is in \wattnm, and the wavelength in nm, as is the case for many
Macam spectroradiometers, the data can be used directly and functions in the package will return irradiances in \watt.

If, for example, the spectral irradiance data output by a spectroradiometer is expressed in \mwattnm,
and the wavelengths are in Ångstrom then to obtain correct results when using any of the packages in the suite, we need to rescale the data when creating a new object.

<<example-1, eval=FALSE>>=
# not run
my.spct <- source_spct(w.length = wavelength/10, s.e.irrad = irrad/1000)
@

In the example above, we take advantage of the behaviour of the S language: an operation between a scalar and vector, is equivalent to applying this operation to each member of the vector.
Consequently, in the code above, each value from the vector of wavelengths is divided
by 10, and each value in the vector of spectral irradiances is divided by 1000.

\subsection{Querying the class}

Before giving examples of how to construct objects to store spectral data we show how to query the class of an object, and how to query the class of a spectrum. Consistently with R design, the package provides `is' functions for querying the type of spectra objects.

<<>>=
is.any_spct(sun.spct)
is.source_spct(sun.spct)
@

In addition function \texttt{class.spc} returns directly the spectrum-related class attributes.

<<>>=
class_spct(sun.spct)
class(sun.spct)
@

\subsection{Construction}

There are basically two different approaches to the creation of spectra by users, a constructor similar to \texttt{data.frame} constructor that takes vectors as arguments, and a constructor that converts \texttt{list} objects into spectral objects, which works similarly to \texttt{as.data.frame} from base R. In contrast to the data frame constructors spectral constructor require the variables or the vector arguments should be suitably named so that they can be recognized.

Here we briefly describe the `as' constructor functions for spectra. In the first example we create an object to store spectral irradiance data for `light source', by first creting a data frame, and creating the spectral object as a copy of it. In the example below we supply a single value, 1, for the spectral irradiance. This value gets recycled as is normal in R, but of course in real use it is more usual to supply a vector of the same length as the \texttt{w.length} vector.

<<>>=
my.df <- data.frame(w.length = 400:410, s.e.irrad = 1)
my.spct <- as.source_spct(my.df)
class(my.spct)
class(my.df)
my.spct
@

We can make a `generic\_spct' copy of any spectrum object.

<<>>=
my.g.spct <- as.generic_spct(my.spct)
class(my.g.spct)
@

When cronstructing spectral objetcs from numeric vectors the names of the arguments are meaningful and convey information on the nature of the spectral data and basis of expression.

<<>>=
source_spct(w.length = 300:305, s.e.irrad = 1)
@

<<>>=
z <- 300:305
y <- 2
source_spct(w.length = z, s.e.irrad = y)
@

<<>>=
w.length <- 300:305
s.e.irrad <- 1
source_spct(w.length, s.e.irrad)
@

The different constructors have additional arguments to be used in setting non-default values for the attributes. These arguments have the same name as the attributes. Here we used the data frame created in the first chunk of the section.

<<>>=
my.d.spct <- as.source_spct(my.df, time.unit = "day")
@

Argument \texttt{strict.range} can be used to override or make more strict the validation of the data values.
<<>>=
source_spct(w.length = 300:305, s.e.irrad = -1)
source_spct(w.length = 300:305, s.e.irrad = -1, strict.range = NULL)
@

Finally argument \texttt{comment} can be used to add a comment to the data at the time of construction.

<<>>=
my.cm.spct <- source_spct(w.length = 300:305, s.e.irrad = 1,
                          comment = "This is a comment")
comment(my.cm.spct)
@

\subsection{Special attributes}

Spectral objects have several attributes used to store metadata, such as the time unit used or type of spectral quantity. Some attributes are meaningful for all the classes of spectra defined in the package. These are \emph{time of measurement} using attribute \texttt{"when.measured"}, \emph{place of measurement} using attrinute \texttt{"where.measured"} and free-text \emph{comments}. One can set and get comments stored in spectra by means of base R's \texttt{comment()} and \verb|comment() <-| functions. Some of the functions in this package append additional information to comments or merge comments.

Functions \texttt{setWhenMeasured()} and \texttt{getWhenMeasured()} are used for setting or getting a date as a \texttt{POSIXct} value. This format is compatible with many functions
from pacakge \texttt{lubridate}.

<<>>=
my.spct <- sun.spct
setWhenMeasured(my.spct, NULL)
getWhenMeasured(my.spct)
setWhenMeasured(my.spct, ymd_hms("2015-10-31 22:55:00", tz = "EET"))
getWhenMeasured(my.spct)
@

Functions \texttt{setWhereMeasured()} and \texttt{getWhereMeasured()} are used for setting or getting a geocode as a \texttt{data.frame} value. This format is comaptible with function
\texttt{geocode()} from pacakge \texttt{ggmap}. It is also possible, to simply pass latitude
and longitude coordinates, as shown below. The returned value is always a data frame with columns \texttt{"lon"} and \texttt{"lat"}.

<<>>=
setWhereMeasured(my.spct, NULL)
getWhereMeasured(my.spct)
setWhereMeasured(my.spct, lat = 60, lon = -10)
getWhereMeasured(my.spct)
getWhereMeasured(my.spct)$lon
my.spct
@

Similar functions exist for other attributes which are not shared by all spectral classes.
Spectral objects may have several other attributes used to store metadata, such as the time unit used. There functions available for quering and setting the state if these attributes. \texttt{is\_} functions return a logical value, and \texttt{get} functions return the values of the attributes themselves. In addition \texttt{set} functions can be used to set the value attributes, but many of the \texttt{set} functions are very rarely needed in user code.

The attributes described below are set automatically, and consequently function \texttt{setBSWFUsed()} and other \emph{set} functions for these attributes are mainly of use to programmers extending the package. One exception is when a wrong value has been assigned by mistake and needs to be overwritten.

For example function \texttt{is\_effective()} returns \texttt{TRUE} if the spectral data has been weighted with a BSWF. The corresponding \texttt{getBSWFUsed()} function can be used, in this case to retrieve the name of the BSWF that was used when generating the data. Here we demonstrate with one example, where we use two different \texttt{waveband} objects---constructed on-the-fly with constructor functions defined in package \PBWB---, one defining a range of wavelengths, and another one defining the spectral weighting function for human erythema.

<<>>=
is_effective(sun.spct)
is_effective(sun.spct * VIS())
getBSWFUsed(sun.spct * VIS())
is_effective(sun.spct * CIE())
getBSWFUsed(sun.spct * CIE())
@

Sometimes it may be desired to change the time unit used for expresing spectral irradiance or spectral response, and this can be achieved with the \emph{conversion} function \texttt{convertTimeUnit}. This function both converts spectral data to the new unit of expression and sets the \texttt{time.unit} attribute, preserving the validity of the data object.

<<>>=
ten.minutes.spct <-
  convertTimeUnit(sun.spct, time.unit = duration(10, "minutes"))
ten.minutes.spct
getTimeUnit(ten.minutes.spct)
@

\begin{framed}
\noindent
Spectral objects created with earlier (pre-release) versions of this package are missing some attributes. For this reason `summary' and `plot' functions may not work as expected with them. These \emph{old} objects can be updated by adding the missing attribute using functions \texttt{setTimeUnit}, \texttt{setBSWFUsed}, \texttt{setTfrType} and \texttt{setRfrType}. However, in many cases function \texttt{update\_spct} can be used to set the missing attributes to default values, or the scripts re-run to rebuild the data objects from raw data.
\end{framed}

\section{Collections of spectra}

\subsection{Classes}

The package defines several classes intended to be used to store \emph{collections} of different types of spectral data. They are all derived from \texttt{generic\_mspct}, which in turn is derived from \texttt{list}. Table \ref{tab:mspct:classes} lists them.

\begin{table}
\caption[Classes for collections of spectral objects]{Classes for collections of spectral objects. Objects of class \texttt{generic\_mspct} can have member objects of any class derived from \texttt{generic\_spct} and can be heterogeneous. Atributes can be queried and set with the normal R methods of the same names.}\label{tab:mspct:classes}
\centering
\begin{small}
\begin{tabular}{>{\ttfamily}l>{\ttfamily}l>{\ttfamily}l}
\toprule
\textnormal{Name} & \textnormal{Member objects} & \textnormal{Attributes}\\
\midrule
generic\_mspct & generic\_spct $+$ \textnormal{any derived} & names, dim, comment \\
raw\_mspct & raw\_spct & names, dim, comment \\
cps\_mspct & cps\_spct & names, dim, comment \\
source\_mspct & source\_spct & names, dim, comment \\
filter\_mspct & filter\_spct & names, dim, comment \\
reflector\_mspct & reflector\_spct & names, dim, comment \\
object\_mspct & object\_spct & names, dim, comment \\
response\_mspct & response\_spct & names, dim, comment \\
chroma\_mspct & chroma\_spct & names, dim, comment \\
\bottomrule
\end{tabular}
\end{small}
\end{table}

Objects of these classes, except for those of class \texttt{generic\_mspct}, can contain members belonging to one of the classes. Being all other spectral object classes derived from \texttt{generic\_spct}, \texttt{generic\_mspct} objects can contain heterogeneous collections of spectra. In all cases, there are no restrictions on the lengths, wavelength range and/or wavelength step size, or attributes other than \texttt{class} of the contained spectra. Mimicking R's arrays and matrixes, a \texttt{dim} attribute is always present and \texttt{dim} methods are provided. These allows the storage of time series of spectral data, or (hyper)spectral image data, or even higher dimensional spectral data. The handling of 1D and 2D spectral collections is already implemented in the summary methods. Handling of 3D and higher dimensional data can be implemented in the future without changing the class definition. By having implemented \texttt{dim}, also methods \texttt{ncol} and \texttt{nrow} are available as they use \texttt{dim} internally. Array-like subscripting is \textbf{not} implemented.

\subsection{Construction}

\subsubsection{Constructors}

We can construct a collection using a list of spectral objects as a starting point, in this case the spectral transmittance for two glass filters.
<<>>=
two_suns.mspct <- source_mspct(list(sun1 = sun.spct, sun2 = sun.spct))
two_suns.mspct
@

We can also create heterogeneous collections, but this reduces the number of methods that can be used on the resulting collection.

<<>>=
mixed.mspct <- generic_mspct(list(filter = clear.spct, source = sun.spct))
@

\subsubsection{Using `as' functions}

The \texttt{as} functions for collections of spectra, not only change the class of the collection object, but also apply the corresponding {as} functions to the member objects. They copy the original objects and then convert the copy, which is returned.

<<>>=
two_gen.mscpt <- as.generic_mspct(two_suns.mspct)
class(two_gen.mscpt)
lapply(two_gen.mscpt, class_spct)
@

\subsubsection{Converting `tidy' data}

Spectral objects containing multiple spectra identified by a factor (class of the argument is replicated to collection members).

<<>>=
two_suns.spct <- rbindspct(list(a = sun.spct, b = sun.spct / 2))
subset2mspct(two_suns.spct)
@

Data frame containing `tidy' spectral data (target class and index variable need to be supplied as arguments).
<<>>=
test1.df <- data.frame(w.length = rep(200:210, 2),
                       s.e.irrad = rep(c(1, 2), c(11, 11)),
                       spectrum = factor(rep(c("A", "B"), c(11,11))))
subset2mspct(test1.df, member.class = "source_spct", idx.var = "spectrum")
@

\subsubsection{Converting `untidy' data frames}

Data frame containing `untidy' or `wide' spectral data (class is determined by the function used,
columns which are not \texttt{numeric} are skipped.

<<>>=
test2.df <- data.frame(w.length = 200:210, A = 1, B = 2, z = "A")
split2source_mspct(test2.df)
split2source_mspct(test2.df, spct.data.var = "s.q.irrad")
@

\subsection{Querying the class}

\texttt{is.} functions are defined for these classes. R's \texttt{class} method can also be used.

<<>>=
is.source_mspct(two_suns.mspct)
class(two_suns.mspct)
@

In addition to using \texttt{class} to query the class of the collection, we can use base R's \texttt{lapply} together with \texttt{class} or \texttt{class\_spct} to query the class of each of the members of the collection.

<<>>=
is.filter_mspct(mixed.mspct)
is.any_mspct(mixed.mspct)
class(mixed.mspct)
lapply(mixed.mspct, class_spct)
lapply(mixed.mspct, class)
@

\subsection{Extract, replace and combine}

R's extraction and replacement methods have specializations for collections of spectra and can be used with the same syntax and functionality as for R lists. However they test the class and validity of the returned objects and replacement members.

\begin{framed}
\noindent
Methods \texttt{`[`}, and \texttt{`[<-`}, extract and replace `parts' of the collection, respectively. Even when only one member is extrated, the returned value is a collection of spectra. The expected replacement value is also, always a collection of spectra.
\end{framed}

<<>>=
two_suns.mspct[1]
two_suns.mspct[2:1]
@

<<>>=
two_suns.mspct[1:2] <- two_suns.mspct[2:1]
@

\begin{framed}
\noindent
Methods \texttt{`[[`}, \verb|$| and \texttt{`[[<-`}, extract and replace individual members of the collection, respectively. They allways return or expect objects of one of the spectral classes.
\end{framed}

<<>>=
two_suns.mspct[[1]]
two_suns.mspct$sun1
two_suns.mspct[["sun1"]]
@


<<>>=
two_suns.mspct[["sun1"]] <- sun.spct * 2
two_suns.mspct[["sun2"]] <- NULL
two_suns.mspct
@

We can use the combine method \texttt{c()} with collections of spectra (but not to create new collections from individual spectra).

<<>>=
c(two_suns.mspct, mixed.mspct)
@

\subsection{Transform or \emph{apply} functions}\label{sec:apply}

For our `apply' functions we follow the namimg convention used in package \texttt{plyr}, but using  \texttt{ms} as prefix for \texttt{\_mspct} objects. The `apply' functions implemented in the \PB package are \texttt{msmsply}, \texttt{msdply}, \texttt{mslply}  and \texttt{msaply} which both accepts a collections of spectra as first argument and return a collection of spectra, a data frame, a list, or an array respectively (Table \ref{tab:apply}).

\begin{table}
  \caption[Apply functions for collections of spectra]{Apply fucntions for collections of spectra. Key: v., value returned by `apply' function; f.v., value returned by the applied function (argument \texttt{.fun}). In the table \texttt{generic\_mspct} and \texttt{generic\_spct} indicate objects of these classes or any class derived from them. The exact class of the collection of spectra object returned  will be determined by the class(es) of the values returned by the applied function.}\label{tab:apply}
  \centering
  \begin{scriptsize}
  \begin{tabular}{>{\ttfamily}l>{\ttfamily}l>{\ttfamily}l>{\ttfamily}lll}
    \toprule
    \textnormal{`apply' function} & \textnormal{first arg.\ class} & \textnormal{v. class} &
    \textnormal{f.v.\ class} & f.v.\ length & f.v.\ dims \\
    \midrule
    msmsply & generic\_mspct & generic\_mspct & generic\_spct & 1 & any \\
    msdply & generic\_mspct & data.frame & numeric & $1\ldots n$ & 1 \\
    mslply & generic\_mspct & list & \textnormal{any} & any & any \\
    msaply & generic\_mspct & vector & \textnormal{any simple} & 1 & 0 \\
    msaply & generic\_mspct & matrix & \textnormal{any simple} & $2\ldots n$ & $2\ldots n$  \\
    concolve\_each & generic\_mspct & generic\_mspct & generic\_spct & 1 & any \\
    \bottomrule
  \end{tabular}
  \end{scriptsize}
\end{table}

Functions \texttt{msmsply()}, \texttt{msdply} and \texttt{mslply} can be used to apply a function to each member spectrum in a collection. The `apply' fucntion to use depends on the return value of the applied function.

In the case of \texttt{msmsply()} the applied function is expected to return a `transformed' spectrum as another object of class \texttt{generic\_spct} or a class derived from it. The value returned by \texttt{msmsply} is a collection of spectra, of a type determined by the class(es) of the member spectra in the new collection.

We start with a simple example in which we add a constant to each spectrum in the collection
<<>>=
two.mspct <- source_mspct(list(A = sun.spct * 1, B = sun.spct * 2))
msmsply(two.mspct, `+`, 0.1)
@

and continue with a more complex example in which we trim each spectrum
<<>>=
msmsply(two.mspct, trim_wl, range = c(281, 500), fill = NA)
@

In the second example we pass two arguments by name to the applied function. The number of arguments is not fixed, but the spectrum will be always passed as the first argument to the function.

In the case of \texttt{msdply()} the applied function is expected to return an R object of the same length for each of the member spectra.

<<>>=
msdply(two.mspct, max)
@

<<>>=
ranges.df <- msdply(two.mspct, range)
ranges.df
cat(comment(ranges.df))
@

<<>>=
msdply(two.mspct, range, na.rm = TRUE)
@

In the case of \texttt{mslply()} the applied function is expected to return an R object of any length, possibly variable among members.

<<>>=
str(mslply(two.mspct, names))
@

In the case of \texttt{msaply()} the applied function is expected to return an R object of length 1, although a list with dimensions will be returned for longer return values.

<<>>=
str(msaply(two.mspct, max))
@

<<>>=
str(msaply(two.mspct, range))
@

\subsection{Convolution}\label{sec:convolve}

By convolution we normally mean the multiplication value by value at matching wavelengths of two spectra. The function described in this section facilitates this and similar operations among collections of spectra. An example use case could be the covolution of spectral irradiance by spectral transmittance for all combinations of light sources and filters in a collection of source spectra and a collection of filter spectra.

Default operator (or function) is that for multiplication, either one or both of the two first arguments must be a collection of spectra. When only one argument is a collection of spectra, the other one can be a spectrum, or even a numeric vector. For multiplication the order of the operands does not affect the returned value. With operators or functions for non-transitive operations the order does matter.

<<>>=
convolve_each(two.mspct, sun.spct)
@

<<>>=
convolve_each(sun.spct, two.mspct)
@

<<>>=
another_two.mspct <- two.mspct
names(another_two.mspct) <- c("a", "b")
convolve_each(another_two.mspct, two.mspct)
@

The function \texttt{convolve\_each} will use other operators or functions and even pass additional named arguments when these are supplied as arguments.
<<>>=
convolve_each(two.mspct, sun.spct, oper = `+`)
@

\begin{framed}
\noindent
There are cases where functions \texttt{convolve\_each()} and \texttt{msmsply()} can be both used, but there are also cases where their differences matter. An example is convolving two collections of spectra, a case where only \texttt{convolve\_each()} can be used. In contrast, when one of the arguments is not a spectrum or a collection of spectra, \texttt{msmsply()} should be used instead.
\end{framed}

\subsection{Attributes}

Some of the \texttt{set} and \texttt{get} functions used with attributes have method definitions for collections of spectra. Some examples follow.

<<>>=
getWhenMeasured(two.mspct)
setWhenMeasured(two.mspct, ymd("2015-10-31"))
getWhenMeasured(two.mspct)
setWhenMeasured(two.mspct,
                list(ymd_hm("2015-10-31 10:00"),
                     ymd_hm("2015-10-31 11:00")))
getWhenMeasured(two.mspct)
two.mspct
@

Other methods available are \texttt{getWhereMeasured} and \texttt{setWhereMeasured}.

\section{Wavebands}

When a range of wavelengths or a range of wavelengths plus a spectral weighting function (SWF) is needed for radiation summaries or transformations, methods, operators and functions defined in package \PB  use \texttt{waveband} objects to store these data. A few other bits of information can be included to fine-tune calculations. The waveband definitions do NOT describe whether input spectral irradiances are photon or energy based, nor whether the output irradiance will be based on photon or energy units. All waveband objects belong to the S3 class \texttt{waveband}.

\subsection{Construction}

When defining a waveband which uses a SWF, a function can be supplied either based on energy effectiveness, on photon effectiveness, or one function for each one. If only one function is supplied the other one is built automatically, but if performance is a concern it is better to provide two separate functions. Another case when you might want to enter the same function twice, is if you are using an absorptance spectrum as SWF, as the percent of radiation absorbed will be independent of whether photon or energy units are used for the spectral irradiance.

To create a waveband object we use constructor function \texttt{waveband}, and optionally giving a name to it.

<<>>=
my_PAR <- waveband(c(400, 700), wb.name = "my_PAR")
@

When including a BSWF, we supply, one or two versions of functions returning the weights as a function of wavelength. Several such functions are defined in package \PBWB as well as constructors using them. Here we give three examples of how equivalent wavebands can be defined based on a SWF. Although the constructor is smart enough to derive the missing function when only one function is supplied, performance may suffer.

<<>>=
my_CIE_1 <-
  waveband(c(250, 400), weight = "SWF", SWF.e.fun = CIE_e_fun, SWF.norm = 298)
my_CIE_2 <-
  waveband(c(250, 400), weight = "SWF", SWF.q.fun = CIE_q_fun, SWF.norm = 298)
my_CIE_3 <-
  waveband(c(250, 400), weight = "SWF", SWF.e.fun = CIE_e_fun,
                         SWF.q.fun = CIE_q_fun, SWF.norm = 298)
@

The first argument to \texttt{waveband()} does not need to be a numeric vector of length two. Any R object of a class that supplies a \texttt{range()} method definition that can be interpreted as a range of wavelengths in nanometres can be used. As a consequence, when wanting to construct a waveband covering the whole range of a spectrum one can simply supply the spectrum as argument, or to construct an unweighted waveband which covers exactly the same range of wavelengths as an existing effective (weighted) waveband, one can supply a waveband object as an argument.

<<>>=
waveband(sun.spct)
waveband(my_CIE_1)
@

\subsection{Querying the class}

The function \texttt{is.waveband} can the used to query any R object. This function returns a logical value.

<<>>=
is.waveband(PAR())
PAR <- PAR()
is.waveband(PAR)
@

Above, we demonstrate that \texttt{PAR()} is a waveband constructor returning a waveband object, and \texttt{PAR} is a waveband object.

\subsection{Retrieving properties}

The function \texttt{is\_effective} can the used to query any R object.

<<>>=
is_effective(PAR())
@

\section{Collections of wavebands}

In the current implementation there is no special class used for storing collections of \texttt{waveband} objects. We simply use base R's \texttt{list} class.

\subsection{Construction}

\subsubsection{List constructor}

Just base R's functions used to create a list object.

<<>>=
wavebands <- list(waveband(c(300,400)), waveband(c(400,500)))
wavebands
@

\subsubsection{Special constructor}

The function \texttt{split\_bands} can be used to generate lists of unweighted wavebands in two different ways: a) it can be used to split a range of wavelengths given by an R object into a series of adjacent wavebands, or b) with a list of objects returning ranges, it can be used to create non-adjacent and even overlapping wavebands.

The code chunk bellow shows an example of two variations of case a). With the default value for \texttt{length.out} of \texttt{NULL} each numerical value in the input is taken as a wavelength (nm) at the boundary between adjacent wavebands. If a numerical value is supplied to \texttt{length.out}, then the whole wavelength range of the input is split into this number of equally spaced adjacent wavebands.

<<>>=
split_bands(c(200, 225, 300))
split_bands(c(200, 225, 300), length.out = 2)
@

In both examples above, the output is a list of two wavebands, but the `split' boundaries are at a different wavelength. The chunk bellow gives a few more examples of the use of case a).

<<>>=
split_bands(sun.spct, length.out = 2)
split_bands(PAR(), length.out = 2)
split_bands(c(200, 800), length.out = 3)
@

Now we demonstrate case b). This case is handled by recursion, so each list element can be anything that is a valid input to the function, including a nested list. However, the returned value is always a flat list of wavebands.

<<>>=
split_bands(list(A = c(200, 300), B = c(400, 500), C = c(250, 350)))
split_bands(list(c(100, 150, 200), c(800, 825)))
@

In case b) if we supply a numeric value to \texttt{length.out}, this value is used recursively for each element of the list.

<<>>=
split_bands(list(R = Red(), B = Blue()), length.out  =  2)
split_bands(list(c(100, 150, 200), c(800, 825)), length.out = 1)
@

\section{Transformations: using operators}

\subsection{Binary operators}

The basic maths operators have definitions for spectra. It is possible to sum, subtract, multiply and divide spectra. These operators can be used even if the spectral data is on different arbitrary sets of wavelengths. Operators by default use values expressed in energy units. Only certain operations are meaningful for a given combination of
objects belonging to different classes, and meaningless combinations return \texttt{NA} also issuing a warning (see Table \ref{tab:operators}). By default operations are carried out on spectral energy irradiance for \texttt{source\_spct} objects and transmittance for \texttt{filter\_spct} objects.

\begin{table}
\newcommand{\N}{\textcolor{red}{\small N}}
\newcommand{\Y}{\textcolor{green}{\small Y}}
\caption[Binary operators]{Binary operators and operands. Validity and class of result. All operations marked `\Y' are allowed, those marked `\N' are forbidden and return \texttt{NA} and issue a warning. Operators \texttt{\%/\%} and \texttt{\%\%} follow \texttt{/}.}\label{tab:operators}

\centering
\begin{footnotesize}
\begin{tabular}{>{\ttfamily}lccccc>{\ttfamily}l>{\ttfamily}l}
\toprule
e1 & \verb|+| & \verb|-| & \verb|*| & \verb|/| & \verb|^| & e2 & \textnormal{value} \\
\midrule
raw\_spct & \Y & \Y &\Y  & \Y & \Y & raw\_spct & raw\_spct \\
cps\_spct & \Y & \Y &\Y  & \Y & \Y & cps\_spct & cps\_spct \\
source\_spct & \Y & \Y &\Y  & \Y & \Y & source\_spct & source\_spct \\
filter\_spct (T) & \N & \N & \Y & \Y  & \N & filter\_spct & filter\_spct \\
filter\_spct (A) & \Y & \Y & \N & \N  & \N & filter\_spct & filter\_spct \\
reflector\_spct & \N & \N & \Y &\Y  & \N & reflector\_spct & reflector\_spct \\
object\_spct & \N & \N & \N & \N &\N & object\_spct & -- \\
response\_spct & \Y & \Y & \Y & \Y & \N & response\_spct & response\_spct \\
chroma\_spct & \Y  & \Y & \Y & \Y & \Y & chroma\_spct & chroma\_spct \\
\midrule
raw\_spct & \Y  & \Y &\Y  & \Y & \Y & numeric & raw\_spct \\
cps\_spct & \Y  & \Y &\Y  & \Y & \Y & numeric & cps\_spct \\
source\_spct & \Y  & \Y &\Y  & \Y & \Y & numeric & source\_spct \\
filter\_spct & \Y  &\Y  & \Y &\Y  & \Y & numeric & filter\_spct \\
reflector\_spct & \Y &\Y  &\Y  &\Y  & \Y & numeric & reflector\_spct \\
object\_spct & \N & \N & \N & \N &\N & numeric & -- \\
response\_spct & \Y  & \Y  & \Y  & \Y  & \Y & numeric & response\_spct \\
chroma\_spct & \Y & \Y  & \Y & \Y  & \Y & numeric & chroma\_spct \\
\midrule
source\_spct & \N & \N & \Y &\Y  & \N & response\_spct & response\_spct \\
source\_spct & \N & \N & \Y  & \Y  & \N & filter\_spct (T) & source\_spct \\
source\_spct & \N & \N & \Y  & \Y & \N & filter\_spct (A) & source\_spct \\
source\_spct & \N & \N & \Y  & \Y  & \N & reflector\_spct & source\_spct \\
source\_spct & \N & \N &\N  & \N & \N & object\_spct & -- \\
source\_spct & \N & \N &\Y  & \N & \N & waveband (no BSWF) & source\_spct \\
source\_spct & \N & \N &\Y  & \N & \N & waveband (BSWF) & source\_spct \\
\bottomrule
\end{tabular}
  \end{footnotesize}
\end{table}


<<>>=
sun.spct * sun.spct
@

When meaningful, operations between different spectra are also allowed. For example, it is possible to simulate the effect of a filter on a light source by multiplying (or convolving) the two spectra.

<<>>=
polyester.spct <- mcdermit.mspct[["Autostat_CT5_125um"]]
sun.spct * polyester.spct
@

If we have two layers of the filter, this can be approximated using either of these two statements.

<<>>=
sun.spct * polyester.spct * polyester.spct
sun.spct * polyester.spct^2
@

Operators are also defined for operations between a spectrum and a numeric vector (with normal recycling).

<<>>=
sun.spct * 2
2 * sun.spct
sun.spct * c(0,1)
@

There is one special case, for \texttt{chroma\_spct}: if the numeric operand has length three, containing three \emph{named} values `x', `y' and `z', the corresponding value is used for each of the chromaticity `columns' in the \texttt{chroma\_spct}. Un-named values or differently named values are not treated specially.

Operators are also defined for operations between an spectrum and a \texttt{waveband} object. The next to code chunks demonstrate how the class of the result depends on whether the \texttt{waveband} object describes a range of wavelengths or a range of wavelengths plus a BSWF.

<<>>=
sun.spct * UVB()
@

<<>>=
sun.spct * CIE()
@

And of course these operations can be combined into more complex statements, including parentheses, when needed. The example below estimates the difference in effective spectral irradiance according to the CIE98 definition, between sunlight and sunlight filtered with a polyester film. Of course, the result is valid only for the solar spectral data used, which corresponds to Southern Finland.

<<warning=TRUE, purl=FALSE>>=
sun.spct * CIE() - sun.spct * polyester.spct * CIE()
@

\subsection{Unary operators and maths functions}

The most common maths functions, as well as unary minus and plus, are also implemented for spectral objects (see Table \ref{tab:unary}).

\begin{table}
\newcommand{\N}{\textcolor{red}{\small N}}
\newcommand{\Y}{\textcolor{green}{\small Y}}
\caption[Binary operators]{Unary operators and maths functions for spectra. Classes for which they are implemented and class of the result. All operations marked `\Y' are allowed, those marked `\N' are not implemented and return \texttt{NA} and issue a warning. Additional supported functions: \texttt{log2, log10, sin, cos, tan, asin, acos, atan, sinpi, cospi, tanpi, signif, floor, ceiling, trunc, sign, abs}.}\label{tab:unary}

\centering
\begin{footnotesize}
\begin{tabular}{>{\ttfamily}lccccc>{\ttfamily}l}
\toprule
e1 & \verb|+, -| & \verb|log, exp| & trig. & \verb|round| & \verb|sqrt| & \textnormal{value} \\
\midrule
raw\_spct & \Y & \Y &\Y  & \Y & \Y & raw\_spct \\
cps\_spct & \Y & \Y &\Y  & \Y & \Y & cps\_spct \\
source\_spct & \Y & \Y &\Y  & \Y & \Y & source\_spct \\
filter\_spct & \Y & \Y & \Y & \Y  & \Y &  filter\_spct \\
reflector\_spct & \Y & \Y & \Y &\Y  & \Y & reflector\_spct \\
object\_spct & \N & \N & \N & \N & \N & -- \\
response\_spct & \Y & \Y & \Y & \Y & \Y &  response\_spct \\
chroma\_spct & \Y  & \Y & \Y & \Y & \Y &  chroma\_spct \\
\bottomrule
\end{tabular}
  \end{footnotesize}
\end{table}

<<>>=
-sun.spct
sqrt(sun.spct)
@

\subsection{Options}

Table \ref{tab:options} lists all the recognized options affecting maths operators and functions, and their default values. Within the suite all functions have a default value which is used when the options are undefined. Options are set using base R's function \texttt{options}, and queried with functions \texttt{options} and \texttt{getOption}.

\begin{table}
\caption[Options]{Options recognized by functions in the \PB package and the values they can take.\label{tab:options}}\vspace{0.75ex}

\centering
\begin{footnotesize}
\begin{tabular}{lll}
\toprule
\underline{Option} & \texttt{values, \underline{default}} & \textbf{function} \\
\midrule
\textbf{Base R} & & \\
\addlinespace
digits & 7 & $d - 3$ used by \texttt{summary} \\
\midrule
photobiology.radiation.unit & \texttt{\underline{"energy"}} & output (\wattnm) \\
                            & \texttt{"photon"} & output (\molnm) \\
\addlinespace
photobiology.filter.qty & \texttt{\underline{"transmittance"}} & output ($/1$) \\
                        & \texttt{"absorptance"} & output ($/1$) \\
                        & \texttt{"absorbance"} & output (a.u. $\log_{10}$ base) \\
\addlinespace
photobiology.use.hinges & \texttt{\underline{NULL}} & guess automatically \\
                        & \texttt{TRUE} & do not insert hinges \\
                        & \texttt{FALSE} & do insert hinges \\
\addlinespace
photobiology.strict.range & \texttt{NA} &  skip range test \\
                        & \texttt{TRUE} & trigger and error \\
                        & \texttt{\underline{FALSE}} & trigger a warning \\
\addlinespace
photobiology.auto.hinges.limit & \texttt{\underline{0.5}} & wavelength step (nm) \\
\addlinespace
photobiology.waveband.trim & \texttt{FALSE} & exclude \\
                           & \texttt{\underline{TRUE}} & trim or exclude \\
\addlinespace
photobiology.use.cached.mult & \texttt{\underline{FALSE}} & do not cache intermediate results \\
                             & \texttt{TRUE} & cache intermediate results \\
\addlinespace
photobiology.verbose & \texttt{\underline{FALSE}} & do not give verbose output \\
                     & \texttt{TRUE} & give verbose output \\
\bottomrule
\end{tabular}
\end{footnotesize}
\end{table}

The behaviour of the operators defined in this package depends on the value of two global options. For example, if we would like the operators to operate on spectral photon irradiance and return spectral photon irradiance instead of spectral energy irradiance, this behaviour can be set, and will remain active until unset or reset.

<<>>=
options(photobiology.radiation.unit = "photon")
sun.spct * UVB()
options(photobiology.radiation.unit = "energy")
sun.spct * UVB()
@

The other options listed in Table \ref{tab:options} can be set similarly, to unset any option, they can be given a \texttt{NULL} value.

\section{Transformations: methods and functions}

In this section we describe methods and functions that take one or more spectral objects, and in some cases also waveband objects, as arguments and return another spectral object (Table \ref{tab:transform:spct}) or that take a collection of spectral objects, and in some cases also waveband objects, as argumnents and return a collection of spectral objects (Table \ref{tab:transform:mspct}).

\begin{table}
  \caption[Transformation methods for spectra]{Transformation methods for spectra. Key: + available, -- not available, f available in the future.}\label{tab:transform:spct}

  \centering
  \begin{footnotesize}
  \begin{tabular}{>{\ttfamily}lcccccc}
    \toprule
    \textnormal{methods} & source & response & filter & reflector & object & chroma \\
    \midrule
    merge & + & + & + & + & + & + \\
    rbindspct & + & + & + & + & + & + \\
    \midrule
    e2q, q2e & + & + & -- & -- & -- & -- \\
    A2T, T2A & -- & -- & + & -- & -- & -- \\
    subset & + & + & + & + & + & + \\
    clip\_wl & + & + & + & + & + & + \\
    trim\_wl & + & + & + & + & + & + \\
    (trim\_spct) & + & + & + & + & + & + \\
    interpolate\_wl & + & + & + & + & + & + \\
    (interpolate\_spct) & + & + & + & + & + & + \\
    fscale & + & + & + & + & -- & --  \\
    fshift & + & + & + & + & -- & --  \\
    normalize & + & + & + & + & -- & --  \\
    clean & + & + & + & + & -- & --  \\
    \emph{math operators} & + & + & + & + & + & +  \\
    \emph{math functions} & + & + & + & + & + & +  \\
    tag & + & + & + & + & + & +  \\
    untag & + & + & + & + & + & +  \\
    \bottomrule
  \end{tabular}
  \end{footnotesize}

\end{table}

\begin{table}
  \caption[Transformation methods for collections of spectra]{Transformation methods for collections of spectra. Key: + available, -- not available, \textbf{ms} use \texttt{msmsply()} or \texttt{convolve\_each()} to apply function or operator to collection members.}\label{tab:transform:mspct}
  \centering
  \begin{footnotesize}
  \begin{tabular}{>{\ttfamily}lcccccc}
    \toprule
    \textnormal{methods} & source & response & filter & reflector & object & chroma \\
    \midrule
    convolve\_each & + & + & + & + & + & + \\
    msmsply & + & + & + & + & + & + \\
    msdply & + & + & + & + & + & + \\
    mslply & + & + & + & + & + & + \\
    msaply & + & + & + & + & + & + \\
    \midrule
    rbindspct & + & + & + & + & + & + \\
    c & + & + & + & + & + & + \\
    \midrule
    \emph{math operators} & ms & ms & ms & ms & ms & ms \\
    \emph{math functions} & ms & ms & ms & ms & ms & ms \\
    \midrule
    e2q, q2e & + & + & -- & -- & -- & -- \\
    A2T, T2A & -- & -- & + & -- & -- & -- \\
    clip\_wl & + & + & + & + & + & + \\
    trim\_wl & + & + & + & + & + & + \\
    (trim\_spct) & + & + & + & + & + & + \\
    interpolate\_wl & + & + &+ & + & + & + \\
    (interpolate\_mspct) & + & + &+ & + & + & + \\
    fscale & + & + & + & + & -- & -- \\
    fshift & + & + & + & + & -- & -- \\
    normalize & + & + & + & + & -- & -- \\
    clean & + & + & + & + & -- & -- \\
    tag & + & + & + & + & + & + \\
    untag & + & + & + & + & + & + \\
   \bottomrule
  \end{tabular}
  \end{footnotesize}

\end{table}

\subsection{Manipulating spectra}

Sometimes, especially for plotting, we may want to row-bind spectra. When the aim is that the returned object retains its class and other attributes like the time unit. Package \PB provides function \texttt{rbinspct} for row-binding spectra, with the necessary checks for consistency of the bound spectra.

<<>>=
# STOPGAP
shade.spct <- sun.spct
@

By default an ID factor named \texttt{spct.idx} is added allow to idetify the source of the observations after the binding. If the supplied list has named members, then these names are used as factor levels. If a character value is supplied to as \texttt{idfactor} argument, this is used as name for the factor.

<<>>=
rbindspct(list(sun.spct, shade.spct))
rbindspct(list(A = sun.spct, B = shade.spct), idfactor = "site")
@

In the special case when the members of the list are \texttt{source\_spct} objects containing effective spectral irradiance data, and they are not based on the same BSWF, an additional factor \texttt{BSWF} will be automatically added, and the \texttt{BSWF} attribute of the resulting spectrum set to \texttt{"multiple"}.

<<>>=
rbindspct(list(sun.spct * CIE(), sun.spct * GEN.G()))
@

Special \textit{Extract} methods for spectral objects have been implemented. These are used by default and preserve the attributes used by this package, except when the returned value is a single column from the spectral object.

<<>>=
sun.spct[1:10, ]
sun.spct[1:10, 1]
sun.spct[1:10, 1, drop = TRUE]
sun.spct[1:10, "w.length", drop = TRUE]
@

In contrast to \texttt{trim\_spct}, \texttt{subset} never interpolates or inserts \emph{hinges}. On the other hand, the \texttt{subset} argument accepts any logical expression and can be consequently used to do subsetting, for example, based on factors. Both \texttt{subset()} and \texttt{trim()} methods preserve attributes.

<<>>=
subset(sun.spct, s.e.irrad > 0.2)
subset(sun.spct, w.length > 600)
subset(sun.spct, c(TRUE, rep(FALSE, 99)))
@

R's Extract methods \verb|$| and \verb|[[ ]]| can be used to extract whole columns.
Replace methods \verb|$<-| and \verb|[<-| have definitions for spectral objects, which allow their safe use. They work identically to those for data frames but check the validity of the spectra after the replacement.

\subsection{Conversions between radiation units}

The functions \texttt{e2q} and \texttt{q2e} can be used on source spectra to convert spectral energy irradiance into spectral photon irradiance and vice versa. A second optional argument sets the action with \texttt{"add"} and \texttt{"replace"} as possible values. By default these functions use normal reference semantics.

<<>>=
e2q(sun.spct, "add")
e2q(sun.spct, "replace")
@

For \texttt{filter\_spct} objects functions \texttt{T2A} and \texttt{A2T} allow conversion between spectral transmittance and spectral absorbance and vice versa.

\subsection{Normalizing a spectrum}

Function \texttt{normalize} permits normalizing a spectrum to a value of one at an arbitrary wavelength (nm) or to the wavelength of either the maximum or the minimum spectral value. It supports the different spectral classes, we use a \texttt{source\_spct} object as an example.

<<>>=
normalize(sun.spct)
@

Which is equivalent to supplying \texttt{"max"} as argument to \texttt{norm}, it is also possible to give a range within which the maximum should be searched.

<<>>=
normalize(sun.spct, range = PAR(), norm = "max")
@

It is also possible to normalize to an arbitrary wavelength within the range of the data, even if it is not one of the wavelength values present in the spectral object, as interpolation is used when needed.

<<>>=
normalize(sun.spct, norm = 600.3)
@

\subsection{Rescaling a spectrum}

Function \texttt{fscale()} rescales a spectrum by dividing each spectral data value by a value calculated with a function (f) selected by a character string ("total" or "mean"), or an actual R function which can accept the spectrum object supplied as its first argument.

<<>>=
fscale(sun.spct)
fscale(sun.spct, f = "total")
fscale(sun.spct, range = PAR(), f = irrad)
@

In the third example, the spectral data is rescaled so that the corresponding photosynthetically-active irradiance is equal to one.

\subsection{Shifting the zero of the spectral data scale}

Function \texttt{fshift()} shifts the zero of the scale of a spectrum by subtracting from each spectral data value a value calculated with a function (f) selected by a character string ("mean", "min" or "max"), or an actual R function which can accept the spectrum object supplied as its first argument. The range argument selects a region of the spectrum to be used as \emph{reference} in the calculation of the summary.

<<>>=
fshift(sun.spct, range = UVB(), f = "mean")
fshift(sun.spct, range = c(280,290), f = "min")
@

In the first example, the spectral data shifted so that the mean spectral irradiance becomes zero for the UV-B region. In the second example the minimum value in the range of wavelengths between 280~nm and 290~nm is used as zero reference for the scale.

\subsection{Replacing off-range spectral data values}

Method \texttt{clean()} should be used with care as off-range values stem almost always from calibration errors or measuring noise. This function allows one to replace such values, but in many cases a zero shift or rescaling could be the option to be preferred. Even when the off-range values are the result of random noise, replacing them with the boundary values can cause bias, by censoring the data. Here we create \emph{artificial} off-range values by subtracting a constant from each spectrum.

<<>>=
clean(sun.spct - 0.01, range = c(280.5, 282))
@

<<>>=
clean(polyester.spct - 0.053)
@

\subsection{Wavelength interpolation}

Converting spectra available at a given set of wavelengths values to a different one, is frequently needed when operating with several spectra of different origin. One can increase the \emph{apparent} resolution by interpolation, and reduce it by local averaging or smoothing and resampling. The same function works on all \texttt{spct} objects, interpolating every column except \texttt{w.length} and replacing in this last column the old wavelength values with the new ones supplied as argument. The optional argument \texttt{fill.value} control what value is assigned to wavelengths in the new data that are outside the range of the old wavelengths.

<<>>=
interpolate_spct(sun.spct, seq(400, 500, by = 0.1))
@

\subsection{Trimming and clipping}\label{sec:trim:spct}

\subsubsection{Method \texttt{clip\_wl()}}

Sometimes it is desirable to change the range of wavelengths included in a spectrum. If we are interested in a given part of the spectrum, there is no need to do calculations or plotting the whole spectrum. To select part a spectrum based on a range of wavelengths we may use the \texttt{clip\_wl} method.

The range of wavelengths expressed in nanometres can be given as numeric vector of length two.

<<>>=
clip_wl(sun.spct, range = c(400, 402))
clip_wl(sun.spct, range = c(400, NA))
@

As for \texttt{trim\_wl()} the range can be also supplied as a \texttt{waveband} object, or any other object for which \texttt{range()} returns a numeric range. Even a different spectrum object is acceptable.

<<>>=
clip_wl(sun.spct, range = UVA())
@

The result can be a spectrum of length zero.

<<>>=
clip_wl(sun.spct, range = c(100, 200))
@

\subsubsection{Method \texttt{trim\_wl()}}

Sometimes, we need more flexibility. We may want to replace the observed values outside a certain range or expand the range of wavelengths, filling the expansion of all other variables with a certain value (i.e.\ a number, or NA.). In contrast to \emph{clipping} (or functionally equivalent, indexing, or subsetting), \emph{trimming} ensures that there will be spectral data returned at the boundaries of the trimmed region. These values are obtained by interpolation when they are not already present in the data.

More flexibility is available in method \texttt{trim\_wl()}, to which we can supply arguments \texttt{range}, \texttt{use.hinges}, and \texttt{fill}. By default interpolation is used at the boundaries of the \texttt{range}.

<<>>=
trim_wl(sun.spct, c(282.5, NA))
clip_wl(sun.spct, c(282.5, NA))
@

As for \texttt{clip\_wl()} the range can be also supplied as a \texttt{waveband} object, or any other object for which \texttt{range()} returns a numeric range. Even a different spectrum object is acceptable.

<<>>=
trim_wl(sun.spct, PAR())
@

The default for \texttt{fill} is \texttt{NULL} which results in deletion values outside the trimmed region. However, it is possible to supply a different argument, to be used to replace the off-range data values.

<<>>=
trim_wl(sun.spct, c(281.5, NA), fill = NA)
@

Furthermore, when fill is not \texttt{NULL}, expansion is possible.

<<>>=
trim_wl(sun.spct, c(275, NA), fill = 0)
@

By default interpolation at the boundaries is used, but setting \texttt{use.hinges} to \texttt{FALSE} results in clipping, a behaviour similar to that of \texttt{clip\_wl} only if \texttt{fill == NULL}.

<<>>=
trim_wl(sun.spct, c(281.5, NA), fill = NA)
trim_wl(sun.spct, c(281.5, NA), fill = NA, use.hinges = FALSE)
@

When \texttt{use.hinges == TRUE} and expanssion or replacement is done, two observations are inserted at each boundary, differing in wavelength by $1 \times 10^{-12}$\,nm to prevent rounding errors in later calculations.

\subsubsection{Functions \texttt{trim\_spct} and \texttt{trim\_spct}}

Functions \texttt{trim\_spct} and \texttt{trim\_spct} are not generic, and add even more flexibility, but \texttt{trim\_wl} should be preferred in user scripts.

\subsection{Convolving weights}

It is very instructive to look at weighted spectral data to understand how effective irradiances are calculated. Plotting effective spectral irradiance data can be very instructive when analyzing the interaction of photoreceptors and ambient radiation. It can also illustrate what a large effect that small measuring errors can have on the estimated effective irradiances or exposures when SWFs have a steep slope.

\subsubsection{Individual spectra}

The multiplication operator is defined for operations between a \texttt{source\_spct} and a \texttt{waveband}, so this is the easiest way of doing the calculations.

<<>>=
sun.spct * CIE()
@

\subsubsection{Vectors}

It is also possible to use vectors.

<<weighted-spectra-01, tidy=FALSE>>=
weighted.s.e.irrad <-
  with(sun.spct,
       s.e.irrad * calc_multipliers(w.length, CIE())
  )
@

\subsection{Tagging with bands and colours}

We call tagging, to the process of adding reference information to spectral data. For example we can add a factor indicating regions or bands in the spectrum. We can add also information on the colour, as seen by humans, for each observed value, or for individual regions or bands of the spectrum. In most cases this additional information is used for annotations when plotting the spectral data.

\subsubsection{Individual spectra}

The function \texttt{tag} can be used to tag different parts of a spectrum according to wavebands.

<<>>=
tag(sun.spct, PAR(), byref = FALSE)
tag(sun.spct, UV_bands(), byref = FALSE)
@

The added factor and colour data can be used for further processing or for plotting. Information about the tagging and wavebands is stored in an attribute \texttt{tag.attr} in every tagged spectrum, this yields a more compact output and keeps a `trace' of the tagging.

<<>>=
tg.sun.spct <- tag(sun.spct, PAR(), byref = FALSE)
attr(tg.sun.spct, "spct.tags")
@

Additional functions are available which return a tagged spectrum and take as input a list of wavebands, but no spectral data. They `build' a spectrum from the data in the wavebands, and are useful for plotting the boundaries of wavebands.

<<>>=
wb2tagged_spct(UV_bands())
wb2rect_spct(UV_bands())
@

Function \texttt{wb2tagged\_spct} returns a tagged spectrum, with two rows for each waveband, corresponding to the low and high wavelength boundaries, while function \texttt{wb2rect\_spct} returns a spectrum with only one row per waveband, with \texttt{w.length} set to its midpoint but with additional columns  \texttt{xmin} and \texttt{xmax} corresponding to the low and high wavelength boundaries of the wavebands.

Function \texttt{is\_tagged} can be used to query if an spectrum is tagged or not, and function \texttt{untag} removes the tags.

<<>>=
tg.sun.spct
is_tagged(tg.sun.spct)
untag(tg.sun.spct)
is_tagged(tg.sun.spct)
@

In the chuck above, we can see how this works, using in this case the default \texttt{byref = TRUE} which adds the tags in place, or ``by reference'', to the spct object supplied as argument.

\section{Summaries}

Summaries can be calculated both from individual spectral objects (Table \ref{tab:summaries:spct}) and from collections of spectral objects (Table \ref{tab:summaries:mspct}). They return a \emph{simpler} object than the spectral data in their arguments. For example a vector of numeric values, possibly of length one, in the case of individual spectra, or a data frame containing one row of summary data for each spectrum the collection of multiple spectra supplied as argument.

\begin{table}
  \caption[Summary methods for spectra]{Summary methods for spectra.  Key: + available, -- not available.}\label{tab:summaries:spct}
  \centering
  \begin{footnotesize}
  \begin{tabular}{>{\ttfamily}lcccccc}
    \toprule
    \textnormal{methods} & source & response & filter & reflector & object & chroma \\
    \midrule
    irrad & + & -- & -- & -- & -- & -- \\
    e\_irrad & + & -- & -- & -- & -- & -- \\
    q\_irrad & + & -- & -- & -- & -- & -- \\
    fluence & + & -- & -- & -- & -- & -- \\
    e\_fluence & + & -- & -- & -- & -- & -- \\
    q\_fluence & + & -- & -- & -- & -- & -- \\
    ratio & + & -- & -- & -- & -- & -- \\
    e\_ratio & + & -- & -- & -- & -- & -- \\
    q\_ratio & + & -- & -- & -- & -- & -- \\
    qe\_ratio & + & -- & -- & -- & -- & -- \\
    eq\_ratio & + & -- & -- & -- & -- & -- \\
    response & -- & + & -- & -- & -- & -- \\
    e\_response & -- & + & -- & -- & -- & -- \\
    q\_response & -- & + & -- & -- & -- & -- \\
    transmittance & -- & -- & + & -- & + & -- \\
    absorptance & -- & -- & + & -- & + & -- \\
    absorbance & -- & -- & + & -- & + & -- \\
    reflectance & -- & -- & -- & + & + & -- \\
    range & + & + & + & + & + & + \\
    min & + & + & + & + & + & + \\
    max & + & + & + & + & + & + \\
    stepsize & + & + & + & + & + & + \\
    spread & + & + & + & + & + & + \\
    midpoint & + & + & + & + & + & + \\
    labels & + & + & + & + & + & + \\
    summary & + & + & + & + & + & + \\
    peaks & + & + & + & + & (+) & (+) \\
    valleys & + & + & + & + & (+) & (+) \\
    integrate\_spct & + & + & + & + & + & + \\
    average\_spct & + & + & + & + & + & + \\
    color & + & -- & -- & -- & -- & -- \\
    \bottomrule
  \end{tabular}
  \end{footnotesize}

\end{table}

\begin{table}
  \caption[Summary methods for collections of spectra]{Summary methods for collections of spectra. Key: + available, -- not available, \textbf{ms} use \texttt{msmsply()} to apply function to collection members, \textbf{d} use \texttt{msdply()}, \textbf{l} use \texttt{mslply} to apply function to collection members, \textbf{a} use \texttt{msaply} to apply function to collection members.}\label{tab:summaries:mspct}
  \centering
  \begin{footnotesize}
  \begin{tabular}{>{\ttfamily}lcccccc}
    \toprule
    \textnormal{methods} & source & response & filter & reflector & object & chroma \\
    \midrule
    f\_mspct & + & + & + & + & + & + \\
    \midrule
    irrad & + & -- & -- & -- & -- & -- \\
    e\_irrad & + & -- & -- & -- & -- & -- \\
    q\_irrad & + & -- & -- & -- & -- & -- \\
    fluence & + & -- & -- & -- & -- & -- \\
    e\_fluence & + & -- & -- & -- & -- & -- \\
    q\_fluence & + & -- & -- & -- & -- & -- \\
    ratio & + & -- & -- & -- & -- & -- \\
    e\_ratio & + & -- & -- & -- & -- & -- \\
    q\_ratio & + & -- & -- & -- & -- & -- \\
    qe\_ratio & + & -- & -- & -- & -- & -- \\
    eq\_ratio & + & -- & -- & -- & -- & -- \\
    response & -- & + & -- & -- & -- & -- \\
    e\_response & -- & + & -- & -- & -- & -- \\
    q\_response & -- & + & -- & -- & -- & -- \\
    transmittance & -- & -- & + & -- & + & -- \\
    absorptance & -- & -- & + & -- & + & -- \\
    absorbance & -- & -- & + & -- & + & -- \\
    reflectance & -- & -- & -- & + & + & -- \\
    range & + & + & + & + & + & + \\
    min & + & + & + & + & + & + \\
    max & + & + & + & + & + & + \\
    stepsize & + & + & + & + & + & + \\
    spread & + & + & + & + & + & + \\
    midpoint & + & + & + & + & + & + \\
    labels & \textbf{l} & \textbf{l} & \textbf{l} & \textbf{l} & \textbf{l} & \textbf{l} \\
    summary & \textbf{l} & \textbf{l} & \textbf{l} & \textbf{l} & \textbf{l} & \textbf{l} \\
    peaks & + & + & + & + & (+) & (+) \\
    valleys & + & + & + & + & (+) & (+) \\
    integrate\_spct & \textbf{a, d, l} & \textbf{a, d, l} & \textbf{a, d, l} & \textbf{a, d, l} & \textbf{a, d, l} & \textbf{a, d, l} \\
    average\_spct & \textbf{a, d, l} & \textbf{a, d, l} & \textbf{a, d, l} & \textbf{a, d, l} & \textbf{a, d, l} & \textbf{a, d, l} \\
    color & + & -- & -- & -- & -- & -- \\
    \bottomrule
  \end{tabular}
  \end{footnotesize}

\end{table}

\subsection{Summary}

Specialized definitions of \texttt{summary} and the corresponding \texttt{print} methods are available for spectral objects. In the case of \texttt{source\_spct} objects the \texttt{time.unit} attribute makes it possible to print the summary using the correct units.

<<>>=
summary(sun.spct)
@

\subsection{Wavelength}

\subsubsection{Individual spectra}

The `usual' and a couple of new summary functions are available for spectra, but redefined to return wavelength based summaries in nanometres (nm).

<<>>=
range(sun.spct)
min(sun.spct)
max(sun.spct)
midpoint(sun.spct)
spread(sun.spct)
stepsize(sun.spct)
@

\subsubsection{Collections of spectra}

\begin{framed}
\noindent
Most frequently used summary methods are implemented for collections of spectra. See Table \ref{tab:summaries:mspct} where methods that need to be applied with functions \texttt{msaply}, \texttt{msdply} or \texttt{mslply} to members in a collection and obtain the results in an array (vector, or matrix), a data frame or a list object are indicated. In many cases depending of the class desired for the result, one can chose a suitable `apply' function, and sometimes it is best to use such a function, even when the corresponding method is implemented for collections of spectra.
\end{framed}

Collections of spectra can be useful not only for time-series of spectra or spectral images, but also when dealing with a small group of related spectra. In the example below we show how to use a collection of spectra for calculating summaries. The spectra in a collection do \textbf{not} need to have been measured at the same wavelength values, or have the same number of rows or even of columns. Consequently, in many cases applying the wavelength summary functions described above to collections of spectra can be useful. The value returned is a data frame, with a number of data columns equal to the length of the returned value by the corresponding method for individual spectra.

<<>>=
filters.mspct <- filter_mspct(list(none = clear.spct,
                                   ug1 = schott.mspct[["UG1"]],
                                   gg400 = schott.mspct[["GG400"]]))
range(filters.mspct)
@

\subsection{Peaks and valleys}

\subsubsection{Individual spectra}

Functions \texttt{peaks} and \texttt{valleys} take spectra as first argument and return a subset of the spectral object data corresponding to local maxima and local minima of the measured variable. \texttt{span} defines the width of the `window' used as a number of observations.

<<>>=
peaks(sun.spct, span = 51)
valleys(sun.spct, span = 51)
@

In the case of \texttt{source\_spct} and \texttt{response\_spct} methods \texttt{unit.out} can be used to force peaks to be searched using either energy or photon based spectral irradiance. The default is energy, or the option \texttt{"photobiology.radiation.unit"} if set.

<<>>=
peaks(sun.spct, span = 51, unit.out = "photon")
@

It is possible to approximately set the width of the windows in nanometres by using function \texttt{step\_size}. However, here we simply use an odd number of wavelengths `steps'.

<<>>=
peaks(sun.spct, span = 21)
@

Low level functions \texttt{find\_peaks}, \texttt{get\_peaks} and \texttt{get\_valleys} take numeric vectors as arguments.

\subsubsection{Collections of spectra}

We can use \texttt{msmsply()} to extract the peaks of a collection of spectra.

<<>>=
msmsply(filters.mspct, peaks, span = 11)
@

Two of the filters in the collection do not have peaks, and a spectrum object of length zero is returned for them.

\subsection{Irradiance}

\subsubsection{Individual spectra}

The code using \texttt{spct} objects is simple, to integrate the whole spectrum we can use

<<>>=
irrad(sun.spct)
@

and, to integrate a range of wavelengths, in the example, photosynthetically active radiation, we use the predefined waveband constructor \texttt{PAR()}.

<<>>=
irrad(sun.spct, PAR())
@

The default for \texttt{irrad}, when no argument \texttt{unit.out} is supplied, is to return the irradiance value in energy irradiance units, unless the R option \texttt{photobiology.radiation.unit} is set.

\sloppy
Functions \texttt{e\_irrad} and \texttt{q\_irrad} save some typing, and always return the same type of spectral irradiance quantity, independently of global option \texttt{photobiology.radiation.unit}.

<<>>=
e_irrad(sun.spct, PAR()) # W m-2
q_irrad(sun.spct, PAR()) * 1e6 # umol s-1 m-2
@

It is also possible to supply a time unit to use as basis of expression for the returned value, but be aware that conversion into a loger time unit is only valid for sources like lamps, which have an output the remains constant in time.

<<>>=
irrad(sun.spct, PAR(), time.unit = "hour")
irrad(sun.spct, PAR(), time.unit = duration(8, "hours"))
@

Using a shorter time unit than the original, yields an average value re-expressed on a new time unit base.

<<>>=
irrad(sun.daily.spct, PAR(), time.unit = "second")
@

Lists of wavebands are also accepted as argument.

<<>>=
my_wavebands <- list(Red(), Blue(), Green())
e_irrad(sun.spct, my_wavebands) # W m-2
@

These functions have an additional argument \texttt{quantity}, with default \texttt{"total"}, which can take values controlling the output. The value "total" yields \textbf{irradiance} in \watt, integrated over wavelengths for each waveband, while "average" yields the mean \textbf{spectral irradiance} within each waveband in \wattnm. The value "contribution" is relative to the irradiance for the whole spectrum, expressed as a fraction of one, while the value "relative" is relative to the sum of the irradiances for the different wavbands given as argument, also expressed as a fraction of one.

<<>>=
irrad(sun.spct, UV_bands(), quantity = "total")
irrad(sun.spct, UV_bands(), quantity = "contribution")
irrad(sun.spct, UV_bands(), quantity = "relative")
irrad(sun.spct, UV_bands(), quantity = "average")
@

\subsubsection{Collections of spectra}

Collections of spectra can be useful not only for time-series of spectra or spectral images, but also when dealing with a small group of related spectra. In the example below we show how to use a collection of spectra for estimating irradiances under different filters set up in sunlight.

We first create a collection of filter spectra:
<<>>=
filters.mspct <- filter_mspct(list(none = clear.spct,
                                   ug1 = schott.mspct[["UG1"]],
                                   gg400 = schott.mspct[["GG400"]]))
@

We then convolve each filter's spectral transmittance by the spectral irradiance of the light source
<<>>=
filtered_sun <- convolve_each(filters.mspct, sun.spct)
irrad(filtered_sun, list(UVA(), VIS()))
@

The code above can also be written as a single statement
<<>>=
irrad(convolve_each(filters.mspct, sun.spct), list(UVA(), VIS()))
@

It is also possible to use an `apply' function. Syntax parallels that of base R's and package \texttt{plyr}'s. See sections \ref{sec:apply} and \ref{sec:convolve} for more details.

One thing to remember, is that operators in R are just normal functions with special names and call syntax. They can also be called with the usual function call syntax by enclosing their \emph{name} in backquotes. We use this to pass as argument the multiplication operator \texttt{`*`} in a call to \texttt{msmsply} which returns, in this case, a \texttt{source\_multi\_spct} object. After this we just call the \texttt{irrad} method on the \emph{collection of spectra} and obtain the result as a data frame with one row per spectrum and one column by waveband.

<<>>=
filtered_sun <- msmsply(filters.mspct, `*`, sun.spct)
irrad(filtered_sun, list(UVA(), VIS()))
@

\subsubsection{Numeric vectors}

The code using numeric vectors is more complicated, but adds some additional flexibility for tweaking performance. Under normal circumstances it is easier to use the functions described above.

Function \texttt{irradiance} takes an array of wavelengths (sorted in strictly increasing order), and the corresponding values of spectral irradiance. By default the input is assumed to be in energy units, but parameter \texttt{unit.in} can be used to change this default. The type of unit used for the returned quantity is set by \texttt{unit.out} with no default. The behaviour with respect to wavebands is as described above for spectral objects. The functions \texttt{photon\_irradiance()} and \texttt{energy\_irradiance()}, just call \texttt{irradiance()} with the \texttt{unit.out} set to \texttt{"photon"} or \texttt{"energy"} respectively.

The functions taking numerical vectors as arguments can be used with data stored as vectors, or using \texttt{with} with data frames, data tables, lists, and spectra objects.

<<>>=
with(sun.spct, photon_irradiance(w.length, s.e.irrad, PAR()))
@

The recommended practice is to use \texttt{with}, as above.

\subsection{Fluence}

\subsubsection{Individual spectra}

The calculation of fluence values (time-integrated irradiance) is identical to that for irradiance, except that a \texttt{exposure.time} argument needs to be supplied. The exposure time must be a \texttt{lubridate::duration}, but any argument accepted by \texttt{as.duration} can also be used. Functions \texttt{fluence}, \texttt{e\_fluence} and \texttt{q\_fluence} correspond to \texttt{irrad}, \texttt{e\_irrad} and \texttt{q\_irrad},

<<>>=
fluence(sun.spct, exposure.time = duration(1, "hours"))
fluence(sun.spct, exposure.time = 3600) # seconds
fluence(sun.spct, exposure.time = hms("01:00:00"))
@

and, to obtain the photon fluence for a range of wavelengths, in the example, photosynthetically active radiation, we use \texttt{PAR()} that is a predefined waveband constructor, for 25 minutes of exposure we use.

<<>>=
e_fluence(sun.spct, PAR(), exposure.time = hms("00:25:00"))
@

\subsection{Photon and energy ratios}

\subsubsection{Individual spectra}

The functions described here, in there simplest use, calculate a ratio between two wavebands. The function \texttt{q\_ratio} returning photon ratios. However both waveband parameters can take lists of wavebands as arguments, with normal recycling rules in effect. The corresponding function \texttt{e\_ratio} returns energy ratios.

<<>>=
q_ratio(sun.spct, UVB(), PAR())
q_ratio(sun.spct,
        list(UVC(), UVB(), UVA()),
        UV())
q_ratio(sun.spct,
        UVB(),
        list(UV(), PAR()))
@

Function \texttt{qe\_ratio}, has only one waveband parameter, and returns the `photon' to `energy' ratio, while its complement \texttt{eq\_ratio} returns the `energy' to `photon' ratio.

<<>>=
qe_ratio(sun.spct, list(Blue(), Green(), Red()))
@

\subsubsection{Collections of spectra}

<<>>=
q_ratio(filtered_sun, list(UVB(), UVA()), PAR())
@

\subsubsection{Vectors}

The function \texttt{waveband\_ratio()} takes basically the same parameters as \texttt{irradiance}, but two waveband definitions instead of one, and two \texttt{unit.out} definitions instead of one. This is the base function used in all the vector based `ratio' functions in the \PB package.

\sloppy
Similar functions \texttt{photon\_ratio()}, \texttt{energy\_ratio()}, and \texttt{photons\_energy\_ratio} return the other ratios described above. In contrast to the functions described in the previous section, these functions only accept individual waveband definitions (not lists of them).

To calculate the photon ratio between UVB and PAR photon irradiance in these to regions we use.

<<example-ratios-01>>=
with(sun.data,
     photon_ratio(w.length, s.e.irrad, UVB(), PAR())
)
@

\subsection{Normalized difference indexes}

\subsection{Individual spectra}

These indexes are frequently used to summarize reflectance data, for example in remote rensing the NDVI (normalized difference vegetation index). Here we give an \emph{unusual} example to demonstrate that function \texttt{normalized\_diff\_ind()} can be used to calculate, or define any similar index.

<<>>=
normalized_diff_ind(sun.spct,
                    waveband(c(400, 700)), waveband(c(700, 1100)),
                    irrad)
@

\subsection{Transmittance, reflectance, absorptance and absorbance}

\subsubsection{Individual spectra}

The functions \texttt{transmittance}, \texttt{absorptance} and \texttt{absorbance} take \texttt{filter\_spct} as argument, while function \texttt{reflectance} takes \texttt{reflector\_spct} objects as argument. Functions \texttt{transmittance}, \texttt{reflectance} and \texttt{absorptance} are also implemented for \texttt{object\_spct}. These functions return as default an average value for these quantities \textbf{assuming} a light source with a flat spectral energy output, but this can be changed as described above for \texttt{irrad()}.

<<>>=
transmittance(polyester.spct, list(UVB(), UVA(), PAR()))
@

It is more likely that we would like to calculate these values with reference to light of a certain spectral quality. This needs to be calculated by hand, which is not difficult.

<<>>=
irrad(sun.spct * polyester.spct, list(UVB(), UVA(), PAR()), wb.trim = TRUE) /
  irrad(sun.spct, list(UVB(), UVA(), PAR()), wb.trim = TRUE)
@

\subsubsection{Collections of spectra}

Here we construct a collection of filter spectra, and then we calculate the transmittance of these filters for two wavebands, obtaining the results as a data frame, with one row per filter, and one column per waveband.

<<>>=
filters.mspct <- filter_mspct(list(none = clear.spct,
                                   ug1 = schott.mspct[["UG1"]],
                                   gg400 = schott.mspct[["GG400"]]))
transmittance(filters.mspct, list(UVA(), VIS()))
@

\subsection{Integrated response}

\subsubsection{Individual spectra}

The functions  \texttt{response}, \texttt{e\_response} and \texttt{q\_response} take \texttt{response\_spct} objects as arguments, and return the integrated value for each waveband (integrated over wavelength) \textbf{assuming} a light source with a flat spectral energy or photon output respectively. If no waveband is supplied as argument, the whole spectrum is integrated.

<<>>=
response(Vital_BW_20.spct)
@

When a waveband, or list of wavebands, is supplied the response is calculated for the wavebands.

<<>>=
e_response(Vital_BW_20.spct, list(UVB(), UVA()))
@

This function has an additional argument \texttt{quantity}, with default \texttt{"total"}, as described for \texttt{irrad()}.

\subsubsection{Collections of spectra}

<<>>=
sensors <- response_mspct(list(BW20 = Vital_BW_20.spct,
                               Berger = Berger_UV_erythemal.spct))
response(sensors, list(UVC(), UVB(), UVA()), quantity = "contribution")
@

\subsection{Integration over wavelengths}

When we need to integrate some \emph{non-standard} \texttt{numeric} variable stored in a spectral object we can use functions \texttt{integrate\_spct} or \texttt{average\_spct}.

\subsubsection{Calculation from individual spectra}

We can integrate the values of arbitrary \texttt{numeric} columns other than \texttt{w.length} in an spectral object. All spectral classes are derived from \texttt{generic\_spct}, so the examples in this section apply to objects of any of the derived spectral classes as well.

<<>>=
integrate_spct(sun.spct)
@

The function \texttt{average\_spct} integrates every column holding numeric values from a spectrum object, except for \texttt{w.length}, and divides the result by the \emph{spread} or width of the wavelength range integrated, returning a value expressed in the same units as the spectral data.

<<>>=
average_spct(sun.spct)
@


\section{Astronomy}

\subsection{Position of the sun}

In photobiology research we sometimes need to calculate the position on the sun at arbitrary locations and positions. The function \texttt{sun\_angles} returns the azimuth in degrees eastwards, altitude in degrees above the horizon, solar disk diameter in degrees and sun to earth distance in astronomical units. The time should be a \texttt{POSIXct} vector, possibly of length one, and it is easiest to use package \texttt{lubridate} for working with time and dates.

<<>>=
sun_angles(now(), lat = 34, lon = 0)
sun_angles(ymd_hms("2014-01-01 0:0:0", tz = "UTC"))
@

When spectra contain suitable metadata, the position of the sun for the
spectral irradiance data measurement can be easily obtained.

<<>>=
sun_angles(getWhenMeasured(sun.spct), geocode = getWhereMeasured(sun.spct))
@

The object to be supplied as argument for \texttt{geocode} is a data frame with variables \texttt{lon} and \texttt{lat}. This matches the return value of function \texttt{ggmap::geocode()}, function that can be used to find the coordinates using any `address' entered as a character string understood by the Google maps API. We will not demonstrate this below, but all functions taking \texttt{lat} and \texttt{lon} arguments described can alternatively be supplied a geocode argument instead of separate latitude and longitude numeric values.

\subsection{Times of sunrise, solar noon and sunset}

Functions \texttt{sunrise\_time}, \texttt{sunset\_time}, \texttt{noon\_time}, \texttt{day\_length} and \texttt{night\_length} have all the same parameter signature. In addition, function \texttt{day\_night} returns a list containing all the quantities returned by the other functions. They are all vectorized for the
\texttt{date} parameter.

We create a vector of dates to use in the examples---default time zone of \texttt{ymd} is UTC or GMT.

<<>>=
dates <- seq(from = ymd("2015-03-01"), to = ymd("2015-07-1"), length.out = 3)
@

Default latitude is zero (the Equator), the default longitude is zero (Greenwich), and default time zone for the functions in the \texttt{photobiology} package is \texttt{"UTC"}. Be also aware that for summer dates the times are expressed accrodingly. In the examples below this can be recognized for example, by the time zone being reported as EEST instead of EET for Eastern Europe.

<<>>=
noon_time(dates, tz = "UTC", lat =  60)
noon_time(dates, tz = "CET", lat =  60)
@

<<>>=
day_night(dates, lat =  60)
@

The default for \texttt{date} is the current day.

<<>>=
sunrise_time(lat = 60)
@

Both latitude and longitude can be supplied, but be aware that if the returned value is desired in the local time coordinates, the time zone should match the longitude.

<<>>=
sunrise_time(today(tzone = "UTC"), tz = "UTC", lat = 60, lon = 0)
sunrise_time(today(tzone = "EET"), tz = "EET", lat = 60, lon = 25)
@

Southern hemisphere latitudes as well as longitudes to the West of the Greenwich meridian should be supplied as negative numbers.

<<>>=
sunrise_time(dates, lat =  60)
sunrise_time(dates, lat = -60)
@

The angle used in the twilight calculation can be supplied, either as the name of a standard definition, or as an angle in degrees (negative for sun positions below the horizon). Positive angles can be used when the time of sun occlusion behind a building, mountain, or other obstacle needs to be calculated.

<<>>=
sunrise_time(today(tzone = "EET"), tz = "EET", lat = 60, lon = 25,
             twilight = "civil")
sunrise_time(today(tzone = "EET"), tz = "EET", lat = 60, lon = 25,
             twilight = -10)
sunrise_time(today(tzone = "EET"), tz = "EET", lat = 60, lon = 25,
             twilight = +12)
@

Parameter \texttt{unit.out} can be used to obtain the returned value expresed as time-of-day in hours, minutes, or seconds since midnight.

<<>>=
sunrise_time(today(tzone = "EET"), tz = "EET", lat = 60, lon = 25,
             unit.out = "hour")
@

Functions \texttt{day\_length} and \texttt{night\_length} return by default the length of time in hours.

<<>>=
day_length(dates, lat = 60)
night_length(dates, lat = 60)
@

Function \texttt{day\_night} returns a list.

<<>>=
day_night(dates, lat = 60)
day_night(dates, lat = 60, unit.out = "hour")
@

\section{RGB colours}

Two functions allow calculation of simulated colour of light sources as R colour definitions. Three different functions are available, one for monochromatic light taking as argument wavelength values, and one for polychromatic light taking as argument spectral energy irradiances and the corresponding wave length values. The third function can be used to calculate a representative RGB colour for a band of the spectrum represented as a range of wavelength, based on the assumption of a flat energy irradiance across the range.
By default CIE coordinates for \textit{typical} human vision are used, but the functions
have a parameter that can be used for supplying a different chromaticity definition.

Examples for monochromatic light:

<<>>=
w_length2rgb(550) # green
w_length2rgb(630) # red
w_length2rgb(c(550, 630, 380, 750)) # vectorized
@


Examples for wavelength ranges:

<<>>=
w_length_range2rgb(c(400,700))
@

Examples for spectra as vectors, in this case for the solar spectrum:

<<>>=
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens = ciexyzCMF2.spct))
@

Examples with \texttt{source\_spct} objects.

<<>>=
rgb_spct(sun.spct)
rgb_spct(sun.spct, sens = ciexyzCMF2.spct)
@

And also a \texttt{color} method for \texttt{source\_spct}.

<<>>=
color(sun.spct)
color(sun.spct * schott.mspct[["RG630"]])
@

\section{Optimizing performance}

When developing the current version of \PB quite a lot of effort was spent in optimizing performance, especially of the functions accepting vectors as arguments, as in one of our experiments, we need to process several hundred thousands of measured spectra. The defaults should provide good performance in most cases, however, some further improvements are achievable, when a series of different calculations are done on the same spectrum, or when a series of spectra measured at exactly the same wavelengths are used for calculating weighted irradiances or exposures.

In the case of doing calculations repeatedly on the same spectrum, a small improvement in performance can be achieved by setting the parameter \texttt{check.spectrum = FALSE} for all but the first call to \texttt{irradiance()}, or \texttt{photon\_irradiance()}, or \texttt{energy\_irradiance()}, or the equivalent function for ratios. It is also possible to set this parameter to FALSE in all calls, and do the check beforehand by explicitly calling \texttt{check\_spectrum()}.

In the case of calculating weighted irradiances on many spectra having exactly the same wavelength values, then a significant improvement in the performance can be achieved by setting \texttt{use.cached.mult = TRUE}, as this reuses the multipliers calculated during successive calls based on the same waveband. However, to achieve this increase in performance, the tests to ensure that the wavelength values have not changed, have to be kept to the minimum. Currently only the length of the wavelength array is checked, and the cached values discarded and recalculated if the length changes. For this reason, this is not the default, and when using caching the user is responsible for making sure that the array of wavelengths has not changed between calls.

You can use the package \texttt{microbenchmark} to time the code and find the parts that slow it down. I have used it, and also
I have used profiling to optimize the code for speed. The choice of defaults is based on what is
best when processing a moderate number of spectra, say less than a few hundreds, as opposed to many thousands.

\section{Example data}

A few example spectra are included in this package for use in examples and vignettes, and testing (Tables \ref{tab:data:spct} and \ref{tab:data:chroma}).

\begin{table}
\caption{Data sets included in the package: spectra. The CIE standard illuminant data in this package are normalized to one at $\lambda = 560\,$nm, while in the CIE standard they are normalized to 100 at the same wavelength.}\label{tab:data:spct}
\centering
\begin{footnotesize}
\begin{tabular}{>{\ttfamily}l>{\ttfamily}lll}
\toprule
\textnormal{Object} & \textnormal{class} & units & data description \\
\midrule
sun.spct & source\_spct & \wattnm & solar spectral irradiance \\
sun.daily.spct & source\_spct & \jdaynm & solar spectral exposure \\
sun.data & data.frame & \wattnm & solar spectral irradiance \\
sun.daily.data & data.frame & \jdaynm & solar spectral exposure\\
D65.illuminant.spct & source\_spct & (norm. 560 nm) & CIE standard \\
A.illuminant.spct & source\_spct & (norm. 560 nm)  & CIE standard \\
\bottomrule
\end{tabular}
\end{footnotesize}
\end{table}


\begin{table}
\caption{Data sets included in the package: chromaticity data}\label{tab:data:chroma}
\centering
\begin{footnotesize}
\begin{tabular}{>{\ttfamily}l>{\ttfamily}ll}
\toprule
\textnormal{Object} & \textnormal{class} & data description \\
\midrule
ciexyzCC2.spct & chroma\_spct &  human chromaticity coordinates $2^\circ$ \\
ciexyzCC10.spct & chroma\_spct &   human chromaticity coordinates $10^\circ$  \\
ciexyzCMF2.spct & chroma\_spct &   human colour matching function $2^\circ$ \\
ciexyzCMF10.spct & chroma\_spct &  human colour matching function $10^\circ$ \\
ciev2.spct & chroma\_spct &  human luminous efficiency $2^\circ$ \\
ciev10.spct & chroma\_spct &   human luminous efficiency $10^\circ$ \\
beesxyzCMF.spct &  chroma\_spct &  bee colour matching function \\
\bottomrule
\end{tabular}
\end{footnotesize}
\end{table}


\end{document}
