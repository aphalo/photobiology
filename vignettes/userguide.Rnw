%\VignetteEngine{knitr}
%\VignetteIndexEntry{User guide}
%\VignetteDepends{knitr, photobiology, photobiologyUV, photobiologyVIS, photobiologyFilters, ggplot2, ggtern}
%\VignetteKeyword{misc}

\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\usepackage{listings}
%\usepackage{booktabs}
%\usepackage{breakurl}
\usepackage{xspace}
\usepackage{framed}

\newcommand{\PB}{\textsf{photobiology}\xspace}
\newcommand{\PBVIS}{\textsf{photobiologyVIS}\xspace}
\newcommand{\PBUV}{\textsf{photobiologyUV}\xspace}
\newcommand{\PBPHY}{\textsf{photobiologyPhy}\xspace}
\newcommand{\PBCRY}{\textsf{photobiologyCry}\xspace}
\newcommand{\PBFLT}{\textsf{photobiologyFilters}\xspace}
\newcommand{\PBLA}{\textsf{photobiologyLamps}\xspace}

\newcommand{\UV}{UV\xspace}
\newcommand{\UVB}{UV-B\xspace}
\newcommand{\UVA}{UV-A\xspace}

\newcommand{\Unit}[1]{\ensuremath{\mathrm{#1}}\xspace}

\newcommand{\watt}{\Unit{W\,m^{-2}}}
\newcommand{\wattnm}{\Unit{W\,m^{-2}\,nm^{-1}}}
\newcommand{\mwattnm}{\Unit{mW\,m^{-2}\,nm^{-1}}}
\newcommand{\mol}{\Unit{mol\,m^{-2}\,s^{-1}}}
\newcommand{\molnm}{\Unit{mol\,m^{-2}\,s^{-1}\,nm^{-1}}}

\begin{document}

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(fig.path='figure/pos-', fig.align='center', fig.show='hold', size="footnotesize", dev='cairo_pdf')
options(replace.assign=TRUE,width=60)
@

<<example-0-hiden, eval=TRUE, include=FALSE>>=
library(photobiology)
library(photobiologyUV)
library(photobiologyVIS)
library(photobiologyFilters)
library(ggplot2)
library(ggtern)
@

<<own-set-up, echo=FALSE, include=FALSE>>=
my_version <- packageVersion("photobiology")
@

\title{\PB Version \Sexpr{my_version}\\ User Guide}
\author{Pedro J. Aphalo}

\maketitle

\section{Introduction}

We have developed a set of packages to
facilitate the calculation of many different quantities that can be derived from spectral irradiance data. The base package in this suite is called \PB, and is the package described here. There other specialized packages for quantification of ultraviolet radiation (\PBUV), visible radiation (\PBVIS), or based on Phytochrome (\PBPHY), Cryptochrome (\PBCRY) (both photoreceptors present in plants), and
spectral data for filters (\PBFLT). In the future it will be submitted to CRAN (Comprehensive R archive network), it is meanwhile available from \url{https://bitbucket.org/aphalo/photobiology/downloads}. There is also a public Git repository at \url{https://bitbucket.org/aphalo/photobiology} from where the source code of the current an earlier versions can be cloned.

\section{Installation and use}

The functions in the package \PBPHY are
made available by installing the packages \verb!photobiology! (once) and
loading it from the library when needed.

To load the package into the workspace we use \verb!library(photobiology)!.

<<example-0-visible, eval=FALSE>>=
library(photobiology)
library(photobiologyUV)
library(photobiologyVIS)
library(photobiologyFilters)
library(ggplot2)
library(ggtern)
@

\section{Data formats}

The package provides two sets of functions for many operations: functions programmed following a functional paradigm, and functions using an object-oriented paradigm. The former functions take as arguments numeric vectors and are probably faster. The later ones take `spectra' objects as arguments, are easier to use, and at least at the moment, to some extent slower. For everyday use `spectra' objects are recommended, but when maximum performance or flexibility in scripts is desired, the use of the functions taking numeric vectors as arguments may allow optimizations that are not possible with the object-oriented higher level functions.

\subsection{Using numeric vectors}

When dealing with spectra, we operate on pairs of vectors, one with the wavelengths in nm, and a second one with the corresponding values for the spectral data.

It is usual to `group' these two (or more) vectors into a data frame. For vectors within a data frame we need to `make them visible' when operating with the functions that expect numeric vectors as arguments.

\subsection{Using `spectra' objects}

This package defines a family of objects based on data tables (data frame compatible objects) which impose some restrictions on the naming of the vectors, something that allows the second set of functions to `find' the data when passed one of these objects as argument. In addition, as the data is checked when the object is built, there is no need to test for the validity of the data each time a calculation is carried out. The other advantage of using \texttt{spct} objects, is that specialized versions of generic functions like \texttt{print} and operators like \texttt{+} can be defined for spectra. \texttt{spct} objects are derived from data.table objects, which in turn are derived from data.frame objects. In this package we define a \textit{generic} spectrum type of object, derived from data table, from which specialized types of spectra are derived. This `parenthood' hierarchy means that spectra objects can be used almost anywhere where a \texttt{data.frame} or \texttt{data.table} is expected. Many functions defined in package \texttt{data.table} and useful when working with spectra are re-exported by the current package, so that in most cases there is no need to explicitly include \texttt{library(data.table)} in your scripts.

Although \texttt{data.tables} are syntactically compatible with \texttt{data.frames}, in some special cases the same code may have different semantics as data tables use references in some cases were data frames would use a copy of the data. In general, no such problems exist, and the different semantics only applies to data table specific syntax. If in doubt, to avoid problems, when you really intend to make a new copy of a spectrum, preserving the original object unchanged by later operations on the new `name', use function \texttt{copy} in addition to the assignment operator.

<<>>=
# 1) data frame syntax on a data.frame
a.df <- data.frame(x=1:3, y=rep(1, 3))
b.df <- a.df
b.df$y <- b.df$y * 2
b.df
a.df # not modified!
# 2) data frame syntax on a data.table
a.dt <- data.table(x=1:3, y=rep(1, 3))
b.dt <- a.dt
b.dt$y <- b.dt$y * 2
b.dt
a.dt # not modified!
# 3) data table syntax on a data.table
a.dt <- data.table(x=1:3, y=rep(1, 3))
b.dt <- a.dt
b.dt[ , y := y * 2]
a.dt # modified!
# 4) forcing creation of a copy
a.dt <- data.table(x=1:3, y=rep(1, 3))
c.dt <- copy(a.dt)
c.dt[ , y := y * 2]
a.dt # not modified!
@

From the examples above one can see that in example 3) \texttt{b.dt} is not a copy of \texttt{a.dt}, but instead a reference (a new name pointing to the original object), while in examples 1), 2) and 4) \texttt{b.dt}, is a new object, initialized to the value of \texttt{a.dt}.

\section{Spectral data}

If our spectral irradiance data is in \wattnm, and the wavelength in nm, as in the case of
the Macam spectroradiometer, the functions will return the effective irradiance in \watt. In this
example we calculated a biologically effective irradiance.

If, for example, the spectral irradiance output by our model of spectroradiometer is in m\wattnm,
and the wavelengths are in Ã…ngstrom then to obtain the effective irradiance in \watt we will
need to convert the units.

<<example-1, eval=FALSE>>=
energy_irradiance(wavelength/10,irrad/1000)
@

In the example above, we take advantage of the behavior of the S language: an operation between a scalar
and vector, is equivalent to applying this operation to each member of the vector.
Consequently, in the code above, each value from the vector of wavelengths is divided
by 10, and each value in the vector of spectral irradiances is divided by 1000.

If the spectral irradiance is in \mwattnm then values should be multiplied by 10 to
convert them to \wattnm.

It is very important to make sure that the wavelengths are in nanometres as this is what
all functions expect. If the wavelengths are in the wrong units, the action spectra will be
wrongly calculated, and the returned value for effective irradiance will be completely wrong.

\subsection{Creation}

\texttt{generic.spct} objects can be created from data tables and data frames simply by setting then as such. However, a column called \texttt{w.length} must be present and contain wavelength values expressed in nm.

<<>>=
a.spct <- setGenSpct(data.table(w.length = 300:305, y = rep(1,6)))
class(a.spct)
a.spct
@

\texttt{source.spct} objects can be created from data tables, data frames, and \texttt{generic.spct} simply by setting then as such. However, a columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{s.e.irrad} (\wattnm) and\textbackslash or \texttt{s.q.irrad} (\molnm) must be present.

<<>>=
b.spct <- setSourceSpct(data.table(w.length = 300:305, s.e.irrad = rep(1,6)))
class(b.spct)
b.spct
@

\texttt{filter.spct} objects can be created from data tables, data frames, and \texttt{generic.spct} simply by setting then as such. However, columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{Tpc} (T\%), \texttt{Tfr} (T as fraction of 1) and\textbackslash or \texttt{A} (absorbance ($\log_{10}$ based)) must be present.

<<>>=
c.spct <- setFilterSpct(data.table(w.length = 300:305, Tfr = rep(1,6)))
class(c.spct)
c.spct
@

\texttt{reflector.spct} objects can be created from data tables, data frames, and \texttt{generic.spct} simply by setting then as such. However, columns called \texttt{w.length} (wavelength values expressed in nm) and \texttt{Rpc} (R\%), and\textbackslash or \texttt{Rfr} (R as fraction of 1) must be present.

<<>>=
c.spct <- setReflectorSpct(data.table(w.length = 300:305, Rfr = rep(1,6)))
class(c.spct)
c.spct
@

If the expected data is not available, then it is filled in if possible with values, and if not with NAs.

<<>>=
d.spct <- setReflectorSpct(data.table(w.length = 300:305, Rpc = rep(100,6)))
class(d.spct)
d.spct
@

<<>>=
e.spct <- setReflectorSpct(data.table(w.length = 300:305, z = rep(1,6)))
class(e.spct)
e.spct
@

<<>>=
e.spct <- setReflectorSpct(data.table(wl = 300:305, Rfr = rep(1,6)))
class(e.spct)
e.spct
@

Here we just use the example data supplied with the packages.

<<>>=
class(sun.spct)
sun.spct
@

\section{Working with spectral objects}

\subsection{Conversions}

The functions \texttt{e2q} and \texttt{q2e} can be used on source spectra to convert spectral energy irradiance into spectral photon irradiance and vice versa. The first argument should be a spectrum, and the second optional argument sets the action with \texttt{"add"} and \texttt{"replace"} as possible values. In the second case the whole spectrum object is copied, while in the first case a column is added but the unchanged columns are references to the original ones, rather than copies.

<<>>=
b.spct
b1.spct <- e2q(b.spct, "replace")
b.spct
b1.spct

b2.spct <- e2q(b.spct, "add")
b.spct
b2.spct
@

For \texttt{filter.spct} objects functions \texttt{T2A} and \texttt{A2T} allow conversion between spectral transmittance and spectral absorbance and vice versa.

\subsection{Remapping a spectrum to different wavelengths}

Converting spectra available at a given set of wavelengths values to a different one, is frequently needed when operating with several spectra of different origin. One can increase the \emph{apparent} resolution by interpolation, and reduce it by local averaging or smoothing and resampling. The same function works on all \texttt{spct} objects, interpolating every column except \texttt{w.length} and replacing in this last column the old wavelength values with the new ones supplied as argument. The optional argument \texttt{fill.value} control what value is assigned to wavelengths in the new data that are outside the range of the new wavelengths.

<<>>=
interpolate_spct(sun.spct, seq(400, 500, by=0.1))
@


\subsection{Summaries}

Functions \texttt{integrate\_spct} and \texttt{average\_spct} take into account each individual wavelength step, so they return valid results even for spectra measured at arbitrary and varying wavelength steps.

<<>>=
integrate_spct(sun.spct)
average_spct(sun.spct)
@

'Normal' and a couple of new functions are also available for spectra, but redefined to return wavelengths.

<<>>=
range(sun.spct)
min(sun.spct)
max(sun.spct)
midpoint(sun.spct)
spread(sun.spct)
@

The \texttt{data.table} definition of \texttt{summary} returns column-wise results that should be interpreted with care if the wavelength step is not constant.

<<>>=
summary(sun.spct)
@

\section{Using operators with spectra}

The basic math operators have definitions for spectra. It is possible to sum, subtract, multiply and divide spectra. These operators can be used even if the spectral data is on different arbitrary sets of wavelengths.

<<>>=
sun.spct / sun.spct
sun.spct + sun.spct
@

Operators are also defined for operations between an spectrum and a numeric vector (with normal recycling).

<<>>=
sun.spct * 2
sun.spct * c(0,1)
@

\section{Defining wavebands}

All functions use \texttt{waveband}s as definitions of the range of wave lengths and the spectral weighting function (SWF) to use in the calculations. A few other bits of information may be included to fine-tune calculations. The waveband definitions do NOT describe whether input spectral irradiances are photon or energy based, nor whether the output irradiance will be based on photon or energy units. Waveband objects belong to the S3 class "waveband".

When defining a waveband which uses a SWF, a function can be supplied either based on energy effectiveness, on photon effectiveness, or one function for each one. If only one function is supplied the other one is built automatically, but if performance is a concern it is better to provide two separate functions. Another case when you might want to enter the same function twice, is if you are using an absorptance spectrum as SWF, as the percent of radiation absorbed will be independent of whether photon or energy units are used for the spectral irradiance.

<<example-waveband-01, eval=TRUE>>=
my_PAR <- new_waveband(400, 700)
my_PARx <- new_waveband(400, 700, wb.name="my_PARx")

my_CIE_1 <-
  new_waveband(250, 400, weight="SWF", SWF.e.fun=CIE.e.fun, SWF.norm=298)
my_CIE_2 <-
  new_waveband(250, 400, weight="SWF", SWF.q.fun=CIE.q.fun, SWF.norm=298)
my_CIE_3 <-
  new_waveband(250, 400, weight="SWF", SWF.e.fun=CIE.e.fun,
                         SWF.q.fun=CIE.q.fun, SWF.norm=298)
@

\section{Calculating irradiance or exposure}

There is one basic function for these calculations \texttt{irradiance()}, it takes an array of wavelengths (sorted in strictly increasing order), and the corresponding values of spectral irradiance. By default the input is assumed to be in energy units, but parameter \texttt{unit.in} cab be used to adjust the calculations to expect photon units. The type of unit used for the calculated irradiance (or exposure) is set by the parameter \texttt{unit.out} with no default. If no \texttt{w.band} parameter is supplied, the whole spectrum spectrum input is used, unweighted, to calculate the total irradiance. If a \texttt{w.band} is supplied, then the range of wavelengths specified and SWF if present are used for calculating the irradiance. If the waveband definition does not include a SWF, then the unweighted irradiance is returned, if the definition includes a SWF, then a weighted irradiance is returned.

The functions \texttt{photon\_irradiance()} and \texttt{energy\_irradiance()}, just call \texttt{irradiance()} with the \texttt{unit.out} set to \texttt{"photon"} or \texttt{"energy"} respectively.

Then we compare the calculations based on the different wavebands defined in the previous section and the predefined functions in the packages \PBVIS and \PBUV. The predefined functions have the advantage of allowing the specification of parameters to modify the \texttt{w.band} created. In the example bellow, we use this to set the normalization wavelength.

This is how \texttt{CIE()} is defined in \PBUV.

<<example-CIE, eval=FALSE>>=
CIE <- function(norm=298) {
  new_waveband(w.low=250, w.high=400,
               weight="SWF", SWF.e.fun=CIE.e.fun, SWF.norm=298,
               norm=norm, hinges=c(249.99, 250, 298, 328, 399.99, 400),
               wb.name=paste("CIE98", as.character(norm), sep="."))
}
@

\sloppy
The generic functions \texttt{print()}, \texttt{min()}, \texttt{max()}, \texttt{range()}, \texttt{midpoint()} and \texttt{labels()} call the corresponding special functions defined for waveband objects: \texttt{print.waveband()}, \texttt{range.waveband()}, etc.

<<>>=
PAR()
str(PAR())
range(PAR())
spread(PAR())
min(PAR())
max(PAR())
midpoint(PAR()) # gives wavelength at center
normalization(PAR())
color(PAR()) # equivalent RGB color definitions
labels(PAR())

CIE()
str(CIE())
labels(CIE())
labels(CIE(300))
normalization(CIE())
normalization(CIE(300))

labels(UVB())
labels(UVB("medical"))
labels(UVB("ISO"))
labels(new_waveband(100, 200))
labels(new_waveband(100, 200, wb.name="ANY NAME"))
labels(new_waveband(100, 200, wb.name="ANY NAME",
                    wb.label="ANY LABEL"))
@

\subsection{Irradiances from vectors}

Here we describe the functions that use vectors as arguments. In the next section we describe similar functions for \texttt{spct} objects.

The functions taking numerical vectors as arguments can be used with stored as vectors, or using \texttt{with} with data frames, data tables, lists, and spectra objects.

<<>>=
with(sun.data, photon_irradiance(w.length, s.e.irrad, PAR()))
with(sun.spct, photon_irradiance(w.length, s.e.irrad, PAR()))
@

The recommended practice is to use \texttt{with}, as above. But to keep code lines shorter and simpler we attach the data frame \texttt{sun.data} to make the contained vectors visible. The use of \texttt{w.length} and \texttt{s.e.irrad} and7or \texttt{s.q.irrad} is just our convention, and vectors of any name can be supplied as arguments.

<<example-data, eval=TRUE>>=
attach(sun.data)
@

Some examples comparing different definitions of wavebands for PAR. Photon irradiance is expressed in \mol.

<<example-irradiance-01>>=
photon_irradiance(w.length, s.e.irrad, my_PAR)
photon_irradiance(w.length, s.e.irrad, my_PARx)

photon_irradiance(w.length, s.e.irrad, PAR())
photon_irradiance(w.length, s.e.irrad, PAR()) * 1e6
@

Some examples comparing different definitions of wavebands for erythemal \UVB (CIE98) irradiance in \watt.

<<example-irradiance-02>>=
photon_irradiance(w.length, s.e.irrad, my_CIE_1)
photon_irradiance(w.length, s.e.irrad, my_CIE_2)
photon_irradiance(w.length, s.e.irrad, my_CIE_3)

energy_irradiance(w.length, s.e.irrad, my_CIE_1)
energy_irradiance(w.length, s.e.irrad, my_CIE_2)
energy_irradiance(w.length, s.e.irrad, my_CIE_3)

energy_irradiance(w.length, s.e.irrad, CIE())
energy_irradiance(w.length, s.e.irrad, CIE(298))
energy_irradiance(w.length, s.e.irrad, CIE(300))
@

Lists of wavebands are also accepted as argument.

<<>>=
energy_irradiance(w.length, s.e.irrad, list(CIE(), CIE(298), CIE(300)))
my_wavebands <- list(Red(), Blue(), Green())
energy_irradiance(w.length, s.e.irrad, my_wavebands)
@

\sloppy
The are also convenience functions for calculating how `total' irradiance is split among different contiguous bands
of the spectrum. The functions \texttt{split\_photon\_irradiance()} and \texttt{split\_energy\_irradiance()}, just call \texttt{split\_irradiance()} with the \texttt{unit.out} set to \texttt{"photon"} or \texttt{"energy"} respectively.

<<>>=
split_energy_irradiance(w.length, s.e.irrad,
                        c(300, 400, 500, 600, 700, 800))
split_energy_irradiance(w.length, s.e.irrad,
                        c(400, 500, 600, 700),
                        scale="percent")
split_photon_irradiance(w.length, s.e.irrad,
                        c(400, 500, 600, 700),
                        scale="percent")
@

Now we detach the data frame.

<<example-data-detach, eval=TRUE>>=
detach(sun.data)
@

\subsection{Irradiances from spectra}

The code using \texttt{spct} objects is much simpler.

<<>>=
e_irrad_spct(sun.spct, PAR())
q_irrad_spct(sun.spct, PAR())
@

\section{Calculating ratios}

\subsection{Ratios from vectors}

The function \texttt{waveband\_ratio()} takes basically the same parameters as \texttt{irradiance}, but two waveband definitions instead of one, and two \texttt{unit.out} definitions instead of one. This is the base function used in all the `ratio' functions in the \PB package.

\sloppy
The derived functions are: \texttt{photon\_ratio()}, \texttt{energy\_ratio()}, and \texttt{photons\_energy\_ratio}. The packages \PBVIS and \PBUV use these to define some convenience functions, and here we give and example for a function not yet implemented, but which you may find as a useful example.

If for example we would like to calculate the ratio between UVB and PAR radiation, we would use either
of the following function calls, depending on which type of units we desire.

We attach again the data frame.

<<example-data-1, eval=TRUE>>=
attach(sun.data)
@

<<example-ratios-01>>=
photon_ratio(w.length, s.e.irrad, UVB(), PAR())
energy_ratio(w.length, s.e.irrad, UVB(), PAR())
@

If we would like to calculate a conversion factor between PPFD (PAR photon irradiance in mol s-1 m-2) and PAR (energy) irradiance (W m-2) for a light source for which we have spectral data we could use the following code.

<<example-ratios-02>>=
conv.factor <- photons_energy_ratio(w.length, s.e.irrad, PAR())

PPFD.mol.photon <- 1000e-6
PAR.energy <- PPFD.mol.photon / conv.factor
print(conv.factor)
print(PPFD.mol.photon * 1e6)
print(PAR.energy)
@

The `ratio' functions do not accept lists of waveband objects as the `irradiance' functions do. This is a feature, as otherwise it would be too easy to make mistakes. It is possible to use the `irradiance' functions to calculate several ratios in one go.

<<example-ratios-03>>=
ratios <- photon_irradiance(w.length, s.e.irrad,
                            list(UVC=UVC(), UVB=UVB(), UVA=UVA())) /
  photon_irradiance(w.length, s.e.irrad, PAR())
ratios
names(ratios) <- paste(names(ratios), ":PAR", sep="")
ratios
@

\subsection{Ratios from spectra}

<<>>=
q_ratio_spct(sun.spct, UVB(), PAR())
q_ratio_spct(sun.spct,
             list(UVC(), UVB(), UVA()),
             UV())
q_ratio_spct(sun.spct,
             UVB(),
             list(UV(), PAR()))
@

<<>>=
e_ratio_spct(sun.spct, UVB(), PAR())
e_ratio_spct(sun.spct,
             list(UVC(), UVB(), UVA()),
             UV())
@

<<>>=
qe_ratio_spct(sun.spct, PAR())
qe_ratio_spct(sun.spct, list(Blue(), Green(), Red()))
@

\section{Calculating weighted spectral irradiances}

This calculation is not very frequently used, but it is very instructive to look at spectral data in this way, as it can make apparent the large effect that small measuring errors can have on the estimated effective irradiances or exposures.

\subsection{Weighted spectral irradiance from vectors}

We here plot weighted and unweighted irradiances using simulated solar spectral irradiance data.

%\cite{Kotilainenxxxx, Lindforsxxxx}.

<<weighted-spectra-01, tidy=FALSE>>=
weighted.s.e.irrad <- s.e.irrad * calc_multipliers(w.length, GEN.T())
plot(weighted.s.e.irrad/max(weighted.s.e.irrad) ~ w.length, type="l", col="red",
     xlab="Wavelength (nm)",
     ylab="UnWeighted and GEN.T weighted spectral irradiance (relative units)")
lines(s.e.irrad/max(s.e.irrad) ~ w.length, col="black")
@

\subsection{Weighted spectral irradiance from an unweighted source spectrum}

The multiplication operator is defined for operation between a \texttt{source.spct} and a \texttt{waveband}.

<<>>=
sun.CIE.spct <- sun.spct * CIE()
sun.CIE.spct
@

\section{Position of the sun in the sky}

In photobiology research we sometimes need to calculate the position on the sun at arbitrary locations and positions. The function \texttt{sun\_angles} returns the azimuth in degrees eastwards, altitude in degrees above the horizon, solar disk diameter in degrees and sun to earth distance in astronomical units. The time should be POSIXct vector, possibly of length one, and it is easiest to use package \texttt{lubridate} for working with time and dates.

<<>>=
sun_angles(now(), lat=34, lon=0)
sun_angles(ymd_hms("2014-01-01 0:0:0", tz="UTC"))
@

\section{Calculating times of sunrise and sunset}

<<>>=
day_night()
day_night(ymd("2014-05-30", tz = "UTC"), lat=30, lon=0)
day_night(ymd("2014-05-30", tz = "UTC"), lat=30, lon=0, twilight="civil")
@

\section{Calculating equivalent RGB colours for display}

Two functions allow calculation of simulated colour of light sources as R colour definitions. Three different functions are available, one for monochromatic light taking as argument wavelength values, and one for polychromatic light taking as argument spectral energy irradiances and the corresponding wave length values. The third function can be used to calculate a representative RGB colour for a band of the spectrum represented as a range of wavelength, based on the assumption of a flat energy irradiance across the range.
By default CIE coordinates for \textit{typical} human vision are used, but the functions
have a parameter that can be used for supplying a different chromaticity definition.

Examples for monochromatic light:

<<>>=
w_length2rgb(550) # green
w_length2rgb(630) # red
w_length2rgb(380) # UVA
w_length2rgb(750) # far red
w_length2rgb(c(550, 630, 380, 750)) # vectorized
@


Examples for wavelength ranges:

<<>>=
w_length_range2rgb(c(400,700))
w_length_range2rgb(400:700)
w_length_range2rgb(sun.spct$w.length)
w_length_range2rgb(550)
@

Examples for spectra as vectors, in this case for the solar spectrum:

<<>>=
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens=ciexyzCMF2.data))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens=ciexyzCMF10.data))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens=ciexyzCC2.data))
with(sun.spct, s_e_irrad2rgb(w.length, s.e.irrad, sens=ciexyzCC10.data))
@

Examples with \texttt{source.spct} objects.

<<>>=
rgb_spct(sun.spct)
rgb_spct(sun.spct, sens=ciexyzCMF2.data)
@

Here we plot the RGB colours for the range covered by the CIE 2006 proposed standard calculated at each 1 nm step:

<<>>=
wl <- c(390, 829)

my.colors <- w_length2rgb(wl[1]:wl[2])

colCount <- 40 # number per row
rowCount <- trunc(length(my.colors) / colCount)

plot( c(1,colCount), c(0,rowCount), type="n", ylab="", xlab="",
      axes=FALSE, ylim=c(rowCount,0))
title(paste("RGB colours for", as.character(wl[1]),
            "to", as.character(wl[2]), "nm"))

for (j in 0:(rowCount-1))
{
  base <- j*colCount
  remaining <- length(my.colors) - base
  RowSize <- ifelse(remaining < colCount, remaining, colCount)
  rect((1:RowSize)-0.5,j-0.5, (1:RowSize)+0.5,j+0.5,
       border="black",
       col=my.colors[base + (1:RowSize)])
}

@

Given a color in any of the above ways, yields RGB values that can be used to locate the position of any colour on Maxwell's triangle. Here using R's predefined colours.

<<>>=
colours <- c("red", "green", "yellow", "white", "orange",
             "blue", "pink", "purple")
rgb.values <- col2rgb(colours)
test.data <-
  data.frame(colour=colours,
             R=rgb.values[1, ], G=rgb.values[2, ], B=rgb.values[3, ])
maxwell.tern <- ggtern(data=test.data,
                       aes(x=R, y=G, z=B, label=colour, fill=colour)) +
  geom_point(shape=21, size=4) + geom_text(hjust=-0.3) +
  labs(x = "R", y="G", z="B") + scale_fill_identity()
maxwell.tern
@

We simulate the spectra of filtered sunlight by multiplying the solar spectrum by filter transmittance spectra.

<<>>=
yellow.light.spct <- canary.yellow.new.spct * sun.spct
green.light.spct <- moss.green.new.spct * sun.spct
polyester.light.spct <- polyester.new.spct * sun.spct
@

Now using the filtered sunlight spectra we calculate colours based on human vision photoreceptors.

<<>>=
yellow.filter <- with(yellow.light.spct, s_e_irrad2rgb(w.length, s.e.irrad))
green.filter <- with(green.light.spct, s_e_irrad2rgb(w.length, s.e.irrad))
polyester.filter <- with(polyester.light.spct, s_e_irrad2rgb(w.length, s.e.irrad))
colours <- c(yellow.filter, green.filter, polyester.filter)
rgb.values <- col2rgb(colours)
test.data <- data.frame(colour=colours,
                        R=rgb.values[1, ], G=rgb.values[2, ], B=rgb.values[3, ],
                        labels=c("canary yellow", "moss green", "polyester"))
maxwell.tern <- ggtern(data=test.data,
                       aes(x=R, y=G, z=B, fill=colour, label=labels)) +
  geom_point(shape=21, size=4) +
  geom_text(hjust=-0.15) +
  labs(x = "R", y="G", z="B")  +
  scale_fill_identity()
maxwell.tern
@

\section{Auxiliary functions}

Sometimes it is needed to add (parallel sum) between two spectra, even if the two spectra have been
measured at different wavelengths or wavelength steps. This can happen for example when we would like
to calculate the spectrum of a combination of two light sources from the individual spectra. The
function \verb|sum_spectra()| can be used in such a case. It's use is described in User Guide of the
\PBLA package.

A function \verb|interpolate_spectrum| is also included to facilitate interpolation of spectral values. It is used in the function described in the previous paragraph, but also be used by itself when interpolation is needed.
Under the hood it uses R's \verb|spline| function if there are fewer than 25 data points, and uses \verb|approx|
otherwise. It allows easier control of values to be used for extrapolation.

% Functions \verb|find_peaks| and \verb|get_peaks| can be used to find peaks (local maxima in a spectrum).

\section{Dealing with real `noisy' spectral data}

The first thing to do is to think whether any part of the spectral measurements can be \textit{a priori} known to be equal to zero. For example for the solar spectrum at ground level it is safe to assume that the spectral irradiance is zero for all wavelengths shorter than 293~nm. If the data are noisy, it is best to discard these data before calculating any effective UV doses.

In the following example we use a longer wavelength (297~nm) just to show how the function works, because the example spectral data set starts at 293~nm.

<<example-sun>>=
head(sun.spct)
@

Sub-setting can be easily done as follows if the data are in a data.frame (of course, replacing \texttt{w.length} with the name used in your data frame for the wavelengths array):

<<example-subset>>=
subsetted.sun.spct <- subset(sun.spct, w.length >= 297)
head(subsetted.sun.spct)
@

And then just use the sub-setted data in your calculations.

If the data are not in a dataframe, then there are different options: 1) create a data frame from your data, 2) use the function \texttt{trim\_tails()} from this package, or 3) just use R commands. Here we give examples of the use of \texttt{trim\_tails()}, and just use the same data as in earlier examples. First we delete all data for wavelengths shorter than 293~nm.

\subsection{Trimming spectra stored as vectors}

<<example-trim-low>>=
trimmed.sun.spct <-
  trim_tails(w.length, s.e.irrad, low.limit=297)
head(trimmed.sun.spct)
tail(trimmed.sun.spct)
@

This function returns a new data.frame and uses always the same variable names for the columns.

<<example-trim-both>>=
trimmed.both.sun.spct <-
  trim_tails(w.length, s.e.irrad, low.limit=297, high.limit=550)
head(trimmed.both.sun.spct)
tail(trimmed.both.sun.spct)
@

If we supply a different value than the default NULL for the parameter \texttt{fill}, the w.length values are kept, and the trimmed spectral irradiance values replaced by the value supplied.

<<example-trim-na>>=
trimmed.na.sun.spct <- trim_tails(w.length, s.e.irrad, low.limit=297, fill=NA)
head(trimmed.na.sun.spct)
@

<<example-trim-both-na>>=
trimmed.both.na.sun.spct <-
  trim_tails(w.length, s.e.irrad, low.limit=297, high.limit=400, fill=NA)
head(trimmed.both.na.sun.spct)
tail(trimmed.both.na.sun.spct)
@

In addition to NA we can supply an arbitrary numeric value.

<<example-trim-zero>>=
trimmed.zero.sun.spct <-
  trim_tails(w.length, s.e.irrad, low.limit=297, fill=0.0)
head(trimmed.zero.sun.spct)
@

%Using real spectral data compared to modelled spectral data for sunlight we show a finally some of the pitfalls, and possible work-arounds, for dealing with noisy measurements, and calculating effective doses from them.

<<detach>>=
detach(sun.data)
@

\subsection{Trimming spectral objects}

We can use as above \texttt{low.limit}, \texttt{high.limit}, and \texttt{fill} as in the examples above.

<<>>=
trim_spct(sun.spct, low.limit=297)
@

We can in addition do the trimming with a \texttt{waveband} object.

<<>>=
trim_spct(sun.spct, PAR())
@


\section{Optimizing performance}

When developing the current version of \PB quite a lot of effort was spent in optimizing performance, as in one of our experiments, we need to process several hundred thousands of measured spectra. The defaults should provide good performance in most cases, however, some further improvements are achievable, when a series of different calculations are done on the same spectrum, or when a series of spectra measured at exactly the same wavelengths are used for calculating weighted irradiances or exposures.

In the case of doing calculations repeatedly on the same spectrum, a small improvement in performance can be achieved by setting the parameter \texttt{check.spectrum=FALSE} for all but the first call to \texttt{irradiance()}, or \texttt{photon\_irradiance()}, or \texttt{energy\_irradiance()}, or the equivalent function for ratios. It is also possible to set this parameter to FALSE in all calls, and do the check beforehand by explicitly calling \texttt{check\_spectrum()}.

In the case of calculating weighted irradiances on many spectra having exactly the same wavelength values, then a significant improvement in the performance can be achieved by setting \texttt{use.cached.mult=TRUE}, as this reuses the multipliers calculated during successive calls based on the same waveband. However, to achieve this increase in performance, the tests to ensure that the wavelength values have not changed, have to be kept to the minimum. Currently only the length of the wavelength array is checked, and the cached values discarded and recalculated if the length changes. For this reason, this is not the default, and when using caching the user is responsible for making sure that the array of wavelengths has not changed between calls.

You can use the package \texttt{microbenchmark} to time the code and find the parts that slow it down. I have used it, and also
I have used profiling to optimize the code for speed. The choice of defaults is based on what is
best when processing a moderate number of spectra, say less than a few hundreds, as opposed to many thousands.

\end{document}
