%\VignetteEngine{knitr}
%\VignetteIndexEntry{Functions for quantifying VIS and UV radiation}
%\VignetteDepends{knitr, photobiology, photobiologyUV, photobiologyVIS}
%\VignetteKeyword{misc}

\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{breakurl}
\usepackage{xspace}

\newcommand{\PB}{\textsf{photobiology}\xspace}
\newcommand{\PBVIS}{\textsf{photobiologyVIS}\xspace}
\newcommand{\PBUV}{\textsf{photobiologyUV}\xspace}
\newcommand{\PBPHY}{\textsf{photobiologyPhy}\xspace}
\newcommand{\PBCRY}{\textsf{photobiologyCry}\xspace}
\newcommand{\PBFLT}{\textsf{photobiologyFilters}\xspace}
\newcommand{\PBLA}{\textsf{photobiologyLamps}\xspace}


\newcommand{\watt}{W m-2}
\newcommand{\wattnm}{W m-2 nm-1}
\newcommand{\mwattnm}{mW m-2 nm-1}

\begin{document}

\title{\PB Version 0.2.12\\ User Guide}
\author{Pedro J. Aphalo}

\maketitle

\section{Introduction}

We have developed a set of packages to
facilitate the calculation of many different quantities that can be derived from spectral irradiance data. The base package in this suite is called \PB, and is the package described here. There other especialized packages for quantification of ultraviolet radiation (\PBUV), visible radiation (\PBVIS), or based on Phytochrome (\PBPHY), Cryptochrome (\PBCRY) (both photoreceptors present in plants), and 
spectral data for filters (\PBFLT). In the future it will be submitted to CRAN (Comprehensive R archive network), it is meanwhile available from \url{https://bitbucket.org/aphalo/photobiology/downloads}. There is also a public Git repository at \url{https://bitbucket.org/aphalo/photobiology} from where the source code of the current an earlier versions can be cloned.

\section{Installation and use}

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(fig.path='figure/pos-', fig.align='center', fig.show='hold', size="footnotesize", dev='cairo_pdf')
options(replace.assign=TRUE,width=60)
@

The functions in the package \PBPHY are
made available by installing the packages \verb!photobiology! (once) and
loading it from the library when needed.

To load the package into the workspace we use \verb!library(photobiology)!.

<<example-0, eval=TRUE>>=
library(photobiology)
library(photobiologyUV)
library(photobiologyVIS)
@

% \section{Example of spectral data}
% 
% Depending on the format of the spectral data you will have
% to use different approaches to import them into your R
% workspace. We here give an example for a `comma separated
% values' text file. 
% 
% In such a case we load the spectral data into R using \verb!read.table()!
% or \verb!read.csv()!.
% 
% A file from a Macam
% spectroradiometer starts:
% \lstset{language=}
% \lstinputlisting[lastline=20]{Philips_TL12.csv}
% \lstset{language=R}
% 
% \sloppy
% For a file like this one, use the code below but
% replacing "name" with the name and path to the data file. On Windows systems you need
% to scape backslashes in file paths like this: `\verb!\\!'.
% 
% <<eval=FALSE, echo=FALSE>>=
% setwd("vignettes")
% @
% 
% <<example-1, eval=TRUE>>=
% my.data <- read.csv(file="Philips_TL12.csv", skip=1,
%   col.names=c("wavelength", "irrad"))
% attach(my.data)
% energy_irradiance(wavelength,irrad,CIE())
% @
% 
% <<eval=FALSE, echo=FALSE>>=
% setwd("..")
% @

\section{Spectral data }
If our spectral irradiance data is in \wattnm, and the wavelength in nm, as in the case of
the Macam spectroradiometer, the functions will return the effective irradiance in \watt. In this
example we calculated a biologically effective irradiance. 

If, for example, the spectral irradiance output by our model of spectroradiometer is in m\wattnm,
and the wavelengths are in Ã…ngstrom then to obtain the effective irradiance in \watt we will
need to convert the units.

<<example-1, eval=FALSE>>=
energy_irradiance(wavelength/10,irrad/1000)
@

In this example, we take advantage of the behaviour of the S language: an operation between a scalar
and vector, is equivalent to applying this operation to each member of the vector.
Consequently, in the code above, each value from the vector of wavelengths is divided
by 10, and each value in the vector of spectral irradiances is divided by 1000.

If the spectral irradiance is in \mwattnm then values should be multiplied by 10 to
convert them to \wattnm.

It is very important to make sure that the wavelengths are in nanometers as this is what
the functions expect. If the wavelengths are in the wrong units, the action spectra will be
wrongly calculated, and the returned value for effective irradiance will be completely wrong.

Here we just use the example data supplied with the package.

\section{Defining wavebands}

All functions use \texttt{waveband}s as definitions of the range of wave lengths and the spectral weighting function (SWF) to use in the calculations. A few other bits of information may be included to fine-tune calculations. The waveband definifitions do NOT describe whether input spectral irradiances are photon or energy based, nor whether the output irradiance will be based on photon or energy units.

When defining a waveband which uses a SWF, a function can be supplied either based on energy effectiveness, on photon effectiveness, or one function for each one. If only one function is supplied the other one is built automatically, but if performance is a concern it is better to provide two separate functions. Another case when you might want to enter the same function twice, is if you are using an absorptance spectrum as SWF, as the percent of radiation absorbed will be independent of whether photon or energy units are used for the spectral irradiance. 

<<example-waveband-01, eval=TRUE>>=
my_PAR <- new_waveband(400, 700)

my_CIE_1 <- new_waveband(250, 400, weight="SWF", SWF.e.fun=CIE.e.fun, SWF.norm=298)
my_CIE_2 <- new_waveband(250, 400, weight="SWF", SWF.q.fun=CIE.q.fun, SWF.norm=298)
my_CIE_3 <- new_waveband(250, 400, weight="SWF", SWF.e.fun=CIE.e.fun, 
                         SWF.q.fun=CIE.q.fun, SWF.norm=298)
@

\section{Calculating irradiance or exposure}

There is one basic function for these calculations \texttt{irradiance()}, it takes an array of wavelengths (sorted in strictly increasing order), and the corresponding values of spectral irradiance. By default the input is assumed to be in energy units, but parameter \texttt{unit.in} cab be used to adjust the calculations to expect photon units. The type of unit used for the calculated irradiance (or expossure) is set by the parameter \texttt{unit.out} with no default. If no \texttt{w.band} parameter is supplied, the whole spectrum spectrum input is used, unweighted, to calculate the total irradiance. If a \texttt{w.band} is supplied, then the range of wavelengths specified and SWF if present are used for calculating the irradiance. If the waveband definition does not include a SWF, then the unweighted irradiance is returned, if the definition includes a SWF, then a weighted irradiance is returned.  

The functions \texttt{photon\_irradiance()} and \texttt{energy\_irradiance()}, just call \texttt{irradiance()} with the \texttt{unit.out} set to \texttt{"photon"} or \texttt{"energy"} respectively.

We first load some data to play with.

<<example-data, eval=TRUE>>=
data(sun.data)
attach(sun.data)
@

Then we compare the calculations based on the different wavebands defined in the previous section and the predefined functions in the packages \PBVIS and \PBUV. The predefined functions have the advantaje of allowing the specification of parameters to modify the \texttt{w.band} created. In the example bellow, we use this to set the normalization wavelength.

This is how CIE() is defined in \PBUV.

<<example-CIE, eval=FALSE>>=
CIE <- function(norm=298) {
  new_waveband(w.low=250, w.high=400, 
               weight="SWF", SWF.e.fun=CIE.e.fun, SWF.norm=298, 
               norm=norm, hinges=c(249.99, 250, 298, 328, 399.99, 400), 
               wb.name=paste("CIE98", as.character(norm), sep="."))
}
@

Now the example calculations.

<<example-irradiance-01>>=
photon_irradiance(w.length, s.e.irrad, my_PAR)

library(photobiologyVIS)
photon_irradiance(w.length, s.e.irrad, PAR())

photon_irradiance(w.length, s.e.irrad, my_CIE_1)
photon_irradiance(w.length, s.e.irrad, my_CIE_2)
photon_irradiance(w.length, s.e.irrad, my_CIE_3)

energy_irradiance(w.length, s.e.irrad, my_CIE_1)
energy_irradiance(w.length, s.e.irrad, my_CIE_2)
energy_irradiance(w.length, s.e.irrad, my_CIE_3)

energy_irradiance(w.length, s.e.irrad, CIE())
energy_irradiance(w.length, s.e.irrad, CIE(298))
energy_irradiance(w.length, s.e.irrad, CIE(300))
@

\section{Calculating ratios}

The function \texttt{waveband\_ratio()} takes basically the same parameters as as \texttt{irradiance}, but two waveband definitions instead of one, and two \texttt{unit.out} definitions instead of one. This is the base function used in all the `ratio' functions in the \PB package.

\sloppy
The derived functions are: \texttt{photon\_ratio()}, \texttt{energy\_ratio()}, and \texttt{photons\_energy\_ratio}. The packages \PBVIS and \PBUV use these to define some convenience functions, and here we give and example for a function not yet implemented, but which you may find as a useful example.

If for example we would like to calcualte the ratio between UVB and PAR radiation, we would use either 
of the following function calls, depending on which type of units we desire.

<<example-ratios-01>>=
photon_ratio(w.length, s.e.irrad, UVB(), PAR())
energy_ratio(w.length, s.e.irrad, UVB(), PAR())
@

If we would like to calculate a conversion factor between PPFD (PAR photon irradiance in mol s-1 m-2) and PAR (energy) irradiance (W m-2) for a light source for which we have spectral data we could use the following code.

<<example-ratios-02>>=
conv.factor <- photons_energy_ratio(w.length, s.e.irrad, PAR())

PPFD.mol.photon <- 1000e-6
PAR.energy <- PPFD.mol.photon / conv.factor
print(conv.factor)
print(PPFD.mol.photon * 1e6)
print(PAR.energy)
@

\section{Calculating weighted spectral irradiances}

This calculation is not very frequently used, but it is very instructive to look at spectral data in this way, as it can make apparent the large effect that small measuring errors can have on the estimated effective irradiances or exposures.

We here plot weighted and unweighted irradiances using simulated solar spectral irradiance data. 

%\cite{Kotilainenxxxx, Lindforsxxxx}.

<<weighted-spectra-01, tidy=FALSE>>=
weighted.s.e.irrad <- s.e.irrad * calc_multipliers(w.length, GEN.T())
plot(weighted.s.e.irrad/max(weighted.s.e.irrad) ~ w.length, type="l", col="red", 
     xlab="Wavelength (nm)", 
     ylab="UnWeighted and GEN.T weighted spectral irradiance (relative units)")
lines(s.e.irrad/max(s.e.irrad) ~ w.length, col="black")
@

\section{Dealing with real `noisy' spectral data}

The first thing to do is to think whether any part of the spectral measurements can be \textit{a priori} known to be equal to zero. For example for the solar spectrum at ground level it is safe to assume that the spectral irradiance is zero for all wavelengths shorter than 293~nm. If the data are noisy, it is best to discard these data before calculating any effective UV doses. This can be easily done as follows if the data are in a data.frame (of course, replacing \texttt{w.length} with the name used in your data frame for the wavelengths array:

<<example-subset>>=
subsetted.sun.data <- subset(sun.data, w.length >= 293)
head(subsetted.sun.data)
@

And then just use the trimmed data in your calculations.

If the data are not in a dataframe, then there are different options: 1) create a data frame from your data, 2) use the function \texttt{trim\_tails()} from this package, or 3) just use R commands. Here we give an example of the use of \texttt{trim\_tails()}, and just as an example, we use the same data:

<<example-trim>>=
trimmed.sun.data <- trim_tails(w.length, s.e.irrad, low=293)
head(trimmed.sun.data)
@

This function returns a new data.frame and uses always the same variable names for the columns.

<<detach>>=
detach(sun.data)
@

Using real spectral data compared to modelled spectral data for sunlight we show a finally some of the pitfalls, and possible work-arounds, for dealing with noisy measurements, and calculating effective doses from them.

\section{Auxiliary function}

Sometimes it is needed to add (parallel sum) between two spectra, even if the two spectra have been
measured at different wavelengths or wavelength steps. This can happen for example when we would like
to calculate the spectrum of a combination of two light sources from the individual spectra. The
function \verb|sum_spectra()| can be used in such a case. It's use is described in User Guide of the 
\PBLA package.

A function \verb|interpolate_spectrum| is also included to facilitate interpolation of spectral values. It is used in the function described in the previous paragraph, but facilitate interpolation.
Under the hood it uses R's \verb|spline| function, but it allows more easy control of values to be
used for extrapolation.
 
\section{Optimizing performance}

When developing the current version of \PB quite a lot of effort was spent in optimizing performance, as in one of our experiments, we need to process several tens of thoudsands of measured spectra. The defaults should provide good performance in most cases, however, some further improvements are achievable, when a series of different calculations are done on the same spectrum, or when a series of spectra measured at exactly the same wavelengths are used for calculating weighted irradiances or exposures.

In the case of doing calculations repeatedly on the same spectrum, a small imrovement in performance can be achieved by setting the parameter \texttt{check.spectrum=FALSE} for all but the first call to \texttt{irradiance()}, or \texttt{photon\_irradiance()}, or \texttt{energy\_irradiance()}, or the equivalent function for ratios. It is also possible to set this parameter to FALSE in all calls, and do the check beforehand by calling \texttt{check\_spectrum()}.

In the case of calculating weighted irradiances on many spectra having exactly the same wavelength values, then a significant improvement in the performance can be achieved by setting \texttt{use.cached.mult=TRUE}, as this reuses the multipliers calculated during succesive calls based on the same waveband. However, to achiev this increase in performance, the tests to ensure that the wavelength values have not changed, have to be kept to the minimum. Currently only the length of the wavelength array is checked, and the cached recalculated if the length changes. For this reason, this is not the default, and when using caching the user is responsible for making sure that the array of wavelengths has not changed between calls.

The option not to use C++ code is mainly there to be able to test the code and measure the improvement in performance. I see no reason for disabling C++ code, as it does exactly the same calculation but much faster.
 
\end{document}
